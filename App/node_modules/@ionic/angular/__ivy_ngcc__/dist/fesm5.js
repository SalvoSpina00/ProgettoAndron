import { __extends, __awaiter, __generator, __assign } from 'tslib';
import { HostListener, Directive, ElementRef, Injectable, Inject, NgZone, defineInjectable, inject, Optional, Component, ChangeDetectionStrategy, ChangeDetectorRef, InjectionToken, ApplicationRef, Injector, ViewContainerRef, ComponentFactoryResolver, Attribute, SkipSelf, Output, EventEmitter, ViewChild, ContentChild, TemplateRef, IterableDiffers, APP_INITIALIZER, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { DOCUMENT, Location, LocationStrategy, CommonModule } from '@angular/common';
import { UrlSerializer, Router, NavigationStart, ActivatedRoute, ChildrenOutletContexts, PRIMARY_OUTLET, RouterLink } from '@angular/router';
import { isPlatform, getPlatforms, LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD, actionSheetController, alertController, loadingController, menuController, pickerController, modalController, popoverController, toastController } from '@ionic/core';
import { Subject, fromEvent, BehaviorSubject } from 'rxjs';
import { filter, switchMap, distinctUntilChanged } from 'rxjs/operators';
import { applyPolyfills, defineCustomElements } from '@ionic/core/loader';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/router';

var _c0 = ["*"];
var _c1 = ["outlet"];
var _c2 = [[["", "slot", "top"]], "*"];
var _c3 = ["[slot=top]", "*"];
var raf = (/**
 * @param {?} h
 * @return {?}
 */
function (h) {
    if (typeof __zone_symbol__requestAnimationFrame === 'function') {
        return __zone_symbol__requestAnimationFrame(h);
    }
    if (typeof requestAnimationFrame === 'function') {
        return requestAnimationFrame(h);
    }
    return setTimeout(h);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ValueAccessor = /** @class */ (function () {
    function ValueAccessor(el) {
        this.el = el;
        this.onChange = (/**
         * @return {?}
         */
        function () { });
        this.onTouched = (/**
         * @return {?}
         */
        function () { });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    ValueAccessor.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.el.nativeElement.value = this.lastValue = value == null ? '' : value;
        setIonicClasses(this.el);
    };
    /**
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    ValueAccessor.prototype.handleChangeEvent = /**
     * @param {?} el
     * @param {?} value
     * @return {?}
     */
    function (el, value) {
        if (el === this.el.nativeElement) {
            if (value !== this.lastValue) {
                this.lastValue = value;
                this.onChange(value);
            }
            setIonicClasses(this.el);
        }
    };
    /**
     * @param {?} el
     * @return {?}
     */
    ValueAccessor.prototype._handleBlurEvent = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        if (el === this.el.nativeElement) {
            this.onTouched();
            setIonicClasses(this.el);
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ValueAccessor.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ValueAccessor.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    ValueAccessor.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.el.nativeElement.disabled = isDisabled;
    };
    ValueAccessor.propDecorators = {
        _handleBlurEvent: [{ type: HostListener, args: ['ionBlur', ['$event.target'],] }]
    };
ValueAccessor.ɵfac = function ValueAccessor_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ValueAccessor, hostBindings: function ValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("ionBlur", function ValueAccessor_ionBlur_HostBindingHandler($event) { return ctx._handleBlurEvent($event.target); });
    } } });

    return ValueAccessor;
}());
/** @type {?} */
var setIonicClasses = (/**
 * @param {?} element
 * @return {?}
 */
function (element) {
    raf((/**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var input = (/** @type {?} */ (element.nativeElement));
        /** @type {?} */
        var classes = getClasses(input);
        setClasses(input, classes);
        /** @type {?} */
        var item = input.closest('ion-item');
        if (item) {
            setClasses(item, classes);
        }
    }));
});
/** @type {?} */
var getClasses = (/**
 * @param {?} element
 * @return {?}
 */
function (element) {
    /** @type {?} */
    var classList = element.classList;
    /** @type {?} */
    var classes = [];
    for (var i = 0; i < classList.length; i++) {
        /** @type {?} */
        var item = classList.item(i);
        if (item !== null && startsWith(item, 'ng-')) {
            classes.push("ion-" + item.substr(3));
        }
    }
    return classes;
});
/** @type {?} */
var setClasses = (/**
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
function (element, classes) {
    /** @type {?} */
    var classList = element.classList;
    [
        'ion-valid',
        'ion-invalid',
        'ion-touched',
        'ion-untouched',
        'ion-dirty',
        'ion-pristine'
    ].forEach((/**
     * @param {?} c
     * @return {?}
     */
    function (c) { return classList.remove(c); }));
    classes.forEach((/**
     * @param {?} c
     * @return {?}
     */
    function (c) { return classList.add(c); }));
});
/** @type {?} */
var startsWith = (/**
 * @param {?} input
 * @param {?} search
 * @return {?}
 */
function (input, search) {
    return input.substr(0, search.length) === search;
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BooleanValueAccessor = /** @class */ (function (_super) {
    __extends(BooleanValueAccessor, _super);
    function BooleanValueAccessor(el) {
        return _super.call(this, el) || this;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    BooleanValueAccessor.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.el.nativeElement.checked = this.lastValue = value == null ? false : value;
        setIonicClasses(this.el);
    };
    /**
     * @param {?} el
     * @return {?}
     */
    BooleanValueAccessor.prototype._handleIonChange = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        this.handleChangeEvent(el, el.checked);
    };
    /** @nocollapse */
    BooleanValueAccessor.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    BooleanValueAccessor.propDecorators = {
        _handleIonChange: [{ type: HostListener, args: ['ionChange', ['$event.target'],] }]
    };
BooleanValueAccessor.ɵfac = function BooleanValueAccessor_Factory(t) { return new (t || BooleanValueAccessor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
BooleanValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BooleanValueAccessor, selectors: [["ion-checkbox"], ["ion-toggle"]], hostBindings: function BooleanValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("ionChange", function BooleanValueAccessor_ionChange_HostBindingHandler($event) { return ctx._handleIonChange($event.target); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: BooleanValueAccessor,
                multi: true
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BooleanValueAccessor, [{
        type: Directive,
        args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'ion-checkbox,ion-toggle',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: BooleanValueAccessor,
                        multi: true
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { _handleIonChange: [{
            type: HostListener,
            args: ['ionChange', ['$event.target']]
        }] }); })();
    return BooleanValueAccessor;
}(ValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NumericValueAccessor = /** @class */ (function (_super) {
    __extends(NumericValueAccessor, _super);
    function NumericValueAccessor(el) {
        return _super.call(this, el) || this;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    NumericValueAccessor.prototype._handleIonChange = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        this.handleChangeEvent(el, el.value);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NumericValueAccessor.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        _super.prototype.registerOnChange.call(this, (/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            fn(value === '' ? null : parseFloat(value));
        }));
    };
    /** @nocollapse */
    NumericValueAccessor.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    NumericValueAccessor.propDecorators = {
        _handleIonChange: [{ type: HostListener, args: ['ionChange', ['$event.target'],] }]
    };
NumericValueAccessor.ɵfac = function NumericValueAccessor_Factory(t) { return new (t || NumericValueAccessor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NumericValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NumericValueAccessor, selectors: [["ion-input", "type", "number"]], hostBindings: function NumericValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("ionChange", function NumericValueAccessor_ionChange_HostBindingHandler($event) { return ctx._handleIonChange($event.target); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: NumericValueAccessor,
                multi: true
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumericValueAccessor, [{
        type: Directive,
        args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'ion-input[type=number]',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: NumericValueAccessor,
                        multi: true
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { _handleIonChange: [{
            type: HostListener,
            args: ['ionChange', ['$event.target']]
        }] }); })();
    return NumericValueAccessor;
}(ValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RadioValueAccessor = /** @class */ (function (_super) {
    __extends(RadioValueAccessor, _super);
    function RadioValueAccessor(el) {
        return _super.call(this, el) || this;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    RadioValueAccessor.prototype._handleIonSelect = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        this.handleChangeEvent(el, el.checked);
    };
    /** @nocollapse */
    RadioValueAccessor.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    RadioValueAccessor.propDecorators = {
        _handleIonSelect: [{ type: HostListener, args: ['ionSelect', ['$event.target'],] }]
    };
RadioValueAccessor.ɵfac = function RadioValueAccessor_Factory(t) { return new (t || RadioValueAccessor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
RadioValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RadioValueAccessor, selectors: [["ion-radio"]], hostBindings: function RadioValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("ionSelect", function RadioValueAccessor_ionSelect_HostBindingHandler($event) { return ctx._handleIonSelect($event.target); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: RadioValueAccessor,
                multi: true
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RadioValueAccessor, [{
        type: Directive,
        args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'ion-radio',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: RadioValueAccessor,
                        multi: true
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { _handleIonSelect: [{
            type: HostListener,
            args: ['ionSelect', ['$event.target']]
        }] }); })();
    return RadioValueAccessor;
}(ValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SelectValueAccessor = /** @class */ (function (_super) {
    __extends(SelectValueAccessor, _super);
    function SelectValueAccessor(el) {
        return _super.call(this, el) || this;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    SelectValueAccessor.prototype._handleChangeEvent = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        this.handleChangeEvent(el, el.value);
    };
    /** @nocollapse */
    SelectValueAccessor.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    SelectValueAccessor.propDecorators = {
        _handleChangeEvent: [{ type: HostListener, args: ['ionChange', ['$event.target'],] }]
    };
SelectValueAccessor.ɵfac = function SelectValueAccessor_Factory(t) { return new (t || SelectValueAccessor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
SelectValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SelectValueAccessor, selectors: [["ion-range"], ["ion-select"], ["ion-radio-group"], ["ion-segment"], ["ion-datetime"]], hostBindings: function SelectValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("ionChange", function SelectValueAccessor_ionChange_HostBindingHandler($event) { return ctx._handleChangeEvent($event.target); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: SelectValueAccessor,
                multi: true
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SelectValueAccessor, [{
        type: Directive,
        args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'ion-range, ion-select, ion-radio-group, ion-segment, ion-datetime',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: SelectValueAccessor,
                        multi: true
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { _handleChangeEvent: [{
            type: HostListener,
            args: ['ionChange', ['$event.target']]
        }] }); })();
    return SelectValueAccessor;
}(ValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TextValueAccessor = /** @class */ (function (_super) {
    __extends(TextValueAccessor, _super);
    function TextValueAccessor(el) {
        return _super.call(this, el) || this;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    TextValueAccessor.prototype._handleInputEvent = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        this.handleChangeEvent(el, el.value);
    };
    /** @nocollapse */
    TextValueAccessor.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    TextValueAccessor.propDecorators = {
        _handleInputEvent: [{ type: HostListener, args: ['ionChange', ['$event.target'],] }]
    };
TextValueAccessor.ɵfac = function TextValueAccessor_Factory(t) { return new (t || TextValueAccessor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
TextValueAccessor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TextValueAccessor, selectors: [["ion-input", 3, "type", "number"], ["ion-textarea"], ["ion-searchbar"]], hostBindings: function TextValueAccessor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("ionChange", function TextValueAccessor_ionChange_HostBindingHandler($event) { return ctx._handleInputEvent($event.target); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: TextValueAccessor,
                multi: true
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TextValueAccessor, [{
        type: Directive,
        args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'ion-input:not([type=number]),ion-textarea,ion-searchbar',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: TextValueAccessor,
                        multi: true
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { _handleInputEvent: [{
            type: HostListener,
            args: ['ionChange', ['$event.target']]
        }] }); })();
    return TextValueAccessor;
}(ValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Platform = /** @class */ (function () {
    function Platform(doc, zone) {
        var _this = this;
        this.doc = doc;
        /**
         * @hidden
         */
        this.backButton = (/** @type {?} */ (new Subject()));
        /**
         * The pause event emits when the native platform puts the application
         * into the background, typically when the user switches to a different
         * application. This event would emit when a Cordova app is put into
         * the background, however, it would not fire on a standard web browser.
         */
        this.pause = new Subject();
        /**
         * The resume event emits when the native platform pulls the application
         * out from the background. This event would emit when a Cordova app comes
         * out from the background, however, it would not fire on a standard web browser.
         */
        this.resume = new Subject();
        /**
         * The resize event emits when the browser window has changed dimensions. This
         * could be from a browser window being physically resized, or from a device
         * changing orientation.
         */
        this.resize = new Subject();
        zone.run((/**
         * @return {?}
         */
        function () {
            _this.win = doc.defaultView;
            _this.backButton.subscribeWithPriority = (/**
             * @param {?} priority
             * @param {?} callback
             * @return {?}
             */
            function (priority, callback) {
                return this.subscribe((/**
                 * @param {?} ev
                 * @return {?}
                 */
                function (ev) { return (ev.register(priority, (/**
                 * @return {?}
                 */
                function () { return zone.run(callback); }))); }));
            });
            proxyEvent(_this.pause, doc, 'pause');
            proxyEvent(_this.resume, doc, 'resume');
            proxyEvent(_this.backButton, doc, 'ionBackButton');
            proxyEvent(_this.resize, _this.win, 'resize');
            /** @type {?} */
            var readyResolve;
            _this._readyPromise = new Promise((/**
             * @param {?} res
             * @return {?}
             */
            function (res) { readyResolve = res; }));
            if (_this.win && _this.win['cordova']) {
                doc.addEventListener('deviceready', (/**
                 * @return {?}
                 */
                function () {
                    readyResolve('cordova');
                }), { once: true });
            }
            else {
                (/** @type {?} */ (readyResolve))('dom');
            }
        }));
    }
    /**
     * @returns returns true/false based on platform.
     * @description
     * Depending on the platform the user is on, `is(platformName)` will
     * return `true` or `false`. Note that the same app can return `true`
     * for more than one platform name. For example, an app running from
     * an iPad would return `true` for the platform names: `mobile`,
     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running
     * from Cordova then `cordova` would be true, and if it was running
     * from a web browser on the iPad then `mobileweb` would be `true`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * @Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     if (this.platform.is('ios')) {
     *       // This will only print when on iOS
     *       console.log('I am an iOS device!');
     *     }
     *   }
     * }
     * ```
     *
     * | Platform Name   | Description                        |
     * |-----------------|------------------------------------|
     * | android         | on a device running Android.       |
     * | cordova         | on a device running Cordova.       |
     * | ios             | on a device running iOS.           |
     * | ipad            | on an iPad device.                 |
     * | iphone          | on an iPhone device.               |
     * | phablet         | on a phablet device.               |
     * | tablet          | on a tablet device.                |
     * | electron        | in Electron on a desktop device.   |
     * | pwa             | as a PWA app.                      |
     * | mobile          | on a mobile device.                |
     * | mobileweb       | on a mobile device in a browser.   |
     * | desktop         | on a desktop device.               |
     * | hybrid          | is a cordova or capacitor app.     |
     *
     */
    /**
     * \@description
     * Depending on the platform the user is on, `is(platformName)` will
     * return `true` or `false`. Note that the same app can return `true`
     * for more than one platform name. For example, an app running from
     * an iPad would return `true` for the platform names: `mobile`,
     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running
     * from Cordova then `cordova` would be true, and if it was running
     * from a web browser on the iPad then `mobileweb` would be `true`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * \@Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     if (this.platform.is('ios')) {
     *       // This will only print when on iOS
     *       console.log('I am an iOS device!');
     *     }
     *   }
     * }
     * ```
     *
     * | Platform Name   | Description                        |
     * |-----------------|------------------------------------|
     * | android         | on a device running Android.       |
     * | cordova         | on a device running Cordova.       |
     * | ios             | on a device running iOS.           |
     * | ipad            | on an iPad device.                 |
     * | iphone          | on an iPhone device.               |
     * | phablet         | on a phablet device.               |
     * | tablet          | on a tablet device.                |
     * | electron        | in Electron on a desktop device.   |
     * | pwa             | as a PWA app.                      |
     * | mobile          | on a mobile device.                |
     * | mobileweb       | on a mobile device in a browser.   |
     * | desktop         | on a desktop device.               |
     * | hybrid          | is a cordova or capacitor app.     |
     *
     * @param {?} platformName
     * @return {?} returns true/false based on platform.
     */
    Platform.prototype.is = /**
     * \@description
     * Depending on the platform the user is on, `is(platformName)` will
     * return `true` or `false`. Note that the same app can return `true`
     * for more than one platform name. For example, an app running from
     * an iPad would return `true` for the platform names: `mobile`,
     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running
     * from Cordova then `cordova` would be true, and if it was running
     * from a web browser on the iPad then `mobileweb` would be `true`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * \@Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     if (this.platform.is('ios')) {
     *       // This will only print when on iOS
     *       console.log('I am an iOS device!');
     *     }
     *   }
     * }
     * ```
     *
     * | Platform Name   | Description                        |
     * |-----------------|------------------------------------|
     * | android         | on a device running Android.       |
     * | cordova         | on a device running Cordova.       |
     * | ios             | on a device running iOS.           |
     * | ipad            | on an iPad device.                 |
     * | iphone          | on an iPhone device.               |
     * | phablet         | on a phablet device.               |
     * | tablet          | on a tablet device.                |
     * | electron        | in Electron on a desktop device.   |
     * | pwa             | as a PWA app.                      |
     * | mobile          | on a mobile device.                |
     * | mobileweb       | on a mobile device in a browser.   |
     * | desktop         | on a desktop device.               |
     * | hybrid          | is a cordova or capacitor app.     |
     *
     * @param {?} platformName
     * @return {?} returns true/false based on platform.
     */
    function (platformName) {
        return isPlatform(this.win, platformName);
    };
    /**
     * @returns the array of platforms
     * @description
     * Depending on what device you are on, `platforms` can return multiple values.
     * Each possible value is a hierarchy of platforms. For example, on an iPhone,
     * it would return `mobile`, `ios`, and `iphone`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * @Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     // This will print an array of the current platforms
     *     console.log(this.platform.platforms());
     *   }
     * }
     * ```
     */
    /**
     * \@description
     * Depending on what device you are on, `platforms` can return multiple values.
     * Each possible value is a hierarchy of platforms. For example, on an iPhone,
     * it would return `mobile`, `ios`, and `iphone`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * \@Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     // This will print an array of the current platforms
     *     console.log(this.platform.platforms());
     *   }
     * }
     * ```
     * @return {?} the array of platforms
     */
    Platform.prototype.platforms = /**
     * \@description
     * Depending on what device you are on, `platforms` can return multiple values.
     * Each possible value is a hierarchy of platforms. For example, on an iPhone,
     * it would return `mobile`, `ios`, and `iphone`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * \@Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     // This will print an array of the current platforms
     *     console.log(this.platform.platforms());
     *   }
     * }
     * ```
     * @return {?} the array of platforms
     */
    function () {
        return getPlatforms(this.win);
    };
    /**
     * Returns a promise when the platform is ready and native functionality
     * can be called. If the app is running from within a web browser, then
     * the promise will resolve when the DOM is ready. When the app is running
     * from an application engine such as Cordova, then the promise will
     * resolve when Cordova triggers the `deviceready` event.
     *
     * The resolved value is the `readySource`, which states which platform
     * ready was used. For example, when Cordova is ready, the resolved ready
     * source is `cordova`. The default ready source value will be `dom`. The
     * `readySource` is useful if different logic should run depending on the
     * platform the app is running from. For example, only Cordova can execute
     * the status bar plugin, so the web should not run status bar plugin logic.
     *
     * ```
     * import { Component } from '@angular/core';
     * import { Platform } from 'ionic-angular';
     *
     * @Component({...})
     * export MyApp {
     *   constructor(public platform: Platform) {
     *     this.platform.ready().then((readySource) => {
     *       console.log('Platform ready from', readySource);
     *       // Platform now ready, execute any required native code
     *     });
     *   }
     * }
     * ```
     */
    /**
     * Returns a promise when the platform is ready and native functionality
     * can be called. If the app is running from within a web browser, then
     * the promise will resolve when the DOM is ready. When the app is running
     * from an application engine such as Cordova, then the promise will
     * resolve when Cordova triggers the `deviceready` event.
     *
     * The resolved value is the `readySource`, which states which platform
     * ready was used. For example, when Cordova is ready, the resolved ready
     * source is `cordova`. The default ready source value will be `dom`. The
     * `readySource` is useful if different logic should run depending on the
     * platform the app is running from. For example, only Cordova can execute
     * the status bar plugin, so the web should not run status bar plugin logic.
     *
     * ```
     * import { Component } from '\@angular/core';
     * import { Platform } from 'ionic-angular';
     *
     * \@Component({...})
     * export MyApp {
     *   constructor(public platform: Platform) {
     *     this.platform.ready().then((readySource) => {
     *       console.log('Platform ready from', readySource);
     *       // Platform now ready, execute any required native code
     *     });
     *   }
     * }
     * ```
     * @return {?}
     */
    Platform.prototype.ready = /**
     * Returns a promise when the platform is ready and native functionality
     * can be called. If the app is running from within a web browser, then
     * the promise will resolve when the DOM is ready. When the app is running
     * from an application engine such as Cordova, then the promise will
     * resolve when Cordova triggers the `deviceready` event.
     *
     * The resolved value is the `readySource`, which states which platform
     * ready was used. For example, when Cordova is ready, the resolved ready
     * source is `cordova`. The default ready source value will be `dom`. The
     * `readySource` is useful if different logic should run depending on the
     * platform the app is running from. For example, only Cordova can execute
     * the status bar plugin, so the web should not run status bar plugin logic.
     *
     * ```
     * import { Component } from '\@angular/core';
     * import { Platform } from 'ionic-angular';
     *
     * \@Component({...})
     * export MyApp {
     *   constructor(public platform: Platform) {
     *     this.platform.ready().then((readySource) => {
     *       console.log('Platform ready from', readySource);
     *       // Platform now ready, execute any required native code
     *     });
     *   }
     * }
     * ```
     * @return {?}
     */
    function () {
        return this._readyPromise;
    };
    Object.defineProperty(Platform.prototype, "isRTL", {
        /**
         * Returns if this app is using right-to-left language direction or not.
         * We recommend the app's `index.html` file already has the correct `dir`
         * attribute value set, such as `<html dir="ltr">` or `<html dir="rtl">`.
         * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
         */
        get: /**
         * Returns if this app is using right-to-left language direction or not.
         * We recommend the app's `index.html` file already has the correct `dir`
         * attribute value set, such as `<html dir="ltr">` or `<html dir="rtl">`.
         * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
         * @return {?}
         */
        function () {
            return this.doc.dir === 'rtl';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the query string parameter
     */
    /**
     * Get the query string parameter
     * @param {?} key
     * @return {?}
     */
    Platform.prototype.getQueryParam = /**
     * Get the query string parameter
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return readQueryParam(this.win.location.href, key);
    };
    /**
     * Returns `true` if the app is in landscape mode.
     */
    /**
     * Returns `true` if the app is in landscape mode.
     * @return {?}
     */
    Platform.prototype.isLandscape = /**
     * Returns `true` if the app is in landscape mode.
     * @return {?}
     */
    function () {
        return !this.isPortrait();
    };
    /**
     * Returns `true` if the app is in portait mode.
     */
    /**
     * Returns `true` if the app is in portait mode.
     * @return {?}
     */
    Platform.prototype.isPortrait = /**
     * Returns `true` if the app is in portait mode.
     * @return {?}
     */
    function () {
        return this.win.matchMedia && this.win.matchMedia('(orientation: portrait)').matches;
    };
    /**
     * @param {?} expression
     * @return {?}
     */
    Platform.prototype.testUserAgent = /**
     * @param {?} expression
     * @return {?}
     */
    function (expression) {
        /** @type {?} */
        var nav = this.win.navigator;
        return !!(nav && nav.userAgent && nav.userAgent.indexOf(expression) >= 0);
    };
    /**
     * Get the current url.
     */
    /**
     * Get the current url.
     * @return {?}
     */
    Platform.prototype.url = /**
     * Get the current url.
     * @return {?}
     */
    function () {
        return this.win.location.href;
    };
    /**
     * Gets the width of the platform's viewport using `window.innerWidth`.
     */
    /**
     * Gets the width of the platform's viewport using `window.innerWidth`.
     * @return {?}
     */
    Platform.prototype.width = /**
     * Gets the width of the platform's viewport using `window.innerWidth`.
     * @return {?}
     */
    function () {
        return this.win.innerWidth;
    };
    /**
     * Gets the height of the platform's viewport using `window.innerHeight`.
     */
    /**
     * Gets the height of the platform's viewport using `window.innerHeight`.
     * @return {?}
     */
    Platform.prototype.height = /**
     * Gets the height of the platform's viewport using `window.innerHeight`.
     * @return {?}
     */
    function () {
        return this.win.innerHeight;
    };
    /** @nocollapse */
    Platform.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: NgZone }
    ]; };
    /** @nocollapse */ Platform.ngInjectableDef = defineInjectable({ factory: function Platform_Factory() { return new Platform(inject(DOCUMENT), inject(NgZone)); }, token: Platform, providedIn: "root" });
Platform.ɵfac = function Platform_Factory(t) { return new (t || Platform)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
Platform.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Platform, factory: function (t) { return Platform.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Platform, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.NgZone }]; }, null); })();
    return Platform;
}());
/** @type {?} */
var readQueryParam = (/**
 * @param {?} url
 * @param {?} key
 * @return {?}
 */
function (url, key) {
    key = key.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    /** @type {?} */
    var regex = new RegExp('[\\?&]' + key + '=([^&#]*)');
    /** @type {?} */
    var results = regex.exec(url);
    return results ? decodeURIComponent(results[1].replace(/\+/g, ' ')) : null;
});
/** @type {?} */
var proxyEvent = (/**
 * @template T
 * @param {?} emitter
 * @param {?} el
 * @param {?} eventName
 * @return {?}
 */
function (emitter, el, eventName) {
    if (((/** @type {?} */ (el)))) {
        el.addEventListener(eventName, (/**
         * @param {?} ev
         * @return {?}
         */
        function (ev) {
            // ?? cordova might emit "null" events
            emitter.next(ev != null ? (/** @type {?} */ (((/** @type {?} */ (ev))).detail)) : undefined);
        }));
    }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NavController = /** @class */ (function () {
    function NavController(platform, location, serializer, router) {
        var _this = this;
        this.location = location;
        this.serializer = serializer;
        this.router = router;
        this.direction = DEFAULT_DIRECTION;
        this.animated = DEFAULT_ANIMATED;
        this.guessDirection = 'forward';
        this.lastNavId = -1;
        // Subscribe to router events to detect direction
        if (router) {
            router.events.subscribe((/**
             * @param {?} ev
             * @return {?}
             */
            function (ev) {
                if (ev instanceof NavigationStart) {
                    /** @type {?} */
                    var id = (ev.restoredState) ? ev.restoredState.navigationId : ev.id;
                    _this.guessDirection = id < _this.lastNavId ? 'back' : 'forward';
                    _this.guessAnimation = !ev.restoredState ? _this.guessDirection : undefined;
                    _this.lastNavId = _this.guessDirection === 'forward' ? ev.id : id;
                }
            }));
        }
        // Subscribe to backButton events
        platform.backButton.subscribeWithPriority(0, (/**
         * @return {?}
         */
        function () { return _this.pop(); }));
    }
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.
     *
     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),
     * and that it will show a "forward" animation by default.
     *
     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="forward">Link</a>
     * ```
     */
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.
     *
     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),
     * and that it will show a "forward" animation by default.
     *
     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="forward">Link</a>
     * ```
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    NavController.prototype.navigateForward = /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.
     *
     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),
     * and that it will show a "forward" animation by default.
     *
     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="forward">Link</a>
     * ```
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        this.setDirection('forward', options.animated, options.animationDirection);
        return this.navigate(url, options);
    };
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling:
     *
     * ```ts
     * this.navController.setDirection('back');
     * this.router.navigateByUrl(path);
     * ```
     *
     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,
     * and that it will show a "back" animation by default.
     *
     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="back">Link</a>
     * ```
     */
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling:
     *
     * ```ts
     * this.navController.setDirection('back');
     * this.router.navigateByUrl(path);
     * ```
     *
     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,
     * and that it will show a "back" animation by default.
     *
     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="back">Link</a>
     * ```
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    NavController.prototype.navigateBack = /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling:
     *
     * ```ts
     * this.navController.setDirection('back');
     * this.router.navigateByUrl(path);
     * ```
     *
     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,
     * and that it will show a "back" animation by default.
     *
     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="back">Link</a>
     * ```
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        this.setDirection('back', options.animated, options.animationDirection);
        return this.navigate(url, options);
    };
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling:
     *
     * ```ts
     * this.navController.setDirection('root');
     * this.router.navigateByUrl(path);
     * ```
     *
     * Going **root** means that all existing pages in the stack will be removed,
     * and the navigated page will become the single page in the stack.
     *
     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="root">Link</a>
     * ```
     */
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling:
     *
     * ```ts
     * this.navController.setDirection('root');
     * this.router.navigateByUrl(path);
     * ```
     *
     * Going **root** means that all existing pages in the stack will be removed,
     * and the navigated page will become the single page in the stack.
     *
     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="root">Link</a>
     * ```
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    NavController.prototype.navigateRoot = /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling:
     *
     * ```ts
     * this.navController.setDirection('root');
     * this.router.navigateByUrl(path);
     * ```
     *
     * Going **root** means that all existing pages in the stack will be removed,
     * and the navigated page will become the single page in the stack.
     *
     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="root">Link</a>
     * ```
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        this.setDirection('root', options.animated, options.animationDirection);
        return this.navigate(url, options);
    };
    /**
     * Same as [Location](https://angular.io/api/common/Location)'s back() method.
     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation
     * by default.
     */
    /**
     * Same as [Location](https://angular.io/api/common/Location)'s back() method.
     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation
     * by default.
     * @param {?=} options
     * @return {?}
     */
    NavController.prototype.back = /**
     * Same as [Location](https://angular.io/api/common/Location)'s back() method.
     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation
     * by default.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = { animated: true, animationDirection: 'back' }; }
        this.setDirection('back', options.animated, options.animationDirection);
        return this.location.back();
    };
    /**
     * This methods goes back in the context of Ionic's stack navigation.
     *
     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.
     * This is the recommended way to go back when you are using `ion-router-outlet`.
     */
    /**
     * This methods goes back in the context of Ionic's stack navigation.
     *
     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.
     * This is the recommended way to go back when you are using `ion-router-outlet`.
     * @return {?}
     */
    NavController.prototype.pop = /**
     * This methods goes back in the context of Ionic's stack navigation.
     *
     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.
     * This is the recommended way to go back when you are using `ion-router-outlet`.
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var outlet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        outlet = this.topOutlet;
                        _a.label = 1;
                    case 1:
                        if (!outlet) return [3 /*break*/, 3];
                        return [4 /*yield*/, outlet.pop()];
                    case 2:
                        if (_a.sent()) {
                            return [3 /*break*/, 3];
                        }
                        else {
                            outlet = outlet.parentOutlet;
                        }
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This methods specifies the direction of the next navigation performed by the Angular router.
     *
     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.
     *
     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.
     */
    /**
     * This methods specifies the direction of the next navigation performed by the Angular router.
     *
     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.
     *
     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.
     * @param {?} direction
     * @param {?=} animated
     * @param {?=} animationDirection
     * @return {?}
     */
    NavController.prototype.setDirection = /**
     * This methods specifies the direction of the next navigation performed by the Angular router.
     *
     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.
     *
     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.
     * @param {?} direction
     * @param {?=} animated
     * @param {?=} animationDirection
     * @return {?}
     */
    function (direction, animated, animationDirection) {
        this.direction = direction;
        this.animated = getAnimation(direction, animated, animationDirection);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} outlet
     * @return {?}
     */
    NavController.prototype.setTopOutlet = /**
     * \@internal
     * @param {?} outlet
     * @return {?}
     */
    function (outlet) {
        this.topOutlet = outlet;
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @return {?}
     */
    NavController.prototype.consumeTransition = /**
     * \@internal
     * @return {?}
     */
    function () {
        /** @type {?} */
        var direction = 'root';
        /** @type {?} */
        var animation;
        if (this.direction === 'auto') {
            direction = this.guessDirection;
            animation = this.guessAnimation;
        }
        else {
            animation = this.animated;
            direction = this.direction;
        }
        this.direction = DEFAULT_DIRECTION;
        this.animated = DEFAULT_ANIMATED;
        return {
            direction: direction,
            animation: animation
        };
    };
    /**
     * @private
     * @param {?} url
     * @param {?} options
     * @return {?}
     */
    NavController.prototype.navigate = /**
     * @private
     * @param {?} url
     * @param {?} options
     * @return {?}
     */
    function (url, options) {
        if (Array.isArray(url)) {
            return (/** @type {?} */ (this.router)).navigate(url, options);
        }
        else {
            /**
             * navigateByUrl ignores any properties that
             * would change the url, so things like queryParams
             * would be ignored unless we create a url tree
             * More Info: https://github.com/angular/angular/issues/18798
             * @type {?}
             */
            var urlTree = this.serializer.parse(url.toString());
            if (options.queryParams !== undefined) {
                urlTree.queryParams = __assign({}, options.queryParams);
            }
            if (options.fragment !== undefined) {
                urlTree.fragment = options.fragment;
            }
            /**
             * `navigateByUrl` will still apply `NavigationExtras` properties
             * that do not modify the url, such as `replaceUrl` which is why
             * `options` is passed in here.
             */
            return (/** @type {?} */ (this.router)).navigateByUrl(urlTree, options);
        }
    };
    /** @nocollapse */
    NavController.ctorParameters = function () { return [
        { type: Platform },
        { type: Location },
        { type: UrlSerializer },
        { type: Router, decorators: [{ type: Optional }] }
    ]; };
    /** @nocollapse */ NavController.ngInjectableDef = defineInjectable({ factory: function NavController_Factory() { return new NavController(inject(Platform), inject(Location), inject(UrlSerializer), inject(Router, 8)); }, token: NavController, providedIn: "root" });
NavController.ɵfac = function NavController_Factory(t) { return new (t || NavController)(ɵngcc0.ɵɵinject(Platform), ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc2.UrlSerializer), ɵngcc0.ɵɵinject(ɵngcc2.Router, 8)); };
NavController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NavController, factory: function (t) { return NavController.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavController, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: Platform }, { type: ɵngcc1.Location }, { type: ɵngcc2.UrlSerializer }, { type: ɵngcc2.Router, decorators: [{
                type: Optional
            }] }]; }, null); })();
    return NavController;
}());
/** @type {?} */
var getAnimation = (/**
 * @param {?} direction
 * @param {?} animated
 * @param {?} animationDirection
 * @return {?}
 */
function (direction, animated, animationDirection) {
    if (animated === false) {
        return undefined;
    }
    if (animationDirection !== undefined) {
        return animationDirection;
    }
    if (direction === 'forward' || direction === 'back') {
        return direction;
    }
    else if (direction === 'root' && animated === true) {
        return 'forward';
    }
    return undefined;
});
/** @type {?} */
var DEFAULT_DIRECTION = 'auto';
/** @type {?} */
var DEFAULT_ANIMATED = undefined;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var proxyInputs = (/**
 * @param {?} Cmp
 * @param {?} inputs
 * @return {?}
 */
function (Cmp, inputs) {
    /** @type {?} */
    var Prototype = Cmp.prototype;
    inputs.forEach((/**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        Object.defineProperty(Prototype, item, {
            get: /**
             * @return {?}
             */
            function () { return this.el[item]; },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                var _this = this;
                this.z.runOutsideAngular((/**
                 * @return {?}
                 */
                function () { return _this.el[item] = val; }));
            },
        });
    }));
});
/** @type {?} */
var proxyMethods = (/**
 * @param {?} Cmp
 * @param {?} methods
 * @return {?}
 */
function (Cmp, methods) {
    /** @type {?} */
    var Prototype = Cmp.prototype;
    methods.forEach((/**
     * @param {?} methodName
     * @return {?}
     */
    function (methodName) {
        Prototype[methodName] = (/**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var args = arguments;
            return this.z.runOutsideAngular((/**
             * @return {?}
             */
            function () { return _this.el[methodName].apply(_this.el, args); }));
        });
    }));
});
/** @type {?} */
var proxyOutputs = (/**
 * @param {?} instance
 * @param {?} el
 * @param {?} events
 * @return {?}
 */
function (instance, el, events) {
    events.forEach((/**
     * @param {?} eventName
     * @return {?}
     */
    function (eventName) { return instance[eventName] = fromEvent(el, eventName); }));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonApp = /** @class */ (function () {
    function IonApp(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonApp.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonApp.ɵfac = function IonApp_Factory(t) { return new (t || IonApp)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonApp.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonApp, selectors: [["ion-app"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonApp_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonApp, [{
        type: Component,
        args: [{ selector: 'ion-app', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonApp;
}());
var IonAvatar = /** @class */ (function () {
    function IonAvatar(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonAvatar.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonAvatar.ɵfac = function IonAvatar_Factory(t) { return new (t || IonAvatar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonAvatar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonAvatar, selectors: [["ion-avatar"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonAvatar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonAvatar, [{
        type: Component,
        args: [{ selector: 'ion-avatar', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonAvatar;
}());
var IonBackButton = /** @class */ (function () {
    function IonBackButton(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonBackButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonBackButton.ɵfac = function IonBackButton_Factory(t) { return new (t || IonBackButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonBackButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonBackButton, selectors: [["ion-back-button"]], inputs: { color: "color", defaultHref: "defaultHref", disabled: "disabled", icon: "icon", mode: "mode", text: "text", type: "type" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonBackButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonBackButton, [{
        type: Component,
        args: [{ selector: 'ion-back-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'text', 'type'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonBackButton;
}());
proxyInputs(IonBackButton, ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'text', 'type']);
var IonBackdrop = /** @class */ (function () {
    function IonBackdrop(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionBackdropTap']);
    }
    /** @nocollapse */
    IonBackdrop.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonBackdrop.ɵfac = function IonBackdrop_Factory(t) { return new (t || IonBackdrop)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonBackdrop.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonBackdrop, selectors: [["ion-backdrop"]], inputs: { stopPropagation: "stopPropagation", tappable: "tappable", visible: "visible" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonBackdrop_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonBackdrop, [{
        type: Component,
        args: [{ selector: 'ion-backdrop', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['stopPropagation', 'tappable', 'visible'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonBackdrop;
}());
proxyInputs(IonBackdrop, ['stopPropagation', 'tappable', 'visible']);
var IonBadge = /** @class */ (function () {
    function IonBadge(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonBadge.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonBadge.ɵfac = function IonBadge_Factory(t) { return new (t || IonBadge)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonBadge.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonBadge, selectors: [["ion-badge"]], inputs: { color: "color", mode: "mode" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonBadge_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonBadge, [{
        type: Component,
        args: [{ selector: 'ion-badge', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonBadge;
}());
proxyInputs(IonBadge, ['color', 'mode']);
var IonButton = /** @class */ (function () {
    function IonButton(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);
    }
    /** @nocollapse */
    IonButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonButton.ɵfac = function IonButton_Factory(t) { return new (t || IonButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonButton, selectors: [["ion-button"]], inputs: { buttonType: "buttonType", color: "color", disabled: "disabled", download: "download", expand: "expand", fill: "fill", href: "href", mode: "mode", rel: "rel", routerDirection: "routerDirection", shape: "shape", size: "size", strong: "strong", target: "target", type: "type" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonButton, [{
        type: Component,
        args: [{ selector: 'ion-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['buttonType', 'color', 'disabled', 'download', 'expand', 'fill', 'href', 'mode', 'rel', 'routerDirection', 'shape', 'size', 'strong', 'target', 'type'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonButton;
}());
proxyInputs(IonButton, ['buttonType', 'color', 'disabled', 'download', 'expand', 'fill', 'href', 'mode', 'rel', 'routerDirection', 'shape', 'size', 'strong', 'target', 'type']);
var IonButtons = /** @class */ (function () {
    function IonButtons(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonButtons.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonButtons.ɵfac = function IonButtons_Factory(t) { return new (t || IonButtons)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonButtons.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonButtons, selectors: [["ion-buttons"]], inputs: { collapse: "collapse" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonButtons_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonButtons, [{
        type: Component,
        args: [{ selector: 'ion-buttons', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['collapse'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonButtons;
}());
proxyInputs(IonButtons, ['collapse']);
var IonCard = /** @class */ (function () {
    function IonCard(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonCard.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonCard.ɵfac = function IonCard_Factory(t) { return new (t || IonCard)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonCard.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonCard, selectors: [["ion-card"]], inputs: { button: "button", color: "color", disabled: "disabled", download: "download", href: "href", mode: "mode", rel: "rel", routerDirection: "routerDirection", target: "target", type: "type" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonCard_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonCard, [{
        type: Component,
        args: [{ selector: 'ion-card', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['button', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'target', 'type'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonCard;
}());
proxyInputs(IonCard, ['button', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'target', 'type']);
var IonCardContent = /** @class */ (function () {
    function IonCardContent(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonCardContent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonCardContent.ɵfac = function IonCardContent_Factory(t) { return new (t || IonCardContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonCardContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonCardContent, selectors: [["ion-card-content"]], inputs: { mode: "mode" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonCardContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonCardContent, [{
        type: Component,
        args: [{ selector: 'ion-card-content', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['mode'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonCardContent;
}());
proxyInputs(IonCardContent, ['mode']);
var IonCardHeader = /** @class */ (function () {
    function IonCardHeader(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonCardHeader.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonCardHeader.ɵfac = function IonCardHeader_Factory(t) { return new (t || IonCardHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonCardHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonCardHeader, selectors: [["ion-card-header"]], inputs: { color: "color", mode: "mode", translucent: "translucent" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonCardHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonCardHeader, [{
        type: Component,
        args: [{ selector: 'ion-card-header', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'translucent'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonCardHeader;
}());
proxyInputs(IonCardHeader, ['color', 'mode', 'translucent']);
var IonCardSubtitle = /** @class */ (function () {
    function IonCardSubtitle(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonCardSubtitle.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonCardSubtitle.ɵfac = function IonCardSubtitle_Factory(t) { return new (t || IonCardSubtitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonCardSubtitle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonCardSubtitle, selectors: [["ion-card-subtitle"]], inputs: { color: "color", mode: "mode" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonCardSubtitle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonCardSubtitle, [{
        type: Component,
        args: [{ selector: 'ion-card-subtitle', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonCardSubtitle;
}());
proxyInputs(IonCardSubtitle, ['color', 'mode']);
var IonCardTitle = /** @class */ (function () {
    function IonCardTitle(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonCardTitle.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonCardTitle.ɵfac = function IonCardTitle_Factory(t) { return new (t || IonCardTitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonCardTitle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonCardTitle, selectors: [["ion-card-title"]], inputs: { color: "color", mode: "mode" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonCardTitle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonCardTitle, [{
        type: Component,
        args: [{ selector: 'ion-card-title', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonCardTitle;
}());
proxyInputs(IonCardTitle, ['color', 'mode']);
var IonCheckbox = /** @class */ (function () {
    function IonCheckbox(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);
    }
    /** @nocollapse */
    IonCheckbox.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonCheckbox.ɵfac = function IonCheckbox_Factory(t) { return new (t || IonCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonCheckbox.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonCheckbox, selectors: [["ion-checkbox"]], inputs: { checked: "checked", color: "color", disabled: "disabled", indeterminate: "indeterminate", mode: "mode", name: "name", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonCheckbox_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonCheckbox, [{
        type: Component,
        args: [{ selector: 'ion-checkbox', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['checked', 'color', 'disabled', 'indeterminate', 'mode', 'name', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonCheckbox;
}());
proxyInputs(IonCheckbox, ['checked', 'color', 'disabled', 'indeterminate', 'mode', 'name', 'value']);
var IonChip = /** @class */ (function () {
    function IonChip(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonChip.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonChip.ɵfac = function IonChip_Factory(t) { return new (t || IonChip)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonChip.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonChip, selectors: [["ion-chip"]], inputs: { color: "color", mode: "mode", outline: "outline" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonChip_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonChip, [{
        type: Component,
        args: [{ selector: 'ion-chip', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'outline'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonChip;
}());
proxyInputs(IonChip, ['color', 'mode', 'outline']);
var IonCol = /** @class */ (function () {
    function IonCol(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonCol.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonCol.ɵfac = function IonCol_Factory(t) { return new (t || IonCol)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonCol.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonCol, selectors: [["ion-col"]], inputs: { offset: "offset", offsetLg: "offsetLg", offsetMd: "offsetMd", offsetSm: "offsetSm", offsetXl: "offsetXl", offsetXs: "offsetXs", pull: "pull", pullLg: "pullLg", pullMd: "pullMd", pullSm: "pullSm", pullXl: "pullXl", pullXs: "pullXs", push: "push", pushLg: "pushLg", pushMd: "pushMd", pushSm: "pushSm", pushXl: "pushXl", pushXs: "pushXs", size: "size", sizeLg: "sizeLg", sizeMd: "sizeMd", sizeSm: "sizeSm", sizeXl: "sizeXl", sizeXs: "sizeXs" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonCol_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonCol, [{
        type: Component,
        args: [{ selector: 'ion-col', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['offset', 'offsetLg', 'offsetMd', 'offsetSm', 'offsetXl', 'offsetXs', 'pull', 'pullLg', 'pullMd', 'pullSm', 'pullXl', 'pullXs', 'push', 'pushLg', 'pushMd', 'pushSm', 'pushXl', 'pushXs', 'size', 'sizeLg', 'sizeMd', 'sizeSm', 'sizeXl', 'sizeXs'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonCol;
}());
proxyInputs(IonCol, ['offset', 'offsetLg', 'offsetMd', 'offsetSm', 'offsetXl', 'offsetXs', 'pull', 'pullLg', 'pullMd', 'pullSm', 'pullXl', 'pullXs', 'push', 'pushLg', 'pushMd', 'pushSm', 'pushXl', 'pushXs', 'size', 'sizeLg', 'sizeMd', 'sizeSm', 'sizeXl', 'sizeXs']);
var IonContent = /** @class */ (function () {
    function IonContent(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionScrollStart', 'ionScroll', 'ionScrollEnd']);
    }
    /** @nocollapse */
    IonContent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonContent.ɵfac = function IonContent_Factory(t) { return new (t || IonContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonContent, selectors: [["ion-content"]], inputs: { color: "color", forceOverscroll: "forceOverscroll", fullscreen: "fullscreen", scrollEvents: "scrollEvents", scrollX: "scrollX", scrollY: "scrollY" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonContent, [{
        type: Component,
        args: [{ selector: 'ion-content', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'forceOverscroll', 'fullscreen', 'scrollEvents', 'scrollX', 'scrollY'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonContent;
}());
proxyMethods(IonContent, ['getScrollElement', 'scrollToTop', 'scrollToBottom', 'scrollByPoint', 'scrollToPoint']);
proxyInputs(IonContent, ['color', 'forceOverscroll', 'fullscreen', 'scrollEvents', 'scrollX', 'scrollY']);
var IonDatetime = /** @class */ (function () {
    function IonDatetime(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionCancel', 'ionChange', 'ionFocus', 'ionBlur']);
    }
    /** @nocollapse */
    IonDatetime.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonDatetime.ɵfac = function IonDatetime_Factory(t) { return new (t || IonDatetime)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonDatetime.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonDatetime, selectors: [["ion-datetime"]], inputs: { cancelText: "cancelText", dayNames: "dayNames", dayShortNames: "dayShortNames", dayValues: "dayValues", disabled: "disabled", displayFormat: "displayFormat", doneText: "doneText", hourValues: "hourValues", max: "max", min: "min", minuteValues: "minuteValues", mode: "mode", monthNames: "monthNames", monthShortNames: "monthShortNames", monthValues: "monthValues", name: "name", pickerFormat: "pickerFormat", pickerOptions: "pickerOptions", placeholder: "placeholder", readonly: "readonly", value: "value", yearValues: "yearValues" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonDatetime_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonDatetime, [{
        type: Component,
        args: [{ selector: 'ion-datetime', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['cancelText', 'dayNames', 'dayShortNames', 'dayValues', 'disabled', 'displayFormat', 'doneText', 'hourValues', 'max', 'min', 'minuteValues', 'mode', 'monthNames', 'monthShortNames', 'monthValues', 'name', 'pickerFormat', 'pickerOptions', 'placeholder', 'readonly', 'value', 'yearValues'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonDatetime;
}());
proxyMethods(IonDatetime, ['open']);
proxyInputs(IonDatetime, ['cancelText', 'dayNames', 'dayShortNames', 'dayValues', 'disabled', 'displayFormat', 'doneText', 'hourValues', 'max', 'min', 'minuteValues', 'mode', 'monthNames', 'monthShortNames', 'monthValues', 'name', 'pickerFormat', 'pickerOptions', 'placeholder', 'readonly', 'value', 'yearValues']);
var IonFab = /** @class */ (function () {
    function IonFab(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonFab.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonFab.ɵfac = function IonFab_Factory(t) { return new (t || IonFab)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonFab.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonFab, selectors: [["ion-fab"]], inputs: { activated: "activated", edge: "edge", horizontal: "horizontal", vertical: "vertical" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonFab_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonFab, [{
        type: Component,
        args: [{ selector: 'ion-fab', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['activated', 'edge', 'horizontal', 'vertical'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonFab;
}());
proxyMethods(IonFab, ['close']);
proxyInputs(IonFab, ['activated', 'edge', 'horizontal', 'vertical']);
var IonFabButton = /** @class */ (function () {
    function IonFabButton(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);
    }
    /** @nocollapse */
    IonFabButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonFabButton.ɵfac = function IonFabButton_Factory(t) { return new (t || IonFabButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonFabButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonFabButton, selectors: [["ion-fab-button"]], inputs: { activated: "activated", color: "color", disabled: "disabled", download: "download", href: "href", mode: "mode", rel: "rel", routerDirection: "routerDirection", show: "show", size: "size", target: "target", translucent: "translucent", type: "type" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonFabButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonFabButton, [{
        type: Component,
        args: [{ selector: 'ion-fab-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['activated', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'show', 'size', 'target', 'translucent', 'type'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonFabButton;
}());
proxyInputs(IonFabButton, ['activated', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'show', 'size', 'target', 'translucent', 'type']);
var IonFabList = /** @class */ (function () {
    function IonFabList(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonFabList.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonFabList.ɵfac = function IonFabList_Factory(t) { return new (t || IonFabList)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonFabList.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonFabList, selectors: [["ion-fab-list"]], inputs: { activated: "activated", side: "side" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonFabList_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonFabList, [{
        type: Component,
        args: [{ selector: 'ion-fab-list', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['activated', 'side'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonFabList;
}());
proxyInputs(IonFabList, ['activated', 'side']);
var IonFooter = /** @class */ (function () {
    function IonFooter(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonFooter.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonFooter.ɵfac = function IonFooter_Factory(t) { return new (t || IonFooter)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonFooter.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonFooter, selectors: [["ion-footer"]], inputs: { mode: "mode", translucent: "translucent" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonFooter_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonFooter, [{
        type: Component,
        args: [{ selector: 'ion-footer', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['mode', 'translucent'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonFooter;
}());
proxyInputs(IonFooter, ['mode', 'translucent']);
var IonGrid = /** @class */ (function () {
    function IonGrid(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonGrid.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonGrid.ɵfac = function IonGrid_Factory(t) { return new (t || IonGrid)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonGrid.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonGrid, selectors: [["ion-grid"]], inputs: { fixed: "fixed" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonGrid_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonGrid, [{
        type: Component,
        args: [{ selector: 'ion-grid', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['fixed'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonGrid;
}());
proxyInputs(IonGrid, ['fixed']);
var IonHeader = /** @class */ (function () {
    function IonHeader(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonHeader.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonHeader.ɵfac = function IonHeader_Factory(t) { return new (t || IonHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonHeader, selectors: [["ion-header"]], inputs: { collapse: "collapse", mode: "mode", translucent: "translucent" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonHeader, [{
        type: Component,
        args: [{ selector: 'ion-header', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['collapse', 'mode', 'translucent'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonHeader;
}());
proxyInputs(IonHeader, ['collapse', 'mode', 'translucent']);
var IonIcon = /** @class */ (function () {
    function IonIcon(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonIcon.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonIcon.ɵfac = function IonIcon_Factory(t) { return new (t || IonIcon)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonIcon.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonIcon, selectors: [["ion-icon"]], inputs: { ariaLabel: "ariaLabel", color: "color", flipRtl: "flipRtl", icon: "icon", ios: "ios", lazy: "lazy", md: "md", mode: "mode", name: "name", size: "size", src: "src" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonIcon_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonIcon, [{
        type: Component,
        args: [{ selector: 'ion-icon', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['ariaLabel', 'color', 'flipRtl', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'size', 'src'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonIcon;
}());
proxyInputs(IonIcon, ['ariaLabel', 'color', 'flipRtl', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'size', 'src']);
var IonImg = /** @class */ (function () {
    function IonImg(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionImgWillLoad', 'ionImgDidLoad', 'ionError']);
    }
    /** @nocollapse */
    IonImg.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonImg.ɵfac = function IonImg_Factory(t) { return new (t || IonImg)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonImg.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonImg, selectors: [["ion-img"]], inputs: { alt: "alt", src: "src" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonImg_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonImg, [{
        type: Component,
        args: [{ selector: 'ion-img', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['alt', 'src'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonImg;
}());
proxyInputs(IonImg, ['alt', 'src']);
var IonInfiniteScroll = /** @class */ (function () {
    function IonInfiniteScroll(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionInfinite']);
    }
    /** @nocollapse */
    IonInfiniteScroll.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonInfiniteScroll.ɵfac = function IonInfiniteScroll_Factory(t) { return new (t || IonInfiniteScroll)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonInfiniteScroll.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonInfiniteScroll, selectors: [["ion-infinite-scroll"]], inputs: { disabled: "disabled", position: "position", threshold: "threshold" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonInfiniteScroll_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonInfiniteScroll, [{
        type: Component,
        args: [{ selector: 'ion-infinite-scroll', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['disabled', 'position', 'threshold'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonInfiniteScroll;
}());
proxyMethods(IonInfiniteScroll, ['complete']);
proxyInputs(IonInfiniteScroll, ['disabled', 'position', 'threshold']);
var IonInfiniteScrollContent = /** @class */ (function () {
    function IonInfiniteScrollContent(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonInfiniteScrollContent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonInfiniteScrollContent.ɵfac = function IonInfiniteScrollContent_Factory(t) { return new (t || IonInfiniteScrollContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonInfiniteScrollContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonInfiniteScrollContent, selectors: [["ion-infinite-scroll-content"]], inputs: { loadingSpinner: "loadingSpinner", loadingText: "loadingText" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonInfiniteScrollContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonInfiniteScrollContent, [{
        type: Component,
        args: [{ selector: 'ion-infinite-scroll-content', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['loadingSpinner', 'loadingText'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonInfiniteScrollContent;
}());
proxyInputs(IonInfiniteScrollContent, ['loadingSpinner', 'loadingText']);
var IonInput = /** @class */ (function () {
    function IonInput(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionBlur', 'ionFocus']);
    }
    /** @nocollapse */
    IonInput.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonInput.ɵfac = function IonInput_Factory(t) { return new (t || IonInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonInput.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonInput, selectors: [["ion-input"]], inputs: { accept: "accept", autocapitalize: "autocapitalize", autocomplete: "autocomplete", autocorrect: "autocorrect", autofocus: "autofocus", clearInput: "clearInput", clearOnEdit: "clearOnEdit", color: "color", debounce: "debounce", disabled: "disabled", inputmode: "inputmode", max: "max", maxlength: "maxlength", min: "min", minlength: "minlength", mode: "mode", multiple: "multiple", name: "name", pattern: "pattern", placeholder: "placeholder", readonly: "readonly", required: "required", size: "size", spellcheck: "spellcheck", step: "step", type: "type", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonInput_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonInput, [{
        type: Component,
        args: [{ selector: 'ion-input', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'color', 'debounce', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'mode', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'spellcheck', 'step', 'type', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonInput;
}());
proxyMethods(IonInput, ['setFocus', 'getInputElement']);
proxyInputs(IonInput, ['accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'color', 'debounce', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'mode', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'spellcheck', 'step', 'type', 'value']);
var IonItem = /** @class */ (function () {
    function IonItem(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonItem.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonItem.ɵfac = function IonItem_Factory(t) { return new (t || IonItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonItem.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonItem, selectors: [["ion-item"]], inputs: { button: "button", color: "color", detail: "detail", detailIcon: "detailIcon", disabled: "disabled", download: "download", href: "href", lines: "lines", mode: "mode", rel: "rel", routerDirection: "routerDirection", target: "target", type: "type" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonItem_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonItem, [{
        type: Component,
        args: [{ selector: 'ion-item', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['button', 'color', 'detail', 'detailIcon', 'disabled', 'download', 'href', 'lines', 'mode', 'rel', 'routerDirection', 'target', 'type'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonItem;
}());
proxyInputs(IonItem, ['button', 'color', 'detail', 'detailIcon', 'disabled', 'download', 'href', 'lines', 'mode', 'rel', 'routerDirection', 'target', 'type']);
var IonItemDivider = /** @class */ (function () {
    function IonItemDivider(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonItemDivider.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonItemDivider.ɵfac = function IonItemDivider_Factory(t) { return new (t || IonItemDivider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonItemDivider.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonItemDivider, selectors: [["ion-item-divider"]], inputs: { color: "color", mode: "mode", sticky: "sticky" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonItemDivider_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonItemDivider, [{
        type: Component,
        args: [{ selector: 'ion-item-divider', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'sticky'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonItemDivider;
}());
proxyInputs(IonItemDivider, ['color', 'mode', 'sticky']);
var IonItemGroup = /** @class */ (function () {
    function IonItemGroup(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonItemGroup.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonItemGroup.ɵfac = function IonItemGroup_Factory(t) { return new (t || IonItemGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonItemGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonItemGroup, selectors: [["ion-item-group"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonItemGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonItemGroup, [{
        type: Component,
        args: [{ selector: 'ion-item-group', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonItemGroup;
}());
var IonItemOption = /** @class */ (function () {
    function IonItemOption(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonItemOption.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonItemOption.ɵfac = function IonItemOption_Factory(t) { return new (t || IonItemOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonItemOption.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonItemOption, selectors: [["ion-item-option"]], inputs: { color: "color", disabled: "disabled", download: "download", expandable: "expandable", href: "href", mode: "mode", rel: "rel", target: "target", type: "type" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonItemOption_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonItemOption, [{
        type: Component,
        args: [{ selector: 'ion-item-option', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'disabled', 'download', 'expandable', 'href', 'mode', 'rel', 'target', 'type'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonItemOption;
}());
proxyInputs(IonItemOption, ['color', 'disabled', 'download', 'expandable', 'href', 'mode', 'rel', 'target', 'type']);
var IonItemOptions = /** @class */ (function () {
    function IonItemOptions(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionSwipe']);
    }
    /** @nocollapse */
    IonItemOptions.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonItemOptions.ɵfac = function IonItemOptions_Factory(t) { return new (t || IonItemOptions)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonItemOptions.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonItemOptions, selectors: [["ion-item-options"]], inputs: { side: "side" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonItemOptions_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonItemOptions, [{
        type: Component,
        args: [{ selector: 'ion-item-options', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['side'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonItemOptions;
}());
proxyInputs(IonItemOptions, ['side']);
var IonItemSliding = /** @class */ (function () {
    function IonItemSliding(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionDrag']);
    }
    /** @nocollapse */
    IonItemSliding.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonItemSliding.ɵfac = function IonItemSliding_Factory(t) { return new (t || IonItemSliding)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonItemSliding.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonItemSliding, selectors: [["ion-item-sliding"]], inputs: { disabled: "disabled" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonItemSliding_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonItemSliding, [{
        type: Component,
        args: [{ selector: 'ion-item-sliding', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['disabled'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonItemSliding;
}());
proxyMethods(IonItemSliding, ['getOpenAmount', 'getSlidingRatio', 'open', 'close', 'closeOpened']);
proxyInputs(IonItemSliding, ['disabled']);
var IonLabel = /** @class */ (function () {
    function IonLabel(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonLabel.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonLabel.ɵfac = function IonLabel_Factory(t) { return new (t || IonLabel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonLabel.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonLabel, selectors: [["ion-label"]], inputs: { color: "color", mode: "mode", position: "position" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonLabel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonLabel, [{
        type: Component,
        args: [{ selector: 'ion-label', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'position'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonLabel;
}());
proxyInputs(IonLabel, ['color', 'mode', 'position']);
var IonList = /** @class */ (function () {
    function IonList(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonList.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonList.ɵfac = function IonList_Factory(t) { return new (t || IonList)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonList.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonList, selectors: [["ion-list"]], inputs: { inset: "inset", lines: "lines", mode: "mode" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonList_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonList, [{
        type: Component,
        args: [{ selector: 'ion-list', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['inset', 'lines', 'mode'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonList;
}());
proxyMethods(IonList, ['closeSlidingItems']);
proxyInputs(IonList, ['inset', 'lines', 'mode']);
var IonListHeader = /** @class */ (function () {
    function IonListHeader(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonListHeader.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonListHeader.ɵfac = function IonListHeader_Factory(t) { return new (t || IonListHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonListHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonListHeader, selectors: [["ion-list-header"]], inputs: { color: "color", mode: "mode" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonListHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonListHeader, [{
        type: Component,
        args: [{ selector: 'ion-list-header', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonListHeader;
}());
proxyInputs(IonListHeader, ['color', 'mode']);
var IonMenu = /** @class */ (function () {
    function IonMenu(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionWillOpen', 'ionWillClose', 'ionDidOpen', 'ionDidClose']);
    }
    /** @nocollapse */
    IonMenu.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonMenu.ɵfac = function IonMenu_Factory(t) { return new (t || IonMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonMenu.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonMenu, selectors: [["ion-menu"]], inputs: { contentId: "contentId", disabled: "disabled", maxEdgeStart: "maxEdgeStart", menuId: "menuId", side: "side", swipeGesture: "swipeGesture", type: "type" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonMenu_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonMenu, [{
        type: Component,
        args: [{ selector: 'ion-menu', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['contentId', 'disabled', 'maxEdgeStart', 'menuId', 'side', 'swipeGesture', 'type'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonMenu;
}());
proxyMethods(IonMenu, ['isOpen', 'isActive', 'open', 'close', 'toggle', 'setOpen']);
proxyInputs(IonMenu, ['contentId', 'disabled', 'maxEdgeStart', 'menuId', 'side', 'swipeGesture', 'type']);
var IonMenuButton = /** @class */ (function () {
    function IonMenuButton(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonMenuButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonMenuButton.ɵfac = function IonMenuButton_Factory(t) { return new (t || IonMenuButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonMenuButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonMenuButton, selectors: [["ion-menu-button"]], inputs: { autoHide: "autoHide", color: "color", disabled: "disabled", menu: "menu", type: "type" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonMenuButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonMenuButton, [{
        type: Component,
        args: [{ selector: 'ion-menu-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['autoHide', 'color', 'disabled', 'menu', 'type'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonMenuButton;
}());
proxyInputs(IonMenuButton, ['autoHide', 'color', 'disabled', 'menu', 'type']);
var IonMenuToggle = /** @class */ (function () {
    function IonMenuToggle(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonMenuToggle.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonMenuToggle.ɵfac = function IonMenuToggle_Factory(t) { return new (t || IonMenuToggle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonMenuToggle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonMenuToggle, selectors: [["ion-menu-toggle"]], inputs: { autoHide: "autoHide", menu: "menu" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonMenuToggle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonMenuToggle, [{
        type: Component,
        args: [{ selector: 'ion-menu-toggle', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['autoHide', 'menu'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonMenuToggle;
}());
proxyInputs(IonMenuToggle, ['autoHide', 'menu']);
var IonNav = /** @class */ (function () {
    function IonNav(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionNavWillChange', 'ionNavDidChange']);
    }
    /** @nocollapse */
    IonNav.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonNav.ɵfac = function IonNav_Factory(t) { return new (t || IonNav)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonNav.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonNav, selectors: [["ion-nav"]], inputs: { animated: "animated", animation: "animation", root: "root", rootParams: "rootParams", swipeGesture: "swipeGesture" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonNav_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonNav, [{
        type: Component,
        args: [{ selector: 'ion-nav', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonNav;
}());
proxyMethods(IonNav, ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious']);
proxyInputs(IonNav, ['animated', 'animation', 'root', 'rootParams', 'swipeGesture']);
var IonNavLink = /** @class */ (function () {
    function IonNavLink(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonNavLink.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonNavLink.ɵfac = function IonNavLink_Factory(t) { return new (t || IonNavLink)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonNavLink.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonNavLink, selectors: [["ion-nav-link"]], inputs: { component: "component", componentProps: "componentProps", routerDirection: "routerDirection" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonNavLink_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonNavLink, [{
        type: Component,
        args: [{ selector: 'ion-nav-link', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['component', 'componentProps', 'routerDirection'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonNavLink;
}());
proxyInputs(IonNavLink, ['component', 'componentProps', 'routerDirection']);
var IonNavPop = /** @class */ (function () {
    function IonNavPop(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonNavPop.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonNavPop.ɵfac = function IonNavPop_Factory(t) { return new (t || IonNavPop)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonNavPop.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonNavPop, selectors: [["ion-nav-pop"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonNavPop_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonNavPop, [{
        type: Component,
        args: [{ selector: 'ion-nav-pop', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonNavPop;
}());
var IonNavPush = /** @class */ (function () {
    function IonNavPush(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonNavPush.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonNavPush.ɵfac = function IonNavPush_Factory(t) { return new (t || IonNavPush)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonNavPush.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonNavPush, selectors: [["ion-nav-push"]], inputs: { component: "component", componentProps: "componentProps" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonNavPush_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonNavPush, [{
        type: Component,
        args: [{ selector: 'ion-nav-push', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['component', 'componentProps'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonNavPush;
}());
proxyInputs(IonNavPush, ['component', 'componentProps']);
var IonNavSetRoot = /** @class */ (function () {
    function IonNavSetRoot(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonNavSetRoot.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonNavSetRoot.ɵfac = function IonNavSetRoot_Factory(t) { return new (t || IonNavSetRoot)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonNavSetRoot.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonNavSetRoot, selectors: [["ion-nav-set-root"]], inputs: { component: "component", componentProps: "componentProps" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonNavSetRoot_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonNavSetRoot, [{
        type: Component,
        args: [{ selector: 'ion-nav-set-root', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['component', 'componentProps'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonNavSetRoot;
}());
proxyInputs(IonNavSetRoot, ['component', 'componentProps']);
var IonNote = /** @class */ (function () {
    function IonNote(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonNote.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonNote.ɵfac = function IonNote_Factory(t) { return new (t || IonNote)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonNote.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonNote, selectors: [["ion-note"]], inputs: { color: "color", mode: "mode" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonNote_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonNote, [{
        type: Component,
        args: [{ selector: 'ion-note', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonNote;
}());
proxyInputs(IonNote, ['color', 'mode']);
var IonProgressBar = /** @class */ (function () {
    function IonProgressBar(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonProgressBar.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonProgressBar.ɵfac = function IonProgressBar_Factory(t) { return new (t || IonProgressBar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonProgressBar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonProgressBar, selectors: [["ion-progress-bar"]], inputs: { buffer: "buffer", color: "color", mode: "mode", reversed: "reversed", type: "type", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonProgressBar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonProgressBar, [{
        type: Component,
        args: [{ selector: 'ion-progress-bar', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['buffer', 'color', 'mode', 'reversed', 'type', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonProgressBar;
}());
proxyInputs(IonProgressBar, ['buffer', 'color', 'mode', 'reversed', 'type', 'value']);
var IonRadio = /** @class */ (function () {
    function IonRadio(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionSelect', 'ionFocus', 'ionBlur']);
    }
    /** @nocollapse */
    IonRadio.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonRadio.ɵfac = function IonRadio_Factory(t) { return new (t || IonRadio)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonRadio.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonRadio, selectors: [["ion-radio"]], inputs: { checked: "checked", color: "color", disabled: "disabled", mode: "mode", name: "name", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonRadio_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonRadio, [{
        type: Component,
        args: [{ selector: 'ion-radio', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['checked', 'color', 'disabled', 'mode', 'name', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonRadio;
}());
proxyInputs(IonRadio, ['checked', 'color', 'disabled', 'mode', 'name', 'value']);
var IonRadioGroup = /** @class */ (function () {
    function IonRadioGroup(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange']);
    }
    /** @nocollapse */
    IonRadioGroup.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonRadioGroup.ɵfac = function IonRadioGroup_Factory(t) { return new (t || IonRadioGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonRadioGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonRadioGroup, selectors: [["ion-radio-group"]], inputs: { allowEmptySelection: "allowEmptySelection", name: "name", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonRadioGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonRadioGroup, [{
        type: Component,
        args: [{ selector: 'ion-radio-group', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['allowEmptySelection', 'name', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonRadioGroup;
}());
proxyInputs(IonRadioGroup, ['allowEmptySelection', 'name', 'value']);
var IonRange = /** @class */ (function () {
    function IonRange(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);
    }
    /** @nocollapse */
    IonRange.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonRange.ɵfac = function IonRange_Factory(t) { return new (t || IonRange)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonRange.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonRange, selectors: [["ion-range"]], inputs: { color: "color", debounce: "debounce", disabled: "disabled", dualKnobs: "dualKnobs", max: "max", min: "min", mode: "mode", name: "name", pin: "pin", snaps: "snaps", step: "step", ticks: "ticks", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonRange_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonRange, [{
        type: Component,
        args: [{ selector: 'ion-range', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'debounce', 'disabled', 'dualKnobs', 'max', 'min', 'mode', 'name', 'pin', 'snaps', 'step', 'ticks', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonRange;
}());
proxyInputs(IonRange, ['color', 'debounce', 'disabled', 'dualKnobs', 'max', 'min', 'mode', 'name', 'pin', 'snaps', 'step', 'ticks', 'value']);
var IonRefresher = /** @class */ (function () {
    function IonRefresher(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionRefresh', 'ionPull', 'ionStart']);
    }
    /** @nocollapse */
    IonRefresher.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonRefresher.ɵfac = function IonRefresher_Factory(t) { return new (t || IonRefresher)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonRefresher.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonRefresher, selectors: [["ion-refresher"]], inputs: { closeDuration: "closeDuration", disabled: "disabled", pullFactor: "pullFactor", pullMax: "pullMax", pullMin: "pullMin", snapbackDuration: "snapbackDuration" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonRefresher_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonRefresher, [{
        type: Component,
        args: [{ selector: 'ion-refresher', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['closeDuration', 'disabled', 'pullFactor', 'pullMax', 'pullMin', 'snapbackDuration'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonRefresher;
}());
proxyMethods(IonRefresher, ['complete', 'cancel', 'getProgress']);
proxyInputs(IonRefresher, ['closeDuration', 'disabled', 'pullFactor', 'pullMax', 'pullMin', 'snapbackDuration']);
var IonRefresherContent = /** @class */ (function () {
    function IonRefresherContent(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonRefresherContent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonRefresherContent.ɵfac = function IonRefresherContent_Factory(t) { return new (t || IonRefresherContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonRefresherContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonRefresherContent, selectors: [["ion-refresher-content"]], inputs: { pullingIcon: "pullingIcon", pullingText: "pullingText", refreshingSpinner: "refreshingSpinner", refreshingText: "refreshingText" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonRefresherContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonRefresherContent, [{
        type: Component,
        args: [{ selector: 'ion-refresher-content', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonRefresherContent;
}());
proxyInputs(IonRefresherContent, ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText']);
var IonReorder = /** @class */ (function () {
    function IonReorder(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonReorder.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonReorder.ɵfac = function IonReorder_Factory(t) { return new (t || IonReorder)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonReorder.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonReorder, selectors: [["ion-reorder"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonReorder_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonReorder, [{
        type: Component,
        args: [{ selector: 'ion-reorder', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonReorder;
}());
var IonReorderGroup = /** @class */ (function () {
    function IonReorderGroup(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionItemReorder']);
    }
    /** @nocollapse */
    IonReorderGroup.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonReorderGroup.ɵfac = function IonReorderGroup_Factory(t) { return new (t || IonReorderGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonReorderGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonReorderGroup, selectors: [["ion-reorder-group"]], inputs: { disabled: "disabled" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonReorderGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonReorderGroup, [{
        type: Component,
        args: [{ selector: 'ion-reorder-group', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['disabled'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonReorderGroup;
}());
proxyMethods(IonReorderGroup, ['complete']);
proxyInputs(IonReorderGroup, ['disabled']);
var IonRippleEffect = /** @class */ (function () {
    function IonRippleEffect(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonRippleEffect.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonRippleEffect.ɵfac = function IonRippleEffect_Factory(t) { return new (t || IonRippleEffect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonRippleEffect.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonRippleEffect, selectors: [["ion-ripple-effect"]], inputs: { type: "type" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonRippleEffect_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonRippleEffect, [{
        type: Component,
        args: [{ selector: 'ion-ripple-effect', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['type'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonRippleEffect;
}());
proxyMethods(IonRippleEffect, ['addRipple']);
proxyInputs(IonRippleEffect, ['type']);
var IonRow = /** @class */ (function () {
    function IonRow(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonRow.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonRow.ɵfac = function IonRow_Factory(t) { return new (t || IonRow)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonRow.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonRow, selectors: [["ion-row"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonRow_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonRow, [{
        type: Component,
        args: [{ selector: 'ion-row', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonRow;
}());
var IonSearchbar = /** @class */ (function () {
    function IonSearchbar(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionCancel', 'ionClear', 'ionBlur', 'ionFocus']);
    }
    /** @nocollapse */
    IonSearchbar.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonSearchbar.ɵfac = function IonSearchbar_Factory(t) { return new (t || IonSearchbar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonSearchbar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonSearchbar, selectors: [["ion-searchbar"]], inputs: { animated: "animated", autocomplete: "autocomplete", autocorrect: "autocorrect", cancelButtonIcon: "cancelButtonIcon", cancelButtonText: "cancelButtonText", clearIcon: "clearIcon", color: "color", debounce: "debounce", disabled: "disabled", inputmode: "inputmode", mode: "mode", placeholder: "placeholder", searchIcon: "searchIcon", showCancelButton: "showCancelButton", spellcheck: "spellcheck", type: "type", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonSearchbar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonSearchbar, [{
        type: Component,
        args: [{ selector: 'ion-searchbar', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'color', 'debounce', 'disabled', 'inputmode', 'mode', 'placeholder', 'searchIcon', 'showCancelButton', 'spellcheck', 'type', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonSearchbar;
}());
proxyMethods(IonSearchbar, ['setFocus', 'getInputElement']);
proxyInputs(IonSearchbar, ['animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'color', 'debounce', 'disabled', 'inputmode', 'mode', 'placeholder', 'searchIcon', 'showCancelButton', 'spellcheck', 'type', 'value']);
var IonSegment = /** @class */ (function () {
    function IonSegment(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange']);
    }
    /** @nocollapse */
    IonSegment.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonSegment.ɵfac = function IonSegment_Factory(t) { return new (t || IonSegment)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonSegment.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonSegment, selectors: [["ion-segment"]], inputs: { color: "color", disabled: "disabled", mode: "mode", scrollable: "scrollable", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonSegment_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonSegment, [{
        type: Component,
        args: [{ selector: 'ion-segment', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'disabled', 'mode', 'scrollable', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonSegment;
}());
proxyInputs(IonSegment, ['color', 'disabled', 'mode', 'scrollable', 'value']);
var IonSegmentButton = /** @class */ (function () {
    function IonSegmentButton(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionSelect']);
    }
    /** @nocollapse */
    IonSegmentButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonSegmentButton.ɵfac = function IonSegmentButton_Factory(t) { return new (t || IonSegmentButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonSegmentButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonSegmentButton, selectors: [["ion-segment-button"]], inputs: { checked: "checked", disabled: "disabled", layout: "layout", mode: "mode", type: "type", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonSegmentButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonSegmentButton, [{
        type: Component,
        args: [{ selector: 'ion-segment-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['checked', 'disabled', 'layout', 'mode', 'type', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonSegmentButton;
}());
proxyInputs(IonSegmentButton, ['checked', 'disabled', 'layout', 'mode', 'type', 'value']);
var IonSelect = /** @class */ (function () {
    function IonSelect(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionCancel', 'ionFocus', 'ionBlur']);
    }
    /** @nocollapse */
    IonSelect.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonSelect.ɵfac = function IonSelect_Factory(t) { return new (t || IonSelect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonSelect.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonSelect, selectors: [["ion-select"]], inputs: { cancelText: "cancelText", compareWith: "compareWith", disabled: "disabled", interface: "interface", interfaceOptions: "interfaceOptions", mode: "mode", multiple: "multiple", name: "name", okText: "okText", placeholder: "placeholder", selectedText: "selectedText", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonSelect_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonSelect, [{
        type: Component,
        args: [{ selector: 'ion-select', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['cancelText', 'compareWith', 'disabled', 'interface', 'interfaceOptions', 'mode', 'multiple', 'name', 'okText', 'placeholder', 'selectedText', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonSelect;
}());
proxyMethods(IonSelect, ['open']);
proxyInputs(IonSelect, ['cancelText', 'compareWith', 'disabled', 'interface', 'interfaceOptions', 'mode', 'multiple', 'name', 'okText', 'placeholder', 'selectedText', 'value']);
var IonSelectOption = /** @class */ (function () {
    function IonSelectOption(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonSelectOption.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonSelectOption.ɵfac = function IonSelectOption_Factory(t) { return new (t || IonSelectOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonSelectOption.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonSelectOption, selectors: [["ion-select-option"]], inputs: { disabled: "disabled", selected: "selected", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonSelectOption_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonSelectOption, [{
        type: Component,
        args: [{ selector: 'ion-select-option', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['disabled', 'selected', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonSelectOption;
}());
proxyInputs(IonSelectOption, ['disabled', 'selected', 'value']);
var IonSkeletonText = /** @class */ (function () {
    function IonSkeletonText(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonSkeletonText.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonSkeletonText.ɵfac = function IonSkeletonText_Factory(t) { return new (t || IonSkeletonText)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonSkeletonText.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonSkeletonText, selectors: [["ion-skeleton-text"]], inputs: { animated: "animated", width: "width" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonSkeletonText_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonSkeletonText, [{
        type: Component,
        args: [{ selector: 'ion-skeleton-text', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['animated', 'width'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonSkeletonText;
}());
proxyInputs(IonSkeletonText, ['animated', 'width']);
var IonSlide = /** @class */ (function () {
    function IonSlide(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonSlide.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonSlide.ɵfac = function IonSlide_Factory(t) { return new (t || IonSlide)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonSlide.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonSlide, selectors: [["ion-slide"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonSlide_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonSlide, [{
        type: Component,
        args: [{ selector: 'ion-slide', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonSlide;
}());
var IonSlides = /** @class */ (function () {
    function IonSlides(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionSlidesDidLoad', 'ionSlideTap', 'ionSlideDoubleTap', 'ionSlideWillChange', 'ionSlideDidChange', 'ionSlideNextStart', 'ionSlidePrevStart', 'ionSlideNextEnd', 'ionSlidePrevEnd', 'ionSlideTransitionStart', 'ionSlideTransitionEnd', 'ionSlideDrag', 'ionSlideReachStart', 'ionSlideReachEnd', 'ionSlideTouchStart', 'ionSlideTouchEnd']);
    }
    /** @nocollapse */
    IonSlides.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonSlides.ɵfac = function IonSlides_Factory(t) { return new (t || IonSlides)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonSlides.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonSlides, selectors: [["ion-slides"]], inputs: { mode: "mode", options: "options", pager: "pager", scrollbar: "scrollbar" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonSlides_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonSlides, [{
        type: Component,
        args: [{ selector: 'ion-slides', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['mode', 'options', 'pager', 'scrollbar'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonSlides;
}());
proxyMethods(IonSlides, ['update', 'updateAutoHeight', 'slideTo', 'slideNext', 'slidePrev', 'getActiveIndex', 'getPreviousIndex', 'length', 'isEnd', 'isBeginning', 'startAutoplay', 'stopAutoplay', 'lockSwipeToNext', 'lockSwipeToPrev', 'lockSwipes', 'getSwiper']);
proxyInputs(IonSlides, ['mode', 'options', 'pager', 'scrollbar']);
var IonSpinner = /** @class */ (function () {
    function IonSpinner(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonSpinner.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonSpinner.ɵfac = function IonSpinner_Factory(t) { return new (t || IonSpinner)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonSpinner.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonSpinner, selectors: [["ion-spinner"]], inputs: { color: "color", duration: "duration", name: "name", paused: "paused" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonSpinner_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonSpinner, [{
        type: Component,
        args: [{ selector: 'ion-spinner', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'duration', 'name', 'paused'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonSpinner;
}());
proxyInputs(IonSpinner, ['color', 'duration', 'name', 'paused']);
var IonSplitPane = /** @class */ (function () {
    function IonSplitPane(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionSplitPaneVisible']);
    }
    /** @nocollapse */
    IonSplitPane.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonSplitPane.ɵfac = function IonSplitPane_Factory(t) { return new (t || IonSplitPane)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonSplitPane.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonSplitPane, selectors: [["ion-split-pane"]], inputs: { contentId: "contentId", disabled: "disabled", when: "when" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonSplitPane_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonSplitPane, [{
        type: Component,
        args: [{ selector: 'ion-split-pane', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['contentId', 'disabled', 'when'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonSplitPane;
}());
proxyInputs(IonSplitPane, ['contentId', 'disabled', 'when']);
var IonTabBar = /** @class */ (function () {
    function IonTabBar(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonTabBar.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonTabBar.ɵfac = function IonTabBar_Factory(t) { return new (t || IonTabBar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonTabBar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonTabBar, selectors: [["ion-tab-bar"]], inputs: { color: "color", mode: "mode", selectedTab: "selectedTab", translucent: "translucent" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonTabBar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonTabBar, [{
        type: Component,
        args: [{ selector: 'ion-tab-bar', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'selectedTab', 'translucent'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonTabBar;
}());
proxyInputs(IonTabBar, ['color', 'mode', 'selectedTab', 'translucent']);
var IonTabButton = /** @class */ (function () {
    function IonTabButton(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonTabButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonTabButton.ɵfac = function IonTabButton_Factory(t) { return new (t || IonTabButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonTabButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonTabButton, selectors: [["ion-tab-button"]], inputs: { disabled: "disabled", download: "download", href: "href", layout: "layout", mode: "mode", rel: "rel", selected: "selected", tab: "tab", target: "target" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonTabButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonTabButton, [{
        type: Component,
        args: [{ selector: 'ion-tab-button', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['disabled', 'download', 'href', 'layout', 'mode', 'rel', 'selected', 'tab', 'target'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonTabButton;
}());
proxyInputs(IonTabButton, ['disabled', 'download', 'href', 'layout', 'mode', 'rel', 'selected', 'tab', 'target']);
var IonText = /** @class */ (function () {
    function IonText(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonText.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonText.ɵfac = function IonText_Factory(t) { return new (t || IonText)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonText.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonText, selectors: [["ion-text"]], inputs: { color: "color", mode: "mode" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonText_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonText, [{
        type: Component,
        args: [{ selector: 'ion-text', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonText;
}());
proxyInputs(IonText, ['color', 'mode']);
var IonTextarea = /** @class */ (function () {
    function IonTextarea(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionInput', 'ionBlur', 'ionFocus']);
    }
    /** @nocollapse */
    IonTextarea.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonTextarea.ɵfac = function IonTextarea_Factory(t) { return new (t || IonTextarea)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonTextarea.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonTextarea, selectors: [["ion-textarea"]], inputs: { autoGrow: "autoGrow", autocapitalize: "autocapitalize", autofocus: "autofocus", clearOnEdit: "clearOnEdit", color: "color", cols: "cols", debounce: "debounce", disabled: "disabled", maxlength: "maxlength", minlength: "minlength", mode: "mode", name: "name", placeholder: "placeholder", readonly: "readonly", required: "required", rows: "rows", spellcheck: "spellcheck", value: "value", wrap: "wrap" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonTextarea_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonTextarea, [{
        type: Component,
        args: [{ selector: 'ion-textarea', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['autoGrow', 'autocapitalize', 'autofocus', 'clearOnEdit', 'color', 'cols', 'debounce', 'disabled', 'maxlength', 'minlength', 'mode', 'name', 'placeholder', 'readonly', 'required', 'rows', 'spellcheck', 'value', 'wrap'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonTextarea;
}());
proxyMethods(IonTextarea, ['setFocus', 'getInputElement']);
proxyInputs(IonTextarea, ['autoGrow', 'autocapitalize', 'autofocus', 'clearOnEdit', 'color', 'cols', 'debounce', 'disabled', 'maxlength', 'minlength', 'mode', 'name', 'placeholder', 'readonly', 'required', 'rows', 'spellcheck', 'value', 'wrap']);
var IonThumbnail = /** @class */ (function () {
    function IonThumbnail(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonThumbnail.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonThumbnail.ɵfac = function IonThumbnail_Factory(t) { return new (t || IonThumbnail)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonThumbnail.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonThumbnail, selectors: [["ion-thumbnail"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonThumbnail_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonThumbnail, [{
        type: Component,
        args: [{ selector: 'ion-thumbnail', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>' }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonThumbnail;
}());
var IonTitle = /** @class */ (function () {
    function IonTitle(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonTitle.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonTitle.ɵfac = function IonTitle_Factory(t) { return new (t || IonTitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonTitle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonTitle, selectors: [["ion-title"]], inputs: { color: "color", size: "size" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonTitle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonTitle, [{
        type: Component,
        args: [{ selector: 'ion-title', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'size'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonTitle;
}());
proxyInputs(IonTitle, ['color', 'size']);
var IonToggle = /** @class */ (function () {
    function IonToggle(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);
    }
    /** @nocollapse */
    IonToggle.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonToggle.ɵfac = function IonToggle_Factory(t) { return new (t || IonToggle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonToggle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonToggle, selectors: [["ion-toggle"]], inputs: { checked: "checked", color: "color", disabled: "disabled", mode: "mode", name: "name", value: "value" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonToggle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonToggle, [{
        type: Component,
        args: [{ selector: 'ion-toggle', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['checked', 'color', 'disabled', 'mode', 'name', 'value'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonToggle;
}());
proxyInputs(IonToggle, ['checked', 'color', 'disabled', 'mode', 'name', 'value']);
var IonToolbar = /** @class */ (function () {
    function IonToolbar(c, r, z) {
        this.z = z;
        c.detach();
        this.el = r.nativeElement;
    }
    /** @nocollapse */
    IonToolbar.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
IonToolbar.ɵfac = function IonToolbar_Factory(t) { return new (t || IonToolbar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IonToolbar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonToolbar, selectors: [["ion-toolbar"]], inputs: { color: "color", mode: "mode" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonToolbar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonToolbar, [{
        type: Component,
        args: [{ selector: 'ion-toolbar', changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return IonToolbar;
}());
proxyInputs(IonToolbar, ['color', 'mode']);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Config = /** @class */ (function () {
    function Config() {
    }
    /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    Config.prototype.get = /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    function (key, fallback) {
        /** @type {?} */
        var c = getConfig();
        if (c) {
            return c.get(key, fallback);
        }
        return null;
    };
    /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    Config.prototype.getBoolean = /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    function (key, fallback) {
        /** @type {?} */
        var c = getConfig();
        if (c) {
            return c.getBoolean(key, fallback);
        }
        return false;
    };
    /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    Config.prototype.getNumber = /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    function (key, fallback) {
        /** @type {?} */
        var c = getConfig();
        if (c) {
            return c.getNumber(key, fallback);
        }
        return 0;
    };
    /**
     * @param {?} key
     * @param {?=} value
     * @return {?}
     */
    Config.prototype.set = /**
     * @param {?} key
     * @param {?=} value
     * @return {?}
     */
    function (key, value) {
        console.warn("[DEPRECATION][Config]: The Config.set() method is deprecated and will be removed in Ionic Framework 6.0. Please see https://ionicframework.com/docs/angular/config for alternatives.");
        /** @type {?} */
        var c = getConfig();
        if (c) {
            c.set(key, value);
        }
    };
    /** @nocollapse */ Config.ngInjectableDef = defineInjectable({ factory: function Config_Factory() { return new Config(); }, token: Config, providedIn: "root" });
Config.ɵfac = function Config_Factory(t) { return new (t || Config)(); };
Config.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Config, factory: function (t) { return Config.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Config, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return Config;
}());
/** @type {?} */
var ConfigToken = new InjectionToken('USERCONFIG');
/** @type {?} */
var getConfig = (/**
 * @return {?}
 */
function () {
    if (typeof ((/** @type {?} */ (window))) !== 'undefined') {
        /** @type {?} */
        var Ionic = ((/** @type {?} */ ((/** @type {?} */ (window))))).Ionic;
        if (Ionic && Ionic.config) {
            return Ionic.config;
        }
    }
    return null;
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * NavParams are an object that exists on a page and can contain data for that particular view.
 * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible
 * option with a simple `get` method.
 *
 * \@usage
 * ```ts
 * import { NavParams } from '\@ionic/angular';
 *
 * export class MyClass{
 *
 *  constructor(navParams: NavParams){
 *    // userParams is an object we have in our nav-parameters
 *    navParams.get('userParams');
 *  }
 *
 * }
 * ```
 */
var  /**
 * \@description
 * NavParams are an object that exists on a page and can contain data for that particular view.
 * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible
 * option with a simple `get` method.
 *
 * \@usage
 * ```ts
 * import { NavParams } from '\@ionic/angular';
 *
 * export class MyClass{
 *
 *  constructor(navParams: NavParams){
 *    // userParams is an object we have in our nav-parameters
 *    navParams.get('userParams');
 *  }
 *
 * }
 * ```
 */
NavParams = /** @class */ (function () {
    function NavParams(data) {
        if (data === void 0) { data = {}; }
        this.data = data;
    }
    /**
     * Get the value of a nav-parameter for the current view
     *
     * ```ts
     * import { NavParams } from 'ionic-angular';
     *
     * export class MyClass{
     *  constructor(public navParams: NavParams){
     *    // userParams is an object we have in our nav-parameters
     *    this.navParams.get('userParams');
     *  }
     * }
     * ```
     *
     * @param param Which param you want to look up
     */
    /**
     * Get the value of a nav-parameter for the current view
     *
     * ```ts
     * import { NavParams } from 'ionic-angular';
     *
     * export class MyClass{
     *  constructor(public navParams: NavParams){
     *    // userParams is an object we have in our nav-parameters
     *    this.navParams.get('userParams');
     *  }
     * }
     * ```
     *
     * @param {?} param Which param you want to look up
     * @return {?}
     */
    NavParams.prototype.get = /**
     * Get the value of a nav-parameter for the current view
     *
     * ```ts
     * import { NavParams } from 'ionic-angular';
     *
     * export class MyClass{
     *  constructor(public navParams: NavParams){
     *    // userParams is an object we have in our nav-parameters
     *    this.navParams.get('userParams');
     *  }
     * }
     * ```
     *
     * @param {?} param Which param you want to look up
     * @return {?}
     */
    function (param) {
        return this.data[param];
    };
    return NavParams;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AngularDelegate = /** @class */ (function () {
    function AngularDelegate(zone, appRef) {
        this.zone = zone;
        this.appRef = appRef;
    }
    /**
     * @param {?} resolver
     * @param {?} injector
     * @param {?=} location
     * @return {?}
     */
    AngularDelegate.prototype.create = /**
     * @param {?} resolver
     * @param {?} injector
     * @param {?=} location
     * @return {?}
     */
    function (resolver, injector, location) {
        return new AngularFrameworkDelegate(resolver, injector, location, this.appRef, this.zone);
    };
    /** @nocollapse */
    AngularDelegate.ctorParameters = function () { return [
        { type: NgZone },
        { type: ApplicationRef }
    ]; };
AngularDelegate.ɵfac = function AngularDelegate_Factory(t) { return new (t || AngularDelegate)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef)); };
AngularDelegate.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AngularDelegate, factory: function (t) { return AngularDelegate.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularDelegate, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ApplicationRef }]; }, null); })();
    return AngularDelegate;
}());
var AngularFrameworkDelegate = /** @class */ (function () {
    function AngularFrameworkDelegate(resolver, injector, location, appRef, zone) {
        this.resolver = resolver;
        this.injector = injector;
        this.location = location;
        this.appRef = appRef;
        this.zone = zone;
        this.elRefMap = new WeakMap();
        this.elEventsMap = new WeakMap();
    }
    /**
     * @param {?} container
     * @param {?} component
     * @param {?=} params
     * @param {?=} cssClasses
     * @return {?}
     */
    AngularFrameworkDelegate.prototype.attachViewToDom = /**
     * @param {?} container
     * @param {?} component
     * @param {?=} params
     * @param {?=} cssClasses
     * @return {?}
     */
    function (container, component, params, cssClasses) {
        var _this = this;
        return this.zone.run((/**
         * @return {?}
         */
        function () {
            return new Promise((/**
             * @param {?} resolve
             * @return {?}
             */
            function (resolve) {
                /** @type {?} */
                var el = attachView(_this.zone, _this.resolver, _this.injector, _this.location, _this.appRef, _this.elRefMap, _this.elEventsMap, container, component, params, cssClasses);
                resolve(el);
            }));
        }));
    };
    /**
     * @param {?} _container
     * @param {?} component
     * @return {?}
     */
    AngularFrameworkDelegate.prototype.removeViewFromDom = /**
     * @param {?} _container
     * @param {?} component
     * @return {?}
     */
    function (_container, component) {
        var _this = this;
        return this.zone.run((/**
         * @return {?}
         */
        function () {
            return new Promise((/**
             * @param {?} resolve
             * @return {?}
             */
            function (resolve) {
                /** @type {?} */
                var componentRef = _this.elRefMap.get(component);
                if (componentRef) {
                    componentRef.destroy();
                    _this.elRefMap.delete(component);
                    /** @type {?} */
                    var unbindEvents = _this.elEventsMap.get(component);
                    if (unbindEvents) {
                        unbindEvents();
                        _this.elEventsMap.delete(component);
                    }
                }
                resolve();
            }));
        }));
    };
    return AngularFrameworkDelegate;
}());
/** @type {?} */
var attachView = (/**
 * @param {?} zone
 * @param {?} resolver
 * @param {?} injector
 * @param {?} location
 * @param {?} appRef
 * @param {?} elRefMap
 * @param {?} elEventsMap
 * @param {?} container
 * @param {?} component
 * @param {?} params
 * @param {?} cssClasses
 * @return {?}
 */
function (zone, resolver, injector, location, appRef, elRefMap, elEventsMap, container, component, params, cssClasses) {
    /** @type {?} */
    var factory = resolver.resolveComponentFactory(component);
    /** @type {?} */
    var childInjector = Injector.create({
        providers: getProviders(params),
        parent: injector
    });
    /** @type {?} */
    var componentRef = (location)
        ? location.createComponent(factory, location.length, childInjector)
        : factory.create(childInjector);
    /** @type {?} */
    var instance = componentRef.instance;
    /** @type {?} */
    var hostElement = componentRef.location.nativeElement;
    if (params) {
        Object.assign(instance, params);
    }
    if (cssClasses) {
        for (var _i = 0, cssClasses_1 = cssClasses; _i < cssClasses_1.length; _i++) {
            var clazz = cssClasses_1[_i];
            hostElement.classList.add(clazz);
        }
    }
    /** @type {?} */
    var unbindEvents = bindLifecycleEvents(zone, instance, hostElement);
    container.appendChild(hostElement);
    if (!location) {
        appRef.attachView(componentRef.hostView);
    }
    componentRef.changeDetectorRef.reattach();
    elRefMap.set(hostElement, componentRef);
    elEventsMap.set(hostElement, unbindEvents);
    return hostElement;
});
/** @type {?} */
var LIFECYCLES = [
    LIFECYCLE_WILL_ENTER,
    LIFECYCLE_DID_ENTER,
    LIFECYCLE_WILL_LEAVE,
    LIFECYCLE_DID_LEAVE,
    LIFECYCLE_WILL_UNLOAD
];
/** @type {?} */
var bindLifecycleEvents = (/**
 * @param {?} zone
 * @param {?} instance
 * @param {?} element
 * @return {?}
 */
function (zone, instance, element) {
    return zone.run((/**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var unregisters = LIFECYCLES
            .filter((/**
         * @param {?} eventName
         * @return {?}
         */
        function (eventName) { return typeof instance[eventName] === 'function'; }))
            .map((/**
         * @param {?} eventName
         * @return {?}
         */
        function (eventName) {
            /** @type {?} */
            var handler = (/**
             * @param {?} ev
             * @return {?}
             */
            function (ev) { return instance[eventName](ev.detail); });
            element.addEventListener(eventName, handler);
            return (/**
             * @return {?}
             */
            function () { return element.removeEventListener(eventName, handler); });
        }));
        return (/**
         * @return {?}
         */
        function () { return unregisters.forEach((/**
         * @param {?} fn
         * @return {?}
         */
        function (fn) { return fn(); })); });
    }));
});
/** @type {?} */
var NavParamsToken = new InjectionToken('NavParamsToken');
/** @type {?} */
var getProviders = (/**
 * @param {?} params
 * @return {?}
 */
function (params) {
    return [
        {
            provide: NavParamsToken, useValue: params
        },
        {
            provide: NavParams, useFactory: provideNavParamsInjectable, deps: [NavParamsToken]
        }
    ];
});
/** @type {?} */
var provideNavParamsInjectable = (/**
 * @param {?} params
 * @return {?}
 */
function (params) {
    return new NavParams(params);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var insertView = (/**
 * @param {?} views
 * @param {?} view
 * @param {?} direction
 * @return {?}
 */
function (views, view, direction) {
    if (direction === 'root') {
        return setRoot(views, view);
    }
    else if (direction === 'forward') {
        return setForward(views, view);
    }
    else {
        return setBack(views, view);
    }
});
/** @type {?} */
var setRoot = (/**
 * @param {?} views
 * @param {?} view
 * @return {?}
 */
function (views, view) {
    views = views.filter((/**
     * @param {?} v
     * @return {?}
     */
    function (v) { return v.stackId !== view.stackId; }));
    views.push(view);
    return views;
});
/** @type {?} */
var setForward = (/**
 * @param {?} views
 * @param {?} view
 * @return {?}
 */
function (views, view) {
    /** @type {?} */
    var index = views.indexOf(view);
    if (index >= 0) {
        views = views.filter((/**
         * @param {?} v
         * @return {?}
         */
        function (v) { return v.stackId !== view.stackId || v.id <= view.id; }));
    }
    else {
        views.push(view);
    }
    return views;
});
/** @type {?} */
var setBack = (/**
 * @param {?} views
 * @param {?} view
 * @return {?}
 */
function (views, view) {
    /** @type {?} */
    var index = views.indexOf(view);
    if (index >= 0) {
        return views.filter((/**
         * @param {?} v
         * @return {?}
         */
        function (v) { return v.stackId !== view.stackId || v.id <= view.id; }));
    }
    else {
        return setRoot(views, view);
    }
});
/** @type {?} */
var getUrl = (/**
 * @param {?} router
 * @param {?} activatedRoute
 * @return {?}
 */
function (router, activatedRoute) {
    /** @type {?} */
    var urlTree = router.createUrlTree(['.'], { relativeTo: activatedRoute });
    return router.serializeUrl(urlTree);
});
/** @type {?} */
var isTabSwitch = (/**
 * @param {?} enteringView
 * @param {?} leavingView
 * @return {?}
 */
function (enteringView, leavingView) {
    if (!leavingView) {
        return true;
    }
    return enteringView.stackId !== leavingView.stackId;
});
/** @type {?} */
var computeStackId = (/**
 * @param {?} prefixUrl
 * @param {?} url
 * @return {?}
 */
function (prefixUrl, url) {
    if (!prefixUrl) {
        return undefined;
    }
    /** @type {?} */
    var segments = toSegments(url);
    for (var i = 0; i < segments.length; i++) {
        if (i >= prefixUrl.length) {
            return segments[i];
        }
        if (segments[i] !== prefixUrl[i]) {
            return undefined;
        }
    }
    return undefined;
});
/** @type {?} */
var toSegments = (/**
 * @param {?} path
 * @return {?}
 */
function (path) {
    return path
        .split('/')
        .map((/**
     * @param {?} s
     * @return {?}
     */
    function (s) { return s.trim(); }))
        .filter((/**
     * @param {?} s
     * @return {?}
     */
    function (s) { return s !== ''; }));
});
/** @type {?} */
var destroyView = (/**
 * @param {?} view
 * @return {?}
 */
function (view) {
    if (view) {
        // TODO lifecycle event
        view.ref.destroy();
        view.unlistenEvents();
    }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StackController = /** @class */ (function () {
    function StackController(tabsPrefix, containerEl, router, navCtrl, zone, location) {
        this.containerEl = containerEl;
        this.router = router;
        this.navCtrl = navCtrl;
        this.zone = zone;
        this.location = location;
        this.views = [];
        this.skipTransition = false;
        this.nextId = 0;
        this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;
    }
    /**
     * @param {?} ref
     * @param {?} activatedRoute
     * @return {?}
     */
    StackController.prototype.createView = /**
     * @param {?} ref
     * @param {?} activatedRoute
     * @return {?}
     */
    function (ref, activatedRoute) {
        /** @type {?} */
        var url = getUrl(this.router, activatedRoute);
        /** @type {?} */
        var element = (/** @type {?} */ ((ref && ref.location && ref.location.nativeElement)));
        /** @type {?} */
        var unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);
        return {
            id: this.nextId++,
            stackId: computeStackId(this.tabsPrefix, url),
            unlistenEvents: unlistenEvents,
            element: element,
            ref: ref,
            url: url,
        };
    };
    /**
     * @param {?} activatedRoute
     * @return {?}
     */
    StackController.prototype.getExistingView = /**
     * @param {?} activatedRoute
     * @return {?}
     */
    function (activatedRoute) {
        /** @type {?} */
        var activatedUrlKey = getUrl(this.router, activatedRoute);
        /** @type {?} */
        var view = this.views.find((/**
         * @param {?} vw
         * @return {?}
         */
        function (vw) { return vw.url === activatedUrlKey; }));
        if (view) {
            view.ref.changeDetectorRef.reattach();
        }
        return view;
    };
    /**
     * @param {?} enteringView
     * @return {?}
     */
    StackController.prototype.setActive = /**
     * @param {?} enteringView
     * @return {?}
     */
    function (enteringView) {
        var _this = this;
        var _a = this.navCtrl.consumeTransition(), direction = _a.direction, animation = _a.animation;
        /** @type {?} */
        var leavingView = this.activeView;
        /** @type {?} */
        var tabSwitch = isTabSwitch(enteringView, leavingView);
        if (tabSwitch) {
            direction = 'back';
            animation = undefined;
        }
        /** @type {?} */
        var viewsSnapshot = this.views.slice();
        /** @type {?} */
        var currentNavigation;
        /** @type {?} */
        var router = ((/** @type {?} */ (this.router)));
        // Angular >= 7.2.0
        if (router.getCurrentNavigation) {
            currentNavigation = router.getCurrentNavigation();
            // Angular < 7.2.0
        }
        else if (router.navigations &&
            router.navigations.value) {
            currentNavigation = router.navigations.value;
        }
        /**
         * If the navigation action
         * sets `replaceUrl: true`
         * then we need to make sure
         * we remove the last item
         * from our views stack
         */
        if (currentNavigation &&
            currentNavigation.extras &&
            currentNavigation.extras.replaceUrl) {
            if (this.views.length > 0) {
                this.views.splice(-1, 1);
            }
        }
        /** @type {?} */
        var reused = this.views.includes(enteringView);
        /** @type {?} */
        var views = this.insertView(enteringView, direction);
        // Trigger change detection before transition starts
        // This will call ngOnInit() the first time too, just after the view
        // was attached to the dom, but BEFORE the transition starts
        if (!reused) {
            enteringView.ref.changeDetectorRef.detectChanges();
        }
        // Wait until previous transitions finish
        return this.zone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            return _this.wait((/**
             * @return {?}
             */
            function () {
                // disconnect leaving page from change detection to
                // reduce jank during the page transition
                if (leavingView) {
                    leavingView.ref.changeDetectorRef.detach();
                }
                // In case the enteringView is the same as the leavingPage we need to reattach()
                enteringView.ref.changeDetectorRef.reattach();
                return _this.transition(enteringView, leavingView, animation, _this.canGoBack(1), false)
                    .then((/**
                 * @return {?}
                 */
                function () { return cleanupAsync(enteringView, views, viewsSnapshot, _this.location); }))
                    .then((/**
                 * @return {?}
                 */
                function () { return ({
                    enteringView: enteringView,
                    direction: direction,
                    animation: animation,
                    tabSwitch: tabSwitch
                }); }));
            }));
        }));
    };
    /**
     * @param {?} deep
     * @param {?=} stackId
     * @return {?}
     */
    StackController.prototype.canGoBack = /**
     * @param {?} deep
     * @param {?=} stackId
     * @return {?}
     */
    function (deep, stackId) {
        if (stackId === void 0) { stackId = this.getActiveStackId(); }
        return this.getStack(stackId).length > deep;
    };
    /**
     * @param {?} deep
     * @param {?=} stackId
     * @return {?}
     */
    StackController.prototype.pop = /**
     * @param {?} deep
     * @param {?=} stackId
     * @return {?}
     */
    function (deep, stackId) {
        var _this = this;
        if (stackId === void 0) { stackId = this.getActiveStackId(); }
        return this.zone.run((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var views = _this.getStack(stackId);
            if (views.length <= deep) {
                return Promise.resolve(false);
            }
            /** @type {?} */
            var view = views[views.length - deep - 1];
            /** @type {?} */
            var url = view.url;
            /** @type {?} */
            var viewSavedData = view.savedData;
            if (viewSavedData) {
                /** @type {?} */
                var primaryOutlet = viewSavedData.get('primary');
                if (primaryOutlet &&
                    primaryOutlet.route &&
                    primaryOutlet.route._routerState &&
                    primaryOutlet.route._routerState.snapshot &&
                    primaryOutlet.route._routerState.snapshot.url) {
                    url = primaryOutlet.route._routerState.snapshot.url;
                }
            }
            return _this.navCtrl.navigateBack(url, view.savedExtras).then((/**
             * @return {?}
             */
            function () { return true; }));
        }));
    };
    /**
     * @return {?}
     */
    StackController.prototype.startBackTransition = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var leavingView = this.activeView;
        if (leavingView) {
            /** @type {?} */
            var views = this.getStack(leavingView.stackId);
            /** @type {?} */
            var enteringView_1 = views[views.length - 2];
            return this.wait((/**
             * @return {?}
             */
            function () {
                return _this.transition(enteringView_1, // entering view
                leavingView, // leaving view
                'back', _this.canGoBack(2), true);
            }));
        }
        return Promise.resolve();
    };
    /**
     * @param {?} shouldComplete
     * @return {?}
     */
    StackController.prototype.endBackTransition = /**
     * @param {?} shouldComplete
     * @return {?}
     */
    function (shouldComplete) {
        if (shouldComplete) {
            this.skipTransition = true;
            this.pop(1);
        }
        else if (this.activeView) {
            cleanup(this.activeView, this.views, this.views, this.location);
        }
    };
    /**
     * @param {?=} stackId
     * @return {?}
     */
    StackController.prototype.getLastUrl = /**
     * @param {?=} stackId
     * @return {?}
     */
    function (stackId) {
        /** @type {?} */
        var views = this.getStack(stackId);
        return views.length > 0 ? views[views.length - 1] : undefined;
    };
    /**
     * @return {?}
     */
    StackController.prototype.getActiveStackId = /**
     * @return {?}
     */
    function () {
        return this.activeView ? this.activeView.stackId : undefined;
    };
    /**
     * @return {?}
     */
    StackController.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.containerEl = (/** @type {?} */ (undefined));
        this.views.forEach(destroyView);
        this.activeView = undefined;
        this.views = [];
    };
    /**
     * @private
     * @param {?} stackId
     * @return {?}
     */
    StackController.prototype.getStack = /**
     * @private
     * @param {?} stackId
     * @return {?}
     */
    function (stackId) {
        return this.views.filter((/**
         * @param {?} v
         * @return {?}
         */
        function (v) { return v.stackId === stackId; }));
    };
    /**
     * @private
     * @param {?} enteringView
     * @param {?} direction
     * @return {?}
     */
    StackController.prototype.insertView = /**
     * @private
     * @param {?} enteringView
     * @param {?} direction
     * @return {?}
     */
    function (enteringView, direction) {
        this.activeView = enteringView;
        this.views = insertView(this.views, enteringView, direction);
        return this.views.slice();
    };
    /**
     * @private
     * @param {?} enteringView
     * @param {?} leavingView
     * @param {?} direction
     * @param {?} showGoBack
     * @param {?} progressAnimation
     * @return {?}
     */
    StackController.prototype.transition = /**
     * @private
     * @param {?} enteringView
     * @param {?} leavingView
     * @param {?} direction
     * @param {?} showGoBack
     * @param {?} progressAnimation
     * @return {?}
     */
    function (enteringView, leavingView, direction, showGoBack, progressAnimation) {
        if (this.skipTransition) {
            this.skipTransition = false;
            return Promise.resolve(false);
        }
        if (leavingView === enteringView) {
            return Promise.resolve(false);
        }
        /** @type {?} */
        var enteringEl = enteringView ? enteringView.element : undefined;
        /** @type {?} */
        var leavingEl = leavingView ? leavingView.element : undefined;
        /** @type {?} */
        var containerEl = this.containerEl;
        if (enteringEl && enteringEl !== leavingEl) {
            enteringEl.classList.add('ion-page');
            enteringEl.classList.add('ion-page-invisible');
            if (enteringEl.parentElement !== containerEl) {
                containerEl.appendChild(enteringEl);
            }
            if (((/** @type {?} */ (containerEl))).commit) {
                return containerEl.commit(enteringEl, leavingEl, {
                    deepWait: true,
                    duration: direction === undefined ? 0 : undefined,
                    direction: direction,
                    showGoBack: showGoBack,
                    progressAnimation: progressAnimation
                });
            }
        }
        return Promise.resolve(false);
    };
    /**
     * @private
     * @template T
     * @param {?} task
     * @return {?}
     */
    StackController.prototype.wait = /**
     * @private
     * @template T
     * @param {?} task
     * @return {?}
     */
    function (task) {
        return __awaiter(this, void 0, void 0, function () {
            var promise;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.runningTask !== undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.runningTask];
                    case 1:
                        _a.sent();
                        this.runningTask = undefined;
                        _a.label = 2;
                    case 2:
                        promise = this.runningTask = task();
                        return [2 /*return*/, promise];
                }
            });
        });
    };
    return StackController;
}());
/** @type {?} */
var cleanupAsync = (/**
 * @param {?} activeRoute
 * @param {?} views
 * @param {?} viewsSnapshot
 * @param {?} location
 * @return {?}
 */
function (activeRoute, views, viewsSnapshot, location) {
    if (typeof ((/** @type {?} */ (requestAnimationFrame))) === 'function') {
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        function (resolve) {
            requestAnimationFrame((/**
             * @return {?}
             */
            function () {
                cleanup(activeRoute, views, viewsSnapshot, location);
                resolve();
            }));
        }));
    }
    return Promise.resolve();
});
/** @type {?} */
var cleanup = (/**
 * @param {?} activeRoute
 * @param {?} views
 * @param {?} viewsSnapshot
 * @param {?} location
 * @return {?}
 */
function (activeRoute, views, viewsSnapshot, location) {
    viewsSnapshot
        .filter((/**
     * @param {?} view
     * @return {?}
     */
    function (view) { return !views.includes(view); }))
        .forEach(destroyView);
    views.forEach((/**
     * @param {?} view
     * @return {?}
     */
    function (view) {
        /**
         * In the event that a user navigated multiple
         * times in rapid succession, we want to make sure
         * we don't pre-emptively detach a view while
         * it is in mid-transition.
         *
         * In this instance we also do not care about query
         * params or fragments as it will be the same view regardless
         * @type {?}
         */
        var locationWithoutParams = location.path().split('?')[0];
        /** @type {?} */
        var locationWithoutFragment = locationWithoutParams.split('#')[0];
        if (view !== activeRoute && view.url !== locationWithoutFragment) {
            /** @type {?} */
            var element = view.element;
            element.setAttribute('aria-hidden', 'true');
            element.classList.add('ion-page-hidden');
            view.ref.changeDetectorRef.detach();
        }
    }));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonRouterOutlet = /** @class */ (function () {
    function IonRouterOutlet(parentContexts, location, resolver, name, tabs, config, navCtrl, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {
        this.parentContexts = parentContexts;
        this.location = location;
        this.resolver = resolver;
        this.config = config;
        this.navCtrl = navCtrl;
        this.parentOutlet = parentOutlet;
        this.activated = null;
        this.activatedView = null;
        this._activatedRoute = null;
        // Maintain map of activated route proxies for each component instance
        this.proxyMap = new WeakMap();
        // Keep the latest activated route in a subject for the proxy routes to switch map to
        this.currentActivatedRoute$ = new BehaviorSubject(null);
        this.stackEvents = new EventEmitter();
        this.activateEvents = new EventEmitter();
        this.deactivateEvents = new EventEmitter();
        this.nativeEl = elementRef.nativeElement;
        this.name = name || PRIMARY_OUTLET;
        this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;
        this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, navCtrl, zone, commonLocation);
        parentContexts.onChildOutletCreated(this.name, (/** @type {?} */ (this)));
    }
    Object.defineProperty(IonRouterOutlet.prototype, "animated", {
        set: /**
         * @param {?} animated
         * @return {?}
         */
        function (animated) {
            this.nativeEl.animated = animated;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IonRouterOutlet.prototype, "swipeGesture", {
        set: /**
         * @param {?} swipe
         * @return {?}
         */
        function (swipe) {
            var _this = this;
            this._swipeGesture = swipe;
            this.nativeEl.swipeHandler = swipe ? {
                canStart: (/**
                 * @return {?}
                 */
                function () { return _this.stackCtrl.canGoBack(1); }),
                onStart: (/**
                 * @return {?}
                 */
                function () { return _this.stackCtrl.startBackTransition(); }),
                onEnd: (/**
                 * @param {?} shouldContinue
                 * @return {?}
                 */
                function (shouldContinue) { return _this.stackCtrl.endBackTransition(shouldContinue); })
            } : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IonRouterOutlet.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.stackCtrl.destroy();
    };
    /**
     * @return {?}
     */
    IonRouterOutlet.prototype.getContext = /**
     * @return {?}
     */
    function () {
        return this.parentContexts.getContext(this.name);
    };
    /**
     * @return {?}
     */
    IonRouterOutlet.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.activated) {
            // If the outlet was not instantiated at the time the route got activated we need to populate
            // the outlet when it is initialized (ie inside a NgIf)
            /** @type {?} */
            var context = this.getContext();
            if (context && context.route) {
                this.activateWith(context.route, context.resolver || null);
            }
        }
        if (((/** @type {?} */ (this.nativeEl))).componentOnReady) {
            this.nativeEl.componentOnReady().then((/**
             * @return {?}
             */
            function () {
                if (_this._swipeGesture === undefined) {
                    _this.swipeGesture = _this.config.getBoolean('swipeBackEnabled', ((/** @type {?} */ (_this.nativeEl))).mode === 'ios');
                }
            }));
        }
    };
    Object.defineProperty(IonRouterOutlet.prototype, "isActivated", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.activated;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IonRouterOutlet.prototype, "component", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.activated) {
                throw new Error('Outlet is not activated');
            }
            return this.activated.instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IonRouterOutlet.prototype, "activatedRoute", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.activated) {
                throw new Error('Outlet is not activated');
            }
            return (/** @type {?} */ (this._activatedRoute));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IonRouterOutlet.prototype, "activatedRouteData", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._activatedRoute) {
                return this._activatedRoute.snapshot.data;
            }
            return {};
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     */
    /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     * @return {?}
     */
    IonRouterOutlet.prototype.detach = /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     * @return {?}
     */
    function () {
        throw new Error('incompatible reuse strategy');
    };
    /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     */
    /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     * @param {?} _ref
     * @param {?} _activatedRoute
     * @return {?}
     */
    IonRouterOutlet.prototype.attach = /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     * @param {?} _ref
     * @param {?} _activatedRoute
     * @return {?}
     */
    function (_ref, _activatedRoute) {
        throw new Error('incompatible reuse strategy');
    };
    /**
     * @return {?}
     */
    IonRouterOutlet.prototype.deactivate = /**
     * @return {?}
     */
    function () {
        if (this.activated) {
            if (this.activatedView) {
                this.activatedView.savedData = new Map((/** @type {?} */ (this.getContext())).children['contexts']);
                /**
                 * Ensure we are saving the NavigationExtras
                 * data otherwise it will be lost
                 */
                this.activatedView.savedExtras = {};
                /** @type {?} */
                var context = (/** @type {?} */ (this.getContext()));
                if (context.route) {
                    /** @type {?} */
                    var contextSnapshot = context.route.snapshot;
                    this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;
                    this.activatedView.savedExtras.fragment = contextSnapshot.fragment;
                }
            }
            /** @type {?} */
            var c = this.component;
            this.activatedView = null;
            this.activated = null;
            this._activatedRoute = null;
            this.deactivateEvents.emit(c);
        }
    };
    /**
     * @param {?} activatedRoute
     * @param {?} resolver
     * @return {?}
     */
    IonRouterOutlet.prototype.activateWith = /**
     * @param {?} activatedRoute
     * @param {?} resolver
     * @return {?}
     */
    function (activatedRoute, resolver) {
        var _this = this;
        if (this.isActivated) {
            throw new Error('Cannot activate an already activated outlet');
        }
        this._activatedRoute = activatedRoute;
        /** @type {?} */
        var cmpRef;
        /** @type {?} */
        var enteringView = this.stackCtrl.getExistingView(activatedRoute);
        if (enteringView) {
            cmpRef = this.activated = enteringView.ref;
            /** @type {?} */
            var saved = enteringView.savedData;
            if (saved) {
                // self-restore
                /** @type {?} */
                var context = (/** @type {?} */ (this.getContext()));
                context.children['contexts'] = saved;
            }
            // Updated activated route proxy for this component
            this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);
        }
        else {
            /** @type {?} */
            var snapshot = ((/** @type {?} */ (activatedRoute)))._futureSnapshot;
            /** @type {?} */
            var component = (/** @type {?} */ ((/** @type {?} */ (snapshot.routeConfig)).component));
            resolver = resolver || this.resolver;
            /** @type {?} */
            var factory = resolver.resolveComponentFactory(component);
            /** @type {?} */
            var childContexts = this.parentContexts.getOrCreateContext(this.name).children;
            // We create an activated route proxy object that will maintain future updates for this component
            // over its lifecycle in the stack.
            /** @type {?} */
            var component$ = new BehaviorSubject(null);
            /** @type {?} */
            var activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);
            /** @type {?} */
            var injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector);
            cmpRef = this.activated = this.location.createComponent(factory, this.location.length, injector);
            // Once the component is created we can push it to our local subject supplied to the proxy
            component$.next(cmpRef.instance);
            // Calling `markForCheck` to make sure we will run the change detection when the
            // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.
            enteringView = this.stackCtrl.createView(this.activated, activatedRoute);
            // Store references to the proxy by component
            this.proxyMap.set(cmpRef.instance, activatedRouteProxy);
            this.currentActivatedRoute$.next({ component: cmpRef.instance, activatedRoute: activatedRoute });
        }
        this.activatedView = enteringView;
        this.stackCtrl.setActive(enteringView).then((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            _this.navCtrl.setTopOutlet(_this);
            _this.activateEvents.emit(cmpRef.instance);
            _this.stackEvents.emit(data);
        }));
    };
    /**
     * Returns `true` if there are pages in the stack to go back.
     */
    /**
     * Returns `true` if there are pages in the stack to go back.
     * @param {?=} deep
     * @param {?=} stackId
     * @return {?}
     */
    IonRouterOutlet.prototype.canGoBack = /**
     * Returns `true` if there are pages in the stack to go back.
     * @param {?=} deep
     * @param {?=} stackId
     * @return {?}
     */
    function (deep, stackId) {
        if (deep === void 0) { deep = 1; }
        return this.stackCtrl.canGoBack(deep, stackId);
    };
    /**
     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.
     */
    /**
     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.
     * @param {?=} deep
     * @param {?=} stackId
     * @return {?}
     */
    IonRouterOutlet.prototype.pop = /**
     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.
     * @param {?=} deep
     * @param {?=} stackId
     * @return {?}
     */
    function (deep, stackId) {
        if (deep === void 0) { deep = 1; }
        return this.stackCtrl.pop(deep, stackId);
    };
    /**
     * Returns the URL of the active page of each stack.
     */
    /**
     * Returns the URL of the active page of each stack.
     * @param {?=} stackId
     * @return {?}
     */
    IonRouterOutlet.prototype.getLastUrl = /**
     * Returns the URL of the active page of each stack.
     * @param {?=} stackId
     * @return {?}
     */
    function (stackId) {
        /** @type {?} */
        var active = this.stackCtrl.getLastUrl(stackId);
        return active ? active.url : undefined;
    };
    /**
     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.
     */
    /**
     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.
     * @return {?}
     */
    IonRouterOutlet.prototype.getActiveStackId = /**
     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.
     * @return {?}
     */
    function () {
        return this.stackCtrl.getActiveStackId();
    };
    /**
     * Since the activated route can change over the life time of a component in an ion router outlet, we create
     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.
     */
    /**
     * Since the activated route can change over the life time of a component in an ion router outlet, we create
     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.
     * @private
     * @param {?} component$
     * @param {?} activatedRoute
     * @return {?}
     */
    IonRouterOutlet.prototype.createActivatedRouteProxy = /**
     * Since the activated route can change over the life time of a component in an ion router outlet, we create
     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.
     * @private
     * @param {?} component$
     * @param {?} activatedRoute
     * @return {?}
     */
    function (component$, activatedRoute) {
        /** @type {?} */
        var proxy = new ActivatedRoute();
        proxy._futureSnapshot = ((/** @type {?} */ (activatedRoute)))._futureSnapshot;
        proxy._routerState = ((/** @type {?} */ (activatedRoute)))._routerState;
        proxy.snapshot = activatedRoute.snapshot;
        proxy.outlet = activatedRoute.outlet;
        proxy.component = activatedRoute.component;
        // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates
        ((/** @type {?} */ (proxy)))._paramMap = this.proxyObservable(component$, 'paramMap');
        ((/** @type {?} */ (proxy)))._queryParamMap = this.proxyObservable(component$, 'queryParamMap');
        proxy.url = this.proxyObservable(component$, 'url');
        proxy.params = this.proxyObservable(component$, 'params');
        proxy.queryParams = this.proxyObservable(component$, 'queryParams');
        proxy.fragment = this.proxyObservable(component$, 'fragment');
        proxy.data = this.proxyObservable(component$, 'data');
        return (/** @type {?} */ (proxy));
    };
    /**
     * Create a wrapped observable that will switch to the latest activated route matched by the given component
     */
    /**
     * Create a wrapped observable that will switch to the latest activated route matched by the given component
     * @private
     * @param {?} component$
     * @param {?} path
     * @return {?}
     */
    IonRouterOutlet.prototype.proxyObservable = /**
     * Create a wrapped observable that will switch to the latest activated route matched by the given component
     * @private
     * @param {?} component$
     * @param {?} path
     * @return {?}
     */
    function (component$, path) {
        var _this = this;
        return component$.pipe(
        // First wait until the component instance is pushed
        filter((/**
         * @param {?} component
         * @return {?}
         */
        function (component) { return !!component; })), switchMap((/**
         * @param {?} component
         * @return {?}
         */
        function (component) {
            return _this.currentActivatedRoute$.pipe(filter((/**
             * @param {?} current
             * @return {?}
             */
            function (current) { return current !== null && current.component === component; })), switchMap((/**
             * @param {?} current
             * @return {?}
             */
            function (current) { return current && ((/** @type {?} */ (current.activatedRoute)))[path]; })), distinctUntilChanged());
        })));
    };
    /**
     * Updates the activated route proxy for the given component to the new incoming router state
     */
    /**
     * Updates the activated route proxy for the given component to the new incoming router state
     * @private
     * @param {?} component
     * @param {?} activatedRoute
     * @return {?}
     */
    IonRouterOutlet.prototype.updateActivatedRouteProxy = /**
     * Updates the activated route proxy for the given component to the new incoming router state
     * @private
     * @param {?} component
     * @param {?} activatedRoute
     * @return {?}
     */
    function (component, activatedRoute) {
        /** @type {?} */
        var proxy = this.proxyMap.get(component);
        if (!proxy) {
            throw new Error("Could not find activated route proxy for view");
        }
        ((/** @type {?} */ (proxy)))._futureSnapshot = ((/** @type {?} */ (activatedRoute)))._futureSnapshot;
        ((/** @type {?} */ (proxy)))._routerState = ((/** @type {?} */ (activatedRoute)))._routerState;
        proxy.snapshot = activatedRoute.snapshot;
        proxy.outlet = activatedRoute.outlet;
        proxy.component = activatedRoute.component;
        this.currentActivatedRoute$.next({ component: component, activatedRoute: activatedRoute });
    };
    /** @nocollapse */
    IonRouterOutlet.ctorParameters = function () { return [
        { type: ChildrenOutletContexts },
        { type: ViewContainerRef },
        { type: ComponentFactoryResolver },
        { type: String, decorators: [{ type: Attribute, args: ['name',] }] },
        { type: String, decorators: [{ type: Optional }, { type: Attribute, args: ['tabs',] }] },
        { type: Config },
        { type: NavController },
        { type: Location },
        { type: ElementRef },
        { type: Router },
        { type: NgZone },
        { type: ActivatedRoute },
        { type: IonRouterOutlet, decorators: [{ type: SkipSelf }, { type: Optional }] }
    ]; };
    IonRouterOutlet.propDecorators = {
        stackEvents: [{ type: Output }],
        activateEvents: [{ type: Output, args: ['activate',] }],
        deactivateEvents: [{ type: Output, args: ['deactivate',] }]
    };
IonRouterOutlet.ɵfac = function IonRouterOutlet_Factory(t) { return new (t || IonRouterOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ChildrenOutletContexts), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinjectAttribute('name'), ɵngcc0.ɵɵinjectAttribute('tabs'), ɵngcc0.ɵɵdirectiveInject(Config), ɵngcc0.ɵɵdirectiveInject(NavController), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Location), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(IonRouterOutlet, 12)); };
IonRouterOutlet.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IonRouterOutlet, selectors: [["ion-router-outlet"]], inputs: { animated: "animated", swipeGesture: "swipeGesture" }, outputs: { stackEvents: "stackEvents", activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonRouterOutlet, [{
        type: Directive,
        args: [{
                selector: 'ion-router-outlet',
                exportAs: 'outlet',
                inputs: ['animated', 'swipeGesture']
            }]
    }], function () { return [{ type: ɵngcc2.ChildrenOutletContexts }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: String, decorators: [{
                type: Attribute,
                args: ['name']
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Attribute,
                args: ['tabs']
            }] }, { type: Config }, { type: NavController }, { type: ɵngcc1.Location }, { type: ɵngcc0.ElementRef }, { type: ɵngcc2.Router }, { type: ɵngcc0.NgZone }, { type: ɵngcc2.ActivatedRoute }, { type: IonRouterOutlet, decorators: [{
                type: SkipSelf
            }, {
                type: Optional
            }] }]; }, { stackEvents: [{
            type: Output
        }], activateEvents: [{
            type: Output,
            args: ['activate']
        }], deactivateEvents: [{
            type: Output,
            args: ['deactivate']
        }] }); })();
    return IonRouterOutlet;
}());
var OutletInjector = /** @class */ (function () {
    function OutletInjector(route, childContexts, parent) {
        this.route = route;
        this.childContexts = childContexts;
        this.parent = parent;
    }
    /**
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    OutletInjector.prototype.get = /**
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    function (token, notFoundValue) {
        if (token === ActivatedRoute) {
            return this.route;
        }
        if (token === ChildrenOutletContexts) {
            return this.childContexts;
        }
        // tslint:disable-next-line
        return this.parent.get(token, notFoundValue);
    };
    return OutletInjector;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonTabs = /** @class */ (function () {
    function IonTabs(navCtrl) {
        this.navCtrl = navCtrl;
        this.ionTabsWillChange = new EventEmitter();
        this.ionTabsDidChange = new EventEmitter();
    }
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} detail
     * @return {?}
     */
    IonTabs.prototype.onPageSelected = /**
     * \@internal
     * @param {?} detail
     * @return {?}
     */
    function (detail) {
        /** @type {?} */
        var stackId = detail.enteringView.stackId;
        if (detail.tabSwitch && stackId !== undefined) {
            if (this.tabBar) {
                this.tabBar.selectedTab = stackId;
            }
            this.ionTabsWillChange.emit({ tab: stackId });
            this.ionTabsDidChange.emit({ tab: stackId });
        }
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    IonTabs.prototype.select = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        /** @type {?} */
        var alreadySelected = this.outlet.getActiveStackId() === tab;
        /** @type {?} */
        var href = this.outlet.tabsPrefix + "/" + tab;
        /** @type {?} */
        var url = alreadySelected
            ? href
            : this.outlet.getLastUrl(tab) || href;
        return this.navCtrl.navigateRoot(url, {
            animated: true,
            animationDirection: 'back'
        });
    };
    /**
     * @return {?}
     */
    IonTabs.prototype.getSelected = /**
     * @return {?}
     */
    function () {
        return this.outlet.getActiveStackId();
    };
    /** @nocollapse */
    IonTabs.ctorParameters = function () { return [
        { type: NavController }
    ]; };
    IonTabs.propDecorators = {
        outlet: [{ type: ViewChild, args: ['outlet', { read: IonRouterOutlet },] }],
        tabBar: [{ type: ContentChild, args: [IonTabBar,] }],
        ionTabsWillChange: [{ type: Output }],
        ionTabsDidChange: [{ type: Output }],
        select: [{ type: HostListener, args: ['ionTabButtonClick', ['$event.detail.tab'],] }]
    };
IonTabs.ɵfac = function IonTabs_Factory(t) { return new (t || IonTabs)(ɵngcc0.ɵɵdirectiveInject(NavController)); };
IonTabs.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonTabs, selectors: [["ion-tabs"]], contentQueries: function IonTabs_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IonTabBar, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabBar = _t.first);
    } }, viewQuery: function IonTabs_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, true, IonRouterOutlet);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.outlet = _t.first);
    } }, hostBindings: function IonTabs_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("ionTabButtonClick", function IonTabs_ionTabButtonClick_HostBindingHandler($event) { return ctx.select($event.detail.tab); });
    } }, outputs: { ionTabsWillChange: "ionTabsWillChange", ionTabsDidChange: "ionTabsDidChange" }, ngContentSelectors: _c3, decls: 5, vars: 0, consts: [[1, "tabs-inner"], ["tabs", "true", 3, "stackEvents"], ["outlet", ""]], template: function IonTabs_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c2);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵelementStart(2, "ion-router-outlet", 1, 2);
        ɵngcc0.ɵɵlistener("stackEvents", function IonTabs_Template_ion_router_outlet_stackEvents_2_listener($event) { return ctx.onPageSelected($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(4, 1);
    } }, directives: [IonRouterOutlet], styles: ["[_nghost-%COMP%] {\n      display: flex;\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n\n      flex-direction: column;\n\n      width: 100%;\n      height: 100%;\n\n      contain: layout size style;\n      z-index: $z-index-page-container;\n    }\n    .tabs-inner[_ngcontent-%COMP%] {\n      position: relative;\n\n      flex: 1;\n\n      contain: layout size style;\n    }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonTabs, [{
        type: Component,
        args: [{
                selector: 'ion-tabs',
                template: "\n    <ng-content select=\"[slot=top]\"></ng-content>\n    <div class=\"tabs-inner\">\n      <ion-router-outlet #outlet tabs=\"true\" (stackEvents)=\"onPageSelected($event)\"></ion-router-outlet>\n    </div>\n    <ng-content></ng-content>",
                styles: ["\n    :host {\n      display: flex;\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n\n      flex-direction: column;\n\n      width: 100%;\n      height: 100%;\n\n      contain: layout size style;\n      z-index: $z-index-page-container;\n    }\n    .tabs-inner {\n      position: relative;\n\n      flex: 1;\n\n      contain: layout size style;\n    }"
                ]
            }]
    }], function () { return [{ type: NavController }]; }, { ionTabsWillChange: [{
            type: Output
        }], ionTabsDidChange: [{
            type: Output
        }], select: [{
            type: HostListener,
            args: ['ionTabButtonClick', ['$event.detail.tab']]
        }], outlet: [{
            type: ViewChild,
            args: ['outlet', { read: IonRouterOutlet }]
        }], tabBar: [{
            type: ContentChild,
            args: [IonTabBar]
        }] }); })();
    return IonTabs;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonBackButtonDelegate = /** @class */ (function () {
    function IonBackButtonDelegate(routerOutlet, navCtrl) {
        this.routerOutlet = routerOutlet;
        this.navCtrl = navCtrl;
    }
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} ev
     * @return {?}
     */
    IonBackButtonDelegate.prototype.onClick = /**
     * \@internal
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        if (this.routerOutlet && this.routerOutlet.canGoBack()) {
            this.routerOutlet.pop();
            ev.preventDefault();
        }
        else if (this.defaultHref != null) {
            this.navCtrl.navigateBack(this.defaultHref);
            ev.preventDefault();
        }
    };
    /** @nocollapse */
    IonBackButtonDelegate.ctorParameters = function () { return [
        { type: IonRouterOutlet, decorators: [{ type: Optional }] },
        { type: NavController }
    ]; };
    IonBackButtonDelegate.propDecorators = {
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
IonBackButtonDelegate.ɵfac = function IonBackButtonDelegate_Factory(t) { return new (t || IonBackButtonDelegate)(ɵngcc0.ɵɵdirectiveInject(IonRouterOutlet, 8), ɵngcc0.ɵɵdirectiveInject(NavController)); };
IonBackButtonDelegate.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IonBackButtonDelegate, selectors: [["ion-back-button"]], hostBindings: function IonBackButtonDelegate_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IonBackButtonDelegate_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } }, inputs: { defaultHref: "defaultHref" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonBackButtonDelegate, [{
        type: Directive,
        args: [{
                selector: 'ion-back-button',
                inputs: ['defaultHref']
            }]
    }], function () { return [{ type: IonRouterOutlet, decorators: [{
                type: Optional
            }] }, { type: NavController }]; }, { onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
    return IonBackButtonDelegate;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NavDelegate = /** @class */ (function () {
    function NavDelegate(ref, resolver, injector, angularDelegate, location) {
        ref.nativeElement.delegate = angularDelegate.create(resolver, injector, location);
    }
    /** @nocollapse */
    NavDelegate.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ComponentFactoryResolver },
        { type: Injector },
        { type: AngularDelegate },
        { type: ViewContainerRef }
    ]; };
NavDelegate.ɵfac = function NavDelegate_Factory(t) { return new (t || NavDelegate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(AngularDelegate), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
NavDelegate.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NavDelegate, selectors: [["ion-nav"]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavDelegate, [{
        type: Directive,
        args: [{
                selector: 'ion-nav'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Injector }, { type: AngularDelegate }, { type: ɵngcc0.ViewContainerRef }]; }, null); })();
    return NavDelegate;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RouterLinkDelegate = /** @class */ (function () {
    function RouterLinkDelegate(locationStrategy, navCtrl, elementRef, router, routerLink) {
        this.locationStrategy = locationStrategy;
        this.navCtrl = navCtrl;
        this.elementRef = elementRef;
        this.router = router;
        this.routerLink = routerLink;
        this.routerDirection = 'forward';
    }
    /**
     * @return {?}
     */
    RouterLinkDelegate.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.updateTargetUrlAndHref();
    };
    /**
     * @return {?}
     */
    RouterLinkDelegate.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        this.updateTargetUrlAndHref();
    };
    /**
     * @return {?}
     */
    RouterLinkDelegate.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    };
    /**
     * @private
     * @return {?}
     */
    RouterLinkDelegate.prototype.updateTargetUrlAndHref = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.routerLink) {
            /** @type {?} */
            var href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));
            this.elementRef.nativeElement.href = href;
        }
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} ev
     * @return {?}
     */
    RouterLinkDelegate.prototype.onClick = /**
     * \@internal
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        this.navCtrl.setDirection(this.routerDirection);
        ev.preventDefault();
    };
    /** @nocollapse */
    RouterLinkDelegate.ctorParameters = function () { return [
        { type: LocationStrategy },
        { type: NavController },
        { type: ElementRef },
        { type: Router },
        { type: RouterLink, decorators: [{ type: Optional }] }
    ]; };
    RouterLinkDelegate.propDecorators = {
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
RouterLinkDelegate.ɵfac = function RouterLinkDelegate_Factory(t) { return new (t || RouterLinkDelegate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocationStrategy), ɵngcc0.ɵɵdirectiveInject(NavController), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.RouterLink, 8)); };
RouterLinkDelegate.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterLinkDelegate, selectors: [["", "routerLink", ""]], hostBindings: function RouterLinkDelegate_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function RouterLinkDelegate_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } }, inputs: { routerDirection: "routerDirection" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterLinkDelegate, [{
        type: Directive,
        args: [{
                selector: '[routerLink]',
                inputs: ['routerDirection']
            }]
    }], function () { return [{ type: ɵngcc1.LocationStrategy }, { type: NavController }, { type: ɵngcc0.ElementRef }, { type: ɵngcc2.Router }, { type: ɵngcc2.RouterLink, decorators: [{
                type: Optional
            }] }]; }, { onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
    return RouterLinkDelegate;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var VirtualFooter = /** @class */ (function () {
    function VirtualFooter(templateRef) {
        this.templateRef = templateRef;
    }
    /** @nocollapse */
    VirtualFooter.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
VirtualFooter.ɵfac = function VirtualFooter_Factory(t) { return new (t || VirtualFooter)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
VirtualFooter.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: VirtualFooter, selectors: [["", "virtualFooter", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VirtualFooter, [{
        type: Directive,
        args: [{ selector: '[virtualFooter]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
    return VirtualFooter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var VirtualHeader = /** @class */ (function () {
    function VirtualHeader(templateRef) {
        this.templateRef = templateRef;
    }
    /** @nocollapse */
    VirtualHeader.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
VirtualHeader.ɵfac = function VirtualHeader_Factory(t) { return new (t || VirtualHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
VirtualHeader.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: VirtualHeader, selectors: [["", "virtualHeader", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VirtualHeader, [{
        type: Directive,
        args: [{ selector: '[virtualHeader]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
    return VirtualHeader;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var VirtualItem = /** @class */ (function () {
    function VirtualItem(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
    /** @nocollapse */
    VirtualItem.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
VirtualItem.ɵfac = function VirtualItem_Factory(t) { return new (t || VirtualItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
VirtualItem.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: VirtualItem, selectors: [["", "virtualItem", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VirtualItem, [{
        type: Directive,
        args: [{ selector: '[virtualItem]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }]; }, null); })();
    return VirtualItem;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonVirtualScroll = /** @class */ (function () {
    function IonVirtualScroll(z, iterableDiffers, elementRef) {
        this.z = z;
        this.iterableDiffers = iterableDiffers;
        this.refMap = new WeakMap();
        this.el = (/** @type {?} */ (elementRef.nativeElement));
        this.el.nodeRender = this.nodeRender.bind(this);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    IonVirtualScroll.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this.trackBy && 'items' in changes) {
            // React on virtualScroll changes only once all inputs have been initialized
            /** @type {?} */
            var value = changes['items'].currentValue;
            if (this.differ === undefined && value != null) {
                try {
                    this.differ = this.iterableDiffers.find(value).create(this.trackBy);
                }
                catch (e) {
                    throw new Error("Cannot find a differ supporting object '" + value + "'. VirtualScroll only supports binding to Iterables such as Arrays.");
                }
            }
        }
    };
    /**
     * @return {?}
     */
    IonVirtualScroll.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        // and if there actually are changes
        /** @type {?} */
        var changes = this.differ !== undefined && this.items ? this.differ.diff(this.items) : null;
        if (changes === null) {
            return;
        }
        // TODO: optimize
        this.checkRange(0);
    };
    /**
     * @private
     * @param {?} el
     * @param {?} cell
     * @param {?} index
     * @return {?}
     */
    IonVirtualScroll.prototype.nodeRender = /**
     * @private
     * @param {?} el
     * @param {?} cell
     * @param {?} index
     * @return {?}
     */
    function (el, cell, index) {
        var _this = this;
        return this.z.run((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var node;
            if (!el) {
                node = _this.itmTmp.viewContainer.createEmbeddedView(_this.getComponent(cell.type), { $implicit: cell.value, index: index }, index);
                el = getElement(node);
                _this.refMap.set(el, node);
            }
            else {
                node = (/** @type {?} */ (_this.refMap.get(el)));
                /** @type {?} */
                var ctx = node.context;
                ctx.$implicit = cell.value;
                ctx.index = cell.index;
            }
            // run sync change detections
            node.detectChanges();
            return el;
        }));
    };
    /**
     * @private
     * @param {?} type
     * @return {?}
     */
    IonVirtualScroll.prototype.getComponent = /**
     * @private
     * @param {?} type
     * @return {?}
     */
    function (type) {
        switch (type) {
            case 'item': return this.itmTmp.templateRef;
            case 'header': return this.hdrTmp.templateRef;
            case 'footer': return this.ftrTmp.templateRef;
        }
        throw new Error('template for virtual item was not provided');
    };
    /** @nocollapse */
    IonVirtualScroll.ctorParameters = function () { return [
        { type: NgZone },
        { type: IterableDiffers },
        { type: ElementRef }
    ]; };
    IonVirtualScroll.propDecorators = {
        itmTmp: [{ type: ContentChild, args: [VirtualItem,] }],
        hdrTmp: [{ type: ContentChild, args: [VirtualHeader,] }],
        ftrTmp: [{ type: ContentChild, args: [VirtualFooter,] }]
    };
IonVirtualScroll.ɵfac = function IonVirtualScroll_Factory(t) { return new (t || IonVirtualScroll)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IonVirtualScroll.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IonVirtualScroll, selectors: [["ion-virtual-scroll"]], contentQueries: function IonVirtualScroll_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, VirtualItem, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, VirtualHeader, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, VirtualFooter, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itmTmp = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hdrTmp = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ftrTmp = _t.first);
    } }, inputs: { approxItemHeight: "approxItemHeight", approxHeaderHeight: "approxHeaderHeight", approxFooterHeight: "approxFooterHeight", headerFn: "headerFn", footerFn: "footerFn", items: "items", itemHeight: "itemHeight", headerHeight: "headerHeight", footerHeight: "footerHeight", trackBy: "trackBy" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function IonVirtualScroll_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonVirtualScroll, [{
        type: Component,
        args: [{
                selector: 'ion-virtual-scroll',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                inputs: [
                    'approxItemHeight',
                    'approxHeaderHeight',
                    'approxFooterHeight',
                    'headerFn',
                    'footerFn',
                    'items',
                    'itemHeight',
                    'headerHeight',
                    'footerHeight',
                    'trackBy'
                ]
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ElementRef }]; }, { itmTmp: [{
            type: ContentChild,
            args: [VirtualItem]
        }], hdrTmp: [{
            type: ContentChild,
            args: [VirtualHeader]
        }], ftrTmp: [{
            type: ContentChild,
            args: [VirtualFooter]
        }] }); })();
    return IonVirtualScroll;
}());
/** @type {?} */
var getElement = (/**
 * @param {?} view
 * @return {?}
 */
function (view) {
    /** @type {?} */
    var rootNodes = view.rootNodes;
    for (var i = 0; i < rootNodes.length; i++) {
        if (rootNodes[i].nodeType === 1) {
            return rootNodes[i];
        }
    }
    throw new Error('virtual element was not created');
});
proxyInputs(IonVirtualScroll, [
    'approxItemHeight',
    'approxHeaderHeight',
    'approxFooterHeight',
    'headerFn',
    'footerFn',
    'items',
    'itemHeight',
    'headerHeight',
    'footerHeight'
]);
proxyMethods(IonVirtualScroll, [
    'checkEnd',
    'checkRange',
    'positionForItem'
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CssUtilsDeprecations = /** @class */ (function () {
    function CssUtilsDeprecations(ref) {
        /** @type {?} */
        var el = ((/** @type {?} */ (ref.nativeElement)));
        /** @type {?} */
        var attributes = Array.from(el.attributes)
            .map((/**
         * @param {?} a
         * @return {?}
         */
        function (a) { return a.name; }))
            .filter((/**
         * @param {?} n
         * @return {?}
         */
        function (n) { return DEPRECATED_ATTRIBUTES.includes(n); }));
        if (attributes.length > 0) {
            console.warn("[DEPRECATED][CSS] Ionic CSS attributes are deprecated.\nReplace:\n'<" + el.tagName.toLowerCase() + " " + attributes.map((/**
             * @param {?} n
             * @return {?}
             */
            function (n) { return "" + n; })).join(' ') + ">'\n\nWith:\n'<" + el.tagName.toLowerCase() + " class=\"" + attributes.map((/**
             * @param {?} n
             * @return {?}
             */
            function (n) { return "ion-" + n; })).join(' ') + "\">'\n      ");
        }
    }
    /** @nocollapse */
    CssUtilsDeprecations.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
CssUtilsDeprecations.ɵfac = function CssUtilsDeprecations_Factory(t) { return new (t || CssUtilsDeprecations)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
CssUtilsDeprecations.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CssUtilsDeprecations, selectors: [["", "align-self-start", ""], ["", "align-self-end", ""], ["", "align-self-center", ""], ["", "align-self-stretch", ""], ["", "align-self-baseline", ""], ["", "align-self-auto", ""], ["", "wrap-reverse", ""], ["", "justify-content-start", ""], ["", "justify-content-center", ""], ["", "justify-content-end", ""], ["", "justify-content-around", ""], ["", "justify-content-between", ""], ["", "justify-content-evenly", ""], ["", "align-items-start", ""], ["", "align-items-center", ""], ["", "align-items-end", ""], ["", "align-items-stretch", ""], ["", "align-items-baseline", ""], ["", "float-left", ""], ["", "float-right", ""], ["", "float-start", ""], ["", "float-end", ""], ["", "float-sm-left", ""], ["", "float-sm-right", ""], ["", "float-sm-start", ""], ["", "float-sm-end", ""], ["", "float-md-left", ""], ["", "float-md-right", ""], ["", "float-md-start", ""], ["", "float-md-end", ""], ["", "float-lg-left", ""], ["", "float-lg-right", ""], ["", "float-lg-start", ""], ["", "float-lg-end", ""], ["", "float-xl-left", ""], ["", "float-xl-right", ""], ["", "float-xl-start", ""], ["", "float-xl-end", ""], ["", "text-center", ""], ["", "text-justify", ""], ["", "text-start", ""], ["", "text-end", ""], ["", "text-left", ""], ["", "text-right", ""], ["", "text-nowrap", ""], ["", "text-wrap", ""], ["", "text-sm-center", ""], ["", "text-sm-justify", ""], ["", "text-sm-start", ""], ["", "text-sm-end", ""], ["", "text-sm-left", ""], ["", "text-sm-right", ""], ["", "text-sm-nowrap", ""], ["", "text-sm-wrap", ""], ["", "text-md-center", ""], ["", "text-md-justify", ""], ["", "text-md-start", ""], ["", "text-md-end", ""], ["", "text-md-left", ""], ["", "text-md-right", ""], ["", "text-md-nowrap", ""], ["", "text-md-wrap", ""], ["", "text-lg-center", ""], ["", "text-lg-justify", ""], ["", "text-lg-start", ""], ["", "text-lg-end", ""], ["", "text-lg-left", ""], ["", "text-lg-right", ""], ["", "text-lg-nowrap", ""], ["", "text-lg-wrap", ""], ["", "text-xl-center", ""], ["", "text-xl-justify", ""], ["", "text-xl-start", ""], ["", "text-xl-end", ""], ["", "text-xl-left", ""], ["", "text-xl-right", ""], ["", "text-xl-nowrap", ""], ["", "text-xl-wrap", ""], ["", "text-uppercase", ""], ["", "text-lowercase", ""], ["", "text-capitalize", ""], ["", "text-sm-uppercase", ""], ["", "text-sm-lowercase", ""], ["", "text-sm-capitalize", ""], ["", "text-md-uppercase", ""], ["", "text-md-lowercase", ""], ["", "text-md-capitalize", ""], ["", "text-lg-uppercase", ""], ["", "text-lg-lowercase", ""], ["", "text-lg-capitalize", ""], ["", "text-xl-uppercase", ""], ["", "text-xl-lowercase", ""], ["", "text-xl-capitalize", ""], ["", "no-padding", ""], ["", "padding", ""], ["", "padding-top", ""], ["", "padding-bottom", ""], ["", "padding-start", ""], ["", "padding-end", ""], ["", "padding-vertical", ""], ["", "padding-horizontal", ""], ["", "no-margin", ""], ["", "margin", ""], ["", "margin-top", ""], ["", "margin-bottom", ""], ["", "margin-start", ""], ["", "margin-end", ""], ["", "margin-vertical", ""], ["", "margin-horizontal", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CssUtilsDeprecations, [{
        type: Directive,
        args: [{
                selector: '[align-self-start], [align-self-end], [align-self-center], [align-self-stretch], [align-self-baseline], [align-self-auto], [wrap-reverse], [justify-content-start], [justify-content-center], [justify-content-end], [justify-content-around], [justify-content-between], [justify-content-evenly], [align-items-start], [align-items-center], [align-items-end], [align-items-stretch], [align-items-baseline], [float-left], [float-right], [float-start], [float-end], [float-sm-left], [float-sm-right], [float-sm-start], [float-sm-end], [float-md-left], [float-md-right], [float-md-start], [float-md-end], [float-lg-left], [float-lg-right], [float-lg-start], [float-lg-end], [float-xl-left], [float-xl-right], [float-xl-start], [float-xl-end], [text-center], [text-justify], [text-start], [text-end], [text-left], [text-right], [text-nowrap], [text-wrap], [text-sm-center], [text-sm-justify], [text-sm-start], [text-sm-end], [text-sm-left], [text-sm-right], [text-sm-nowrap], [text-sm-wrap], [text-md-center], [text-md-justify], [text-md-start], [text-md-end], [text-md-left], [text-md-right], [text-md-nowrap], [text-md-wrap], [text-lg-center], [text-lg-justify], [text-lg-start], [text-lg-end], [text-lg-left], [text-lg-right], [text-lg-nowrap], [text-lg-wrap], [text-xl-center], [text-xl-justify], [text-xl-start], [text-xl-end], [text-xl-left], [text-xl-right], [text-xl-nowrap], [text-xl-wrap], [text-uppercase], [text-lowercase], [text-capitalize], [text-sm-uppercase], [text-sm-lowercase], [text-sm-capitalize], [text-md-uppercase], [text-md-lowercase], [text-md-capitalize], [text-lg-uppercase], [text-lg-lowercase], [text-lg-capitalize], [text-xl-uppercase], [text-xl-lowercase], [text-xl-capitalize], [no-padding], [padding], [padding-top], [padding-bottom], [padding-start], [padding-end], [padding-vertical], [padding-horizontal], [no-margin], [margin], [margin-top], [margin-bottom], [margin-start], [margin-end], [margin-vertical], [margin-horizontal]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();
    return CssUtilsDeprecations;
}());
/** @type {?} */
var DEPRECATED_ATTRIBUTES = [
    'align-self-start',
    'align-self-end',
    'align-self-center',
    'align-self-stretch',
    'align-self-baseline',
    'align-self-auto',
    'wrap-reverse',
    'justify-content-start',
    'justify-content-center',
    'justify-content-end',
    'justify-content-around',
    'justify-content-between',
    'justify-content-evenly',
    'align-items-start',
    'align-items-center',
    'align-items-end',
    'align-items-stretch',
    'align-items-baseline',
    'float-left',
    'float-right',
    'float-start',
    'float-end',
    'float-sm-left',
    'float-sm-right',
    'float-sm-start',
    'float-sm-end',
    'float-md-left',
    'float-md-right',
    'float-md-start',
    'float-md-end',
    'float-lg-left',
    'float-lg-right',
    'float-lg-start',
    'float-lg-end',
    'float-xl-left',
    'float-xl-right',
    'float-xl-start',
    'float-xl-end',
    'text-center',
    'text-justify',
    'text-start',
    'text-end',
    'text-left',
    'text-right',
    'text-nowrap',
    'text-wrap',
    'text-sm-center',
    'text-sm-justify',
    'text-sm-start',
    'text-sm-end',
    'text-sm-left',
    'text-sm-right',
    'text-sm-nowrap',
    'text-sm-wrap',
    'text-md-center',
    'text-md-justify',
    'text-md-start',
    'text-md-end',
    'text-md-left',
    'text-md-right',
    'text-md-nowrap',
    'text-md-wrap',
    'text-lg-center',
    'text-lg-justify',
    'text-lg-start',
    'text-lg-end',
    'text-lg-left',
    'text-lg-right',
    'text-lg-nowrap',
    'text-lg-wrap',
    'text-xl-center',
    'text-xl-justify',
    'text-xl-start',
    'text-xl-end',
    'text-xl-left',
    'text-xl-right',
    'text-xl-nowrap',
    'text-xl-wrap',
    'text-uppercase',
    'text-lowercase',
    'text-capitalize',
    'text-sm-uppercase',
    'text-sm-lowercase',
    'text-sm-capitalize',
    'text-md-uppercase',
    'text-md-lowercase',
    'text-md-capitalize',
    'text-lg-uppercase',
    'text-lg-lowercase',
    'text-lg-capitalize',
    'text-xl-uppercase',
    'text-xl-lowercase',
    'text-xl-capitalize',
    'no-padding',
    'padding',
    'padding-top',
    'padding-bottom',
    'padding-start',
    'padding-end',
    'padding-vertical',
    'padding-horizontal',
    'no-margin',
    'margin',
    'margin-top',
    'margin-bottom',
    'margin-start',
    'margin-end',
    'margin-vertical',
    'margin-horizontal'
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Opts, Overlay
 */
var  /**
 * @template Opts, Overlay
 */
OverlayBaseController = /** @class */ (function () {
    function OverlayBaseController(ctrl) {
        this.ctrl = ctrl;
    }
    /**
     * Creates a new overlay
     */
    /**
     * Creates a new overlay
     * @param {?=} opts
     * @return {?}
     */
    OverlayBaseController.prototype.create = /**
     * Creates a new overlay
     * @param {?=} opts
     * @return {?}
     */
    function (opts) {
        // TODO: next major release opts is not optional
        return this.ctrl.create((/** @type {?} */ ((opts || {}))));
    };
    /**
     * When `id` is not provided, it dismisses the top overlay.
     */
    /**
     * When `id` is not provided, it dismisses the top overlay.
     * @param {?=} data
     * @param {?=} role
     * @param {?=} id
     * @return {?}
     */
    OverlayBaseController.prototype.dismiss = /**
     * When `id` is not provided, it dismisses the top overlay.
     * @param {?=} data
     * @param {?=} role
     * @param {?=} id
     * @return {?}
     */
    function (data, role, id) {
        return this.ctrl.dismiss(data, role, id);
    };
    /**
     * Returns the top overlay.
     */
    /**
     * Returns the top overlay.
     * @return {?}
     */
    OverlayBaseController.prototype.getTop = /**
     * Returns the top overlay.
     * @return {?}
     */
    function () {
        return this.ctrl.getTop();
    };
    return OverlayBaseController;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ActionSheetController = /** @class */ (function (_super) {
    __extends(ActionSheetController, _super);
    function ActionSheetController() {
        return _super.call(this, actionSheetController) || this;
    }
    /** @nocollapse */
    ActionSheetController.ctorParameters = function () { return []; };
    /** @nocollapse */ ActionSheetController.ngInjectableDef = defineInjectable({ factory: function ActionSheetController_Factory() { return new ActionSheetController(); }, token: ActionSheetController, providedIn: "root" });
ActionSheetController.ɵfac = function ActionSheetController_Factory(t) { return new (t || ActionSheetController)(); };
ActionSheetController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ActionSheetController, factory: function (t) { return ActionSheetController.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ActionSheetController, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return ActionSheetController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AlertController = /** @class */ (function (_super) {
    __extends(AlertController, _super);
    function AlertController() {
        return _super.call(this, alertController) || this;
    }
    /** @nocollapse */
    AlertController.ctorParameters = function () { return []; };
    /** @nocollapse */ AlertController.ngInjectableDef = defineInjectable({ factory: function AlertController_Factory() { return new AlertController(); }, token: AlertController, providedIn: "root" });
AlertController.ɵfac = function AlertController_Factory(t) { return new (t || AlertController)(); };
AlertController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AlertController, factory: function (t) { return AlertController.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AlertController, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return AlertController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Events = /** @class */ (function () {
    function Events() {
        this.c = new Map();
        console.warn("[DEPRECATION][Events]: The Events provider is deprecated and it will be removed in the next major release.\n  - Use \"Observables\" for a similar pub/sub architecture: https://angular.io/guide/observables\n  - Use \"Redux\" for advanced state management: https://ngrx.io");
    }
    /**
     * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.
     *
     * @param topic the topic to subscribe to
     * @param handler the event handler
     */
    /**
     * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.
     *
     * @param {?} topic the topic to subscribe to
     * @param {...?} handlers
     * @return {?}
     */
    Events.prototype.subscribe = /**
     * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.
     *
     * @param {?} topic the topic to subscribe to
     * @param {...?} handlers
     * @return {?}
     */
    function (topic) {
        var handlers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            handlers[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var topics = this.c.get(topic);
        if (!topics) {
            this.c.set(topic, topics = []);
        }
        topics.push.apply(topics, handlers);
    };
    /**
     * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.
     *
     * @param topic the topic to unsubscribe from
     * @param handler the event handler
     *
     * @return true if a handler was removed
     */
    /**
     * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.
     *
     * @param {?} topic the topic to unsubscribe from
     * @param {?=} handler the event handler
     *
     * @return {?} true if a handler was removed
     */
    Events.prototype.unsubscribe = /**
     * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.
     *
     * @param {?} topic the topic to unsubscribe from
     * @param {?=} handler the event handler
     *
     * @return {?} true if a handler was removed
     */
    function (topic, handler) {
        if (!handler) {
            return this.c.delete(topic);
        }
        /** @type {?} */
        var topics = this.c.get(topic);
        if (!topics) {
            return false;
        }
        // We need to find and remove a specific handler
        /** @type {?} */
        var index = topics.indexOf(handler);
        if (index < 0) {
            // Wasn't found, wasn't removed
            return false;
        }
        topics.splice(index, 1);
        if (topics.length === 0) {
            this.c.delete(topic);
        }
        return true;
    };
    /**
     * Publish an event to the given topic.
     *
     * @param topic the topic to publish to
     * @param eventData the data to send as the event
     */
    /**
     * Publish an event to the given topic.
     *
     * @param {?} topic the topic to publish to
     * @param {...?} args
     * @return {?}
     */
    Events.prototype.publish = /**
     * Publish an event to the given topic.
     *
     * @param {?} topic the topic to publish to
     * @param {...?} args
     * @return {?}
     */
    function (topic) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var topics = this.c.get(topic);
        if (!topics) {
            return null;
        }
        return topics.map((/**
         * @param {?} handler
         * @return {?}
         */
        function (handler) {
            try {
                return handler.apply(void 0, args);
            }
            catch (e) {
                console.error(e);
                return null;
            }
        }));
    };
    /** @nocollapse */
    Events.ctorParameters = function () { return []; };
    /** @nocollapse */ Events.ngInjectableDef = defineInjectable({ factory: function Events_Factory() { return new Events(); }, token: Events, providedIn: "root" });
Events.ɵfac = function Events_Factory(t) { return new (t || Events)(); };
Events.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Events, factory: function (t) { return Events.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Events, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return Events;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LoadingController = /** @class */ (function (_super) {
    __extends(LoadingController, _super);
    function LoadingController() {
        return _super.call(this, loadingController) || this;
    }
    /** @nocollapse */
    LoadingController.ctorParameters = function () { return []; };
    /** @nocollapse */ LoadingController.ngInjectableDef = defineInjectable({ factory: function LoadingController_Factory() { return new LoadingController(); }, token: LoadingController, providedIn: "root" });
LoadingController.ɵfac = function LoadingController_Factory(t) { return new (t || LoadingController)(); };
LoadingController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: LoadingController, factory: function (t) { return LoadingController.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoadingController, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return LoadingController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MenuController = /** @class */ (function () {
    function MenuController() {
    }
    /**
     * Programmatically open the Menu.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return returns a promise when the menu is fully opened
     */
    /**
     * Programmatically open the Menu.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu is fully opened
     */
    MenuController.prototype.open = /**
     * Programmatically open the Menu.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu is fully opened
     */
    function (menuId) {
        return menuController.open(menuId);
    };
    /**
     * Programmatically close the Menu. If no `menuId` is given as the first
     * argument then it'll close any menu which is open. If a `menuId`
     * is given then it'll close that exact menu.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return returns a promise when the menu is fully closed
     */
    /**
     * Programmatically close the Menu. If no `menuId` is given as the first
     * argument then it'll close any menu which is open. If a `menuId`
     * is given then it'll close that exact menu.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu is fully closed
     */
    MenuController.prototype.close = /**
     * Programmatically close the Menu. If no `menuId` is given as the first
     * argument then it'll close any menu which is open. If a `menuId`
     * is given then it'll close that exact menu.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu is fully closed
     */
    function (menuId) {
        return menuController.close(menuId);
    };
    /**
     * Toggle the menu. If it's closed, it will open, and if opened, it
     * will close.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return returns a promise when the menu has been toggled
     */
    /**
     * Toggle the menu. If it's closed, it will open, and if opened, it
     * will close.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu has been toggled
     */
    MenuController.prototype.toggle = /**
     * Toggle the menu. If it's closed, it will open, and if opened, it
     * will close.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu has been toggled
     */
    function (menuId) {
        return menuController.toggle(menuId);
    };
    /**
     * Used to enable or disable a menu. For example, there could be multiple
     * left menus, but only one of them should be able to be opened at the same
     * time. If there are multiple menus on the same side, then enabling one menu
     * will also automatically disable all the others that are on the same side.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns the instance of the menu, which is useful for chaining.
     */
    /**
     * Used to enable or disable a menu. For example, there could be multiple
     * left menus, but only one of them should be able to be opened at the same
     * time. If there are multiple menus on the same side, then enabling one menu
     * will also automatically disable all the others that are on the same side.
     * @param {?} shouldEnable
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu, which is useful for chaining.
     */
    MenuController.prototype.enable = /**
     * Used to enable or disable a menu. For example, there could be multiple
     * left menus, but only one of them should be able to be opened at the same
     * time. If there are multiple menus on the same side, then enabling one menu
     * will also automatically disable all the others that are on the same side.
     * @param {?} shouldEnable
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu, which is useful for chaining.
     */
    function (shouldEnable, menuId) {
        return menuController.enable(shouldEnable, menuId);
    };
    /**
     * Used to enable or disable the ability to swipe open the menu.
     * @param shouldEnable  True if it should be swipe-able, false if not.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns the instance of the menu, which is useful for chaining.
     * @deprecated Use swipeGesture() instead.
     */
    /**
     * Used to enable or disable the ability to swipe open the menu.
     * @deprecated Use swipeGesture() instead.
     * @param {?} shouldEnable  True if it should be swipe-able, false if not.
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu, which is useful for chaining.
     */
    MenuController.prototype.swipeEnable = /**
     * Used to enable or disable the ability to swipe open the menu.
     * @deprecated Use swipeGesture() instead.
     * @param {?} shouldEnable  True if it should be swipe-able, false if not.
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu, which is useful for chaining.
     */
    function (shouldEnable, menuId) {
        console.warn('[DEPRECATED][ion-menu-controller] swipeEnable() is deprecated. Use MenuController.swipeGesture() instead');
        return this.swipeGesture(shouldEnable, menuId);
    };
    /**
     * Used to enable or disable the ability to swipe open the menu.
     * @param shouldEnable  True if it should be swipe-able, false if not.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns the instance of the menu, which is useful for chaining.
     */
    /**
     * Used to enable or disable the ability to swipe open the menu.
     * @param {?} shouldEnable  True if it should be swipe-able, false if not.
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu, which is useful for chaining.
     */
    MenuController.prototype.swipeGesture = /**
     * Used to enable or disable the ability to swipe open the menu.
     * @param {?} shouldEnable  True if it should be swipe-able, false if not.
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu, which is useful for chaining.
     */
    function (shouldEnable, menuId) {
        return menuController.swipeGesture(shouldEnable, menuId);
    };
    /**
     * @param [menuId] Optionally get the menu by its id, or side.
     * @return Returns true if the specified menu is currently open, otherwise false.
     * If the menuId is not specified, it returns true if ANY menu is currenly open.
     */
    /**
     * @param {?=} menuId
     * @return {?} Returns true if the specified menu is currently open, otherwise false.
     * If the menuId is not specified, it returns true if ANY menu is currenly open.
     */
    MenuController.prototype.isOpen = /**
     * @param {?=} menuId
     * @return {?} Returns true if the specified menu is currently open, otherwise false.
     * If the menuId is not specified, it returns true if ANY menu is currenly open.
     */
    function (menuId) {
        return menuController.isOpen(menuId);
    };
    /**
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns true if the menu is currently enabled, otherwise false.
     */
    /**
     * @param {?=} menuId
     * @return {?} Returns true if the menu is currently enabled, otherwise false.
     */
    MenuController.prototype.isEnabled = /**
     * @param {?=} menuId
     * @return {?} Returns true if the menu is currently enabled, otherwise false.
     */
    function (menuId) {
        return menuController.isEnabled(menuId);
    };
    /**
     * Used to get a menu instance. If a `menuId` is not provided then it'll
     * return the first menu found. If a `menuId` is `left` or `right`, then
     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is
     * provided, then it'll try to find the menu using the menu's `id`
     * property. If a menu is not found then it'll return `null`.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns the instance of the menu if found, otherwise `null`.
     */
    /**
     * Used to get a menu instance. If a `menuId` is not provided then it'll
     * return the first menu found. If a `menuId` is `left` or `right`, then
     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is
     * provided, then it'll try to find the menu using the menu's `id`
     * property. If a menu is not found then it'll return `null`.
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu if found, otherwise `null`.
     */
    MenuController.prototype.get = /**
     * Used to get a menu instance. If a `menuId` is not provided then it'll
     * return the first menu found. If a `menuId` is `left` or `right`, then
     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is
     * provided, then it'll try to find the menu using the menu's `id`
     * property. If a menu is not found then it'll return `null`.
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu if found, otherwise `null`.
     */
    function (menuId) {
        return menuController.get(menuId);
    };
    /**
     * @return Returns the instance of the menu already opened, otherwise `null`.
     */
    /**
     * @return {?} Returns the instance of the menu already opened, otherwise `null`.
     */
    MenuController.prototype.getOpen = /**
     * @return {?} Returns the instance of the menu already opened, otherwise `null`.
     */
    function () {
        return menuController.getOpen();
    };
    /**
     * @return Returns an array of all menu instances.
     */
    /**
     * @return {?} Returns an array of all menu instances.
     */
    MenuController.prototype.getMenus = /**
     * @return {?} Returns an array of all menu instances.
     */
    function () {
        return menuController.getMenus();
    };
    /** @nocollapse */ MenuController.ngInjectableDef = defineInjectable({ factory: function MenuController_Factory() { return new MenuController(); }, token: MenuController, providedIn: "root" });
MenuController.ɵfac = function MenuController_Factory(t) { return new (t || MenuController)(); };
MenuController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MenuController, factory: function (t) { return MenuController.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MenuController, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return MenuController;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PickerController = /** @class */ (function (_super) {
    __extends(PickerController, _super);
    function PickerController() {
        return _super.call(this, pickerController) || this;
    }
    /** @nocollapse */
    PickerController.ctorParameters = function () { return []; };
    /** @nocollapse */ PickerController.ngInjectableDef = defineInjectable({ factory: function PickerController_Factory() { return new PickerController(); }, token: PickerController, providedIn: "root" });
PickerController.ɵfac = function PickerController_Factory(t) { return new (t || PickerController)(); };
PickerController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PickerController, factory: function (t) { return PickerController.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PickerController, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return PickerController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalController = /** @class */ (function (_super) {
    __extends(ModalController, _super);
    function ModalController(angularDelegate, resolver, injector) {
        var _this = _super.call(this, modalController) || this;
        _this.angularDelegate = angularDelegate;
        _this.resolver = resolver;
        _this.injector = injector;
        return _this;
    }
    /**
     * @param {?} opts
     * @return {?}
     */
    ModalController.prototype.create = /**
     * @param {?} opts
     * @return {?}
     */
    function (opts) {
        return _super.prototype.create.call(this, __assign({}, opts, { delegate: this.angularDelegate.create(this.resolver, this.injector) }));
    };
    /** @nocollapse */
    ModalController.ctorParameters = function () { return [
        { type: AngularDelegate },
        { type: ComponentFactoryResolver },
        { type: Injector }
    ]; };
ModalController.ɵfac = function ModalController_Factory(t) { return new (t || ModalController)(ɵngcc0.ɵɵinject(AngularDelegate), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
ModalController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ModalController, factory: function (t) { return ModalController.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ModalController, [{
        type: Injectable
    }], function () { return [{ type: AngularDelegate }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Injector }]; }, null); })();
    return ModalController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PopoverController = /** @class */ (function (_super) {
    __extends(PopoverController, _super);
    function PopoverController(angularDelegate, resolver, injector) {
        var _this = _super.call(this, popoverController) || this;
        _this.angularDelegate = angularDelegate;
        _this.resolver = resolver;
        _this.injector = injector;
        return _this;
    }
    /**
     * @param {?} opts
     * @return {?}
     */
    PopoverController.prototype.create = /**
     * @param {?} opts
     * @return {?}
     */
    function (opts) {
        return _super.prototype.create.call(this, __assign({}, opts, { delegate: this.angularDelegate.create(this.resolver, this.injector) }));
    };
    /** @nocollapse */
    PopoverController.ctorParameters = function () { return [
        { type: AngularDelegate },
        { type: ComponentFactoryResolver },
        { type: Injector }
    ]; };
PopoverController.ɵfac = function PopoverController_Factory(t) { return new (t || PopoverController)(ɵngcc0.ɵɵinject(AngularDelegate), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
PopoverController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PopoverController, factory: function (t) { return PopoverController.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PopoverController, [{
        type: Injectable
    }], function () { return [{ type: AngularDelegate }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Injector }]; }, null); })();
    return PopoverController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ToastController = /** @class */ (function (_super) {
    __extends(ToastController, _super);
    function ToastController() {
        return _super.call(this, toastController) || this;
    }
    /** @nocollapse */
    ToastController.ctorParameters = function () { return []; };
    /** @nocollapse */ ToastController.ngInjectableDef = defineInjectable({ factory: function ToastController_Factory() { return new ToastController(); }, token: ToastController, providedIn: "root" });
ToastController.ɵfac = function ToastController_Factory(t) { return new (t || ToastController)(); };
ToastController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ToastController, factory: function (t) { return ToastController.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ToastController, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return ToastController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DomController = /** @class */ (function () {
    function DomController() {
    }
    /**
     * Schedules a task to run during the READ phase of the next frame.
     * This task should only read the DOM, but never modify it.
     */
    /**
     * Schedules a task to run during the READ phase of the next frame.
     * This task should only read the DOM, but never modify it.
     * @param {?} cb
     * @return {?}
     */
    DomController.prototype.read = /**
     * Schedules a task to run during the READ phase of the next frame.
     * This task should only read the DOM, but never modify it.
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        getQueue().read(cb);
    };
    /**
     * Schedules a task to run during the WRITE phase of the next frame.
     * This task should write the DOM, but never READ it.
     */
    /**
     * Schedules a task to run during the WRITE phase of the next frame.
     * This task should write the DOM, but never READ it.
     * @param {?} cb
     * @return {?}
     */
    DomController.prototype.write = /**
     * Schedules a task to run during the WRITE phase of the next frame.
     * This task should write the DOM, but never READ it.
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        getQueue().write(cb);
    };
    /** @nocollapse */ DomController.ngInjectableDef = defineInjectable({ factory: function DomController_Factory() { return new DomController(); }, token: DomController, providedIn: "root" });
DomController.ɵfac = function DomController_Factory(t) { return new (t || DomController)(); };
DomController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DomController, factory: function (t) { return DomController.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DomController, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return DomController;
}());
/** @type {?} */
var getQueue = (/**
 * @return {?}
 */
function () {
    /** @type {?} */
    var win = typeof ((/** @type {?} */ (window))) !== 'undefined' ? window : (/** @type {?} */ (null));
    if (win != null) {
        /** @type {?} */
        var Ionic = win.Ionic;
        if (Ionic && Ionic.queue) {
            return Ionic.queue;
        }
        return {
            read: (/**
             * @param {?} cb
             * @return {?}
             */
            function (cb) { return win.requestAnimationFrame(cb); }),
            write: (/**
             * @param {?} cb
             * @return {?}
             */
            function (cb) { return win.requestAnimationFrame(cb); })
        };
    }
    return {
        read: (/**
         * @param {?} cb
         * @return {?}
         */
        function (cb) { return cb(); }),
        write: (/**
         * @param {?} cb
         * @return {?}
         */
        function (cb) { return cb(); })
    };
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonicRouteStrategy = /** @class */ (function () {
    function IonicRouteStrategy() {
    }
    /**
     * @param {?} _route
     * @return {?}
     */
    IonicRouteStrategy.prototype.shouldDetach = /**
     * @param {?} _route
     * @return {?}
     */
    function (_route) {
        return false;
    };
    /**
     * @param {?} _route
     * @return {?}
     */
    IonicRouteStrategy.prototype.shouldAttach = /**
     * @param {?} _route
     * @return {?}
     */
    function (_route) {
        return false;
    };
    /**
     * @param {?} _route
     * @param {?} _detachedTree
     * @return {?}
     */
    IonicRouteStrategy.prototype.store = /**
     * @param {?} _route
     * @param {?} _detachedTree
     * @return {?}
     */
    function (_route, _detachedTree) {
        return;
    };
    /**
     * @param {?} _route
     * @return {?}
     */
    IonicRouteStrategy.prototype.retrieve = /**
     * @param {?} _route
     * @return {?}
     */
    function (_route) {
        return null;
    };
    /**
     * @param {?} future
     * @param {?} curr
     * @return {?}
     */
    IonicRouteStrategy.prototype.shouldReuseRoute = /**
     * @param {?} future
     * @param {?} curr
     * @return {?}
     */
    function (future, curr) {
        if (future.routeConfig !== curr.routeConfig) {
            return false;
        }
        // checking router params
        /** @type {?} */
        var futureParams = future.params;
        /** @type {?} */
        var currentParams = curr.params;
        /** @type {?} */
        var keysA = Object.keys(futureParams);
        /** @type {?} */
        var keysB = Object.keys(currentParams);
        if (keysA.length !== keysB.length) {
            return false;
        }
        // Test for A's keys different from B.
        for (var _i = 0, keysA_1 = keysA; _i < keysA_1.length; _i++) {
            var key = keysA_1[_i];
            if (currentParams[key] !== futureParams[key]) {
                return false;
            }
        }
        return true;
    };
    return IonicRouteStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var didInitialize = false;
/** @type {?} */
var appInitialize = (/**
 * @param {?} config
 * @param {?} doc
 * @param {?} zone
 * @return {?}
 */
function (config, doc, zone) {
    return (/**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var win = (/** @type {?} */ (doc.defaultView));
        if (win) {
            if (didInitialize) {
                console.warn('Ionic Angular was already initialized. Make sure IonicModule.forRoot() is just called once.');
            }
            didInitialize = true;
            /** @type {?} */
            var Ionic = win.Ionic = win.Ionic || {};
            Ionic.config = __assign({}, config, { _zoneGate: (/**
                 * @param {?} h
                 * @return {?}
                 */
                function (h) { return zone.run(h); }) });
            /** @type {?} */
            var aelFn_1 = '__zone_symbol__addEventListener' in ((/** @type {?} */ (doc.body)))
                ? '__zone_symbol__addEventListener'
                : 'addEventListener';
            return applyPolyfills().then((/**
             * @return {?}
             */
            function () {
                return defineCustomElements(win, {
                    exclude: ['ion-tabs', 'ion-tab'],
                    syncQueue: true,
                    raf: raf,
                    jmp: (/**
                     * @param {?} h
                     * @return {?}
                     */
                    function (h) { return zone.runOutsideAngular(h); }),
                    ael: /**
                     * @param {?} elm
                     * @param {?} eventName
                     * @param {?} cb
                     * @param {?} opts
                     * @return {?}
                     */
                    function (elm, eventName, cb, opts) {
                        ((/** @type {?} */ (elm)))[aelFn_1](eventName, cb, opts);
                    },
                    rel: /**
                     * @param {?} elm
                     * @param {?} eventName
                     * @param {?} cb
                     * @param {?} opts
                     * @return {?}
                     */
                    function (elm, eventName, cb, opts) {
                        elm.removeEventListener(eventName, cb, opts);
                    }
                });
            }));
        }
    });
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DECLARATIONS = [
    // proxies
    IonApp,
    IonAvatar,
    IonBackButton,
    IonBackdrop,
    IonBadge,
    IonButton,
    IonButtons,
    IonCard,
    IonCardContent,
    IonCardHeader,
    IonCardSubtitle,
    IonCardTitle,
    IonCheckbox,
    IonChip,
    IonCol,
    IonContent,
    IonDatetime,
    IonFab,
    IonFabButton,
    IonFabList,
    IonFooter,
    IonGrid,
    IonHeader,
    IonIcon,
    IonImg,
    IonInfiniteScroll,
    IonInfiniteScrollContent,
    IonInput,
    IonItem,
    IonItemDivider,
    IonItemGroup,
    IonItemOption,
    IonItemOptions,
    IonItemSliding,
    IonLabel,
    IonList,
    IonListHeader,
    IonMenu,
    IonMenuButton,
    IonMenuToggle,
    IonNav,
    IonNavLink,
    IonNavPop,
    IonNavPush,
    IonNavSetRoot,
    IonNote,
    IonProgressBar,
    IonRadio,
    IonRadioGroup,
    IonRange,
    IonRefresher,
    IonRefresherContent,
    IonReorder,
    IonReorderGroup,
    IonRippleEffect,
    IonRow,
    IonSearchbar,
    IonSegment,
    IonSegmentButton,
    IonSelect,
    IonSelectOption,
    IonSkeletonText,
    IonSlide,
    IonSlides,
    IonSpinner,
    IonSplitPane,
    IonTabBar,
    IonTabButton,
    IonText,
    IonTextarea,
    IonThumbnail,
    IonToggle,
    IonToolbar,
    IonTitle,
    IonTabs,
    // ngModel accessors
    BooleanValueAccessor,
    NumericValueAccessor,
    RadioValueAccessor,
    SelectValueAccessor,
    TextValueAccessor,
    // navigation
    IonRouterOutlet,
    IonBackButtonDelegate,
    NavDelegate,
    RouterLinkDelegate,
    // virtual scroll
    VirtualFooter,
    VirtualHeader,
    VirtualItem,
    IonVirtualScroll,
    // Deprecations
    CssUtilsDeprecations
];
var IonicModule = /** @class */ (function () {
    function IonicModule() {
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    IonicModule.forRoot = /**
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: IonicModule,
            providers: [
                {
                    provide: ConfigToken,
                    useValue: config
                },
                {
                    provide: APP_INITIALIZER,
                    useFactory: appInitialize,
                    multi: true,
                    deps: [
                        ConfigToken,
                        DOCUMENT,
                        NgZone
                    ]
                }
            ]
        };
    };
IonicModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IonicModule });
IonicModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IonicModule_Factory(t) { return new (t || IonicModule)(); }, providers: [AngularDelegate, ModalController, PopoverController], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IonicModule, { declarations: function () { return [IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNavPop, IonNavPush, IonNavSetRoot, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonText, IonTextarea, IonThumbnail, IonToggle, IonToolbar, IonTitle, IonTabs, BooleanValueAccessor, NumericValueAccessor, RadioValueAccessor, SelectValueAccessor, TextValueAccessor, IonRouterOutlet, IonBackButtonDelegate, NavDelegate, RouterLinkDelegate, VirtualFooter, VirtualHeader, VirtualItem, IonVirtualScroll, CssUtilsDeprecations]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNavPop, IonNavPush, IonNavSetRoot, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonText, IonTextarea, IonThumbnail, IonToggle, IonToolbar, IonTitle, IonTabs, BooleanValueAccessor, NumericValueAccessor, RadioValueAccessor, SelectValueAccessor, TextValueAccessor, IonRouterOutlet, IonBackButtonDelegate, NavDelegate, RouterLinkDelegate, VirtualFooter, VirtualHeader, VirtualItem, IonVirtualScroll, CssUtilsDeprecations]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IonicModule, [{
        type: NgModule,
        args: [{
                declarations: DECLARATIONS,
                exports: DECLARATIONS,
                providers: [AngularDelegate, ModalController, PopoverController],
                imports: [CommonModule]
            }]
    }], function () { return []; }, null); })();
    return IonicModule;
}());

export { ActionSheetController, AlertController, AngularDelegate, BooleanValueAccessor, Config, CssUtilsDeprecations, DomController, Events, IonApp, IonAvatar, IonBackButton, IonBackButtonDelegate, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNavPop, IonNavPush, IonNavSetRoot, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToggle, IonToolbar, IonVirtualScroll, IonicModule, IonicRouteStrategy, LoadingController, MenuController, ModalController, NavController, NavDelegate, NavParams, NumericValueAccessor, PickerController, Platform, PopoverController, RadioValueAccessor, RouterLinkDelegate, SelectValueAccessor, TextValueAccessor, ToastController, VirtualFooter, VirtualHeader, VirtualItem, ConfigToken as ɵa, ValueAccessor as ɵb, OverlayBaseController as ɵd, appInitialize as ɵe };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmVzbTUuanMiLCJzb3VyY2VzIjpbImZlc201LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEdNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BZ0hBLEFBYUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUF3Q0EsQUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUF1QkEsQUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUF1QkEsQUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUF1QkEsQUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BZ2VBLEFBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7OzJEQU11TTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUF3YnZNLEFBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FRdVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBdUh4USxBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7O0tBUUosQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7OztLQVFKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7O0tBU0osQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7O0tBVUosQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7OztLQVNKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7O0tBU0osQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7OztLQVNKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7O0tBU0osQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7O0tBVUosQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7OztLQVNKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7Ozs7S0FXSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7O0tBV0osQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7OztLQVNKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7O0tBU0osQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7OztLQVNKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7O0tBU0osQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7O0tBUUosQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7O0tBVUosQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7O0tBVUosQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7O0tBVUosQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7OztLQVNKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7O0tBU0osQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7OztLQVFKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7O0tBU0osQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7OztLQVNKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7OztLQVVKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7O0tBU0osQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7OztLQVNKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7Ozs7S0FXSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7OztLQVNKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7O0tBU0osQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7OztLQVNKLEFBR0M7Ozs7Ozs7Ozs7Ozs7Ozt3SUFNRzs7Ozs7Ozs7O0tBU0osQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7S0FVSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7O0tBUUosQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7O0tBVUosQUFHQzs7Ozs7Ozs7Ozs7Ozs7O3dJQU1HOzs7Ozs7Ozs7S0FTSixBQUdDOzs7Ozs7Ozs7Ozs7Ozs7d0lBTUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BbUZILEFBS0E7Ozs7Ozs7OztnREFDK0o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFvSi9KLEFBR0E7Ozs7Ozs7Ozs7d0dBS0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BMHlDSCxBQU9BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFnR0EsQUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBV0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BbUNBLEFBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFRQTs7Ozs7Ozs7Ozs7S0FXRCxBQUtDOzs7Ozs7Ozs7Ozs7Ozs7OytNQVFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQTZFSCxBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBV0E7Ozs7Ozs7Ozs7Ozs7O0tBY0QsQUFHQzs7Ozs7Ozs7Ozs0RUFJRzs7Ozs7Ozs7Ozs7Ozs7S0FjSixBQUdDOzs7Ozs7Ozs7OzRFQUlHOzs7Ozs7Ozs7Ozs7Ozs7S0FlSixBQUdDOzs7Ozs7Ozs7OzsrR0FLRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BK0dILEFBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBV0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWtFRCxBQUtDOzs7Ozs7Ozs7Ozs7MkVBSUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWdNSixBQUtDOzs7Ozs7Ozs7OztnREFHMk47Ozs7Ozs7Ozs7OztLQVk1TixBQUtDOzs7Ozs7Ozs7OztnREFHbU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01Bc0luTSxBQUtBOzs7Ozs7Ozs7OztnREFHK0o7Ozs7Ozs7Ozs7OztLQVloSyxBQUtDOzs7Ozs7Ozs7OztnREFHMk07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUEyTzNNLEFBS0E7Ozs7Ozs7OztnREFDK0w7Ozs7Ozs7Ozs7OztLQVloTSxBQUtDOzs7Ozs7Ozs7OztnREFHdU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQTJCdk0sQUFHQTs7Ozs7Ozs7Ozs7K0lBTUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQTJCSCxBQUdBOzs7Ozs7Ozs7OzsrSUFNRzs7Ozs7Ozs7Ozs7O0tBWUosQUFLQzs7Ozs7Ozs7Ozs7Z0RBR21NOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFnRG5NLEFBS0E7Ozs7Ozs7OztnREFDMkw7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BcVYzTDs7Ozs7Ozs7Ozs7O2dEQVFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19leHRlbmRzLCBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yLCBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IEhvc3RMaXN0ZW5lciwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RhYmxlLCBJbmplY3QsIE5nWm9uZSwgZGVmaW5lSW5qZWN0YWJsZSwgaW5qZWN0LCBPcHRpb25hbCwgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIEluamVjdGlvblRva2VuLCBBcHBsaWNhdGlvblJlZiwgSW5qZWN0b3IsIFZpZXdDb250YWluZXJSZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQXR0cmlidXRlLCBTa2lwU2VsZiwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIFZpZXdDaGlsZCwgQ29udGVudENoaWxkLCBUZW1wbGF0ZVJlZiwgSXRlcmFibGVEaWZmZXJzLCBBUFBfSU5JVElBTElaRVIsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IERPQ1VNRU5ULCBMb2NhdGlvbiwgTG9jYXRpb25TdHJhdGVneSwgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFVybFNlcmlhbGl6ZXIsIFJvdXRlciwgTmF2aWdhdGlvblN0YXJ0LCBBY3RpdmF0ZWRSb3V0ZSwgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cywgUFJJTUFSWV9PVVRMRVQsIFJvdXRlckxpbmsgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybSwgZ2V0UGxhdGZvcm1zLCBMSUZFQ1lDTEVfV0lMTF9FTlRFUiwgTElGRUNZQ0xFX0RJRF9FTlRFUiwgTElGRUNZQ0xFX1dJTExfTEVBVkUsIExJRkVDWUNMRV9ESURfTEVBVkUsIExJRkVDWUNMRV9XSUxMX1VOTE9BRCwgYWN0aW9uU2hlZXRDb250cm9sbGVyLCBhbGVydENvbnRyb2xsZXIsIGxvYWRpbmdDb250cm9sbGVyLCBtZW51Q29udHJvbGxlciwgcGlja2VyQ29udHJvbGxlciwgbW9kYWxDb250cm9sbGVyLCBwb3BvdmVyQ29udHJvbGxlciwgdG9hc3RDb250cm9sbGVyIH0gZnJvbSAnQGlvbmljL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCwgZnJvbUV2ZW50LCBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgc3dpdGNoTWFwLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IGFwcGx5UG9seWZpbGxzLCBkZWZpbmVDdXN0b21FbGVtZW50cyB9IGZyb20gJ0Bpb25pYy9jb3JlL2xvYWRlcic7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKiogQHR5cGUgez99ICovXG52YXIgcmFmID0gKC8qKlxuICogQHBhcmFtIHs/fSBoXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiAoaCkge1xuICAgIGlmICh0eXBlb2YgX196b25lX3N5bWJvbF9fcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBfX3pvbmVfc3ltYm9sX19yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaCk7XG4gICAgfVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGgpO1xufSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgVmFsdWVBY2Nlc3NvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWYWx1ZUFjY2Vzc29yKGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICgvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gKC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICBzZXRJb25pY0NsYXNzZXModGhpcy5lbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlRXZlbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZWwgPT09IHRoaXMuZWwubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLmxhc3RWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRJb25pY0NsYXNzZXModGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9oYW5kbGVCbHVyRXZlbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsID09PSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgICAgICBzZXRJb25pY0NsYXNzZXModGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXNEaXNhYmxlZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXNEaXNhYmxlZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9O1xuICAgIFZhbHVlQWNjZXNzb3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgIF9oYW5kbGVCbHVyRXZlbnQ6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydpb25CbHVyJywgWyckZXZlbnQudGFyZ2V0J10sXSB9XVxuICAgIH07XG4gICAgcmV0dXJuIFZhbHVlQWNjZXNzb3I7XG59KCkpO1xuLyoqIEB0eXBlIHs/fSAqL1xudmFyIHNldElvbmljQ2xhc3NlcyA9ICgvKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByYWYoKC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBpbnB1dCA9ICgvKiogQHR5cGUgez99ICovIChlbGVtZW50Lm5hdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgY2xhc3NlcyA9IGdldENsYXNzZXMoaW5wdXQpO1xuICAgICAgICBzZXRDbGFzc2VzKGlucHV0LCBjbGFzc2VzKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgaXRlbSA9IGlucHV0LmNsb3Nlc3QoJ2lvbi1pdGVtJyk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBzZXRDbGFzc2VzKGl0ZW0sIGNsYXNzZXMpO1xuICAgICAgICB9XG4gICAgfSkpO1xufSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgZ2V0Q2xhc3NlcyA9ICgvKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgdmFyIGNsYXNzTGlzdCA9IGVsZW1lbnQuY2xhc3NMaXN0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICB2YXIgY2xhc3NlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGl0ZW0gPSBjbGFzc0xpc3QuaXRlbShpKTtcbiAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwgJiYgc3RhcnRzV2l0aChpdGVtLCAnbmctJykpIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaChcImlvbi1cIiArIGl0ZW0uc3Vic3RyKDMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3Nlcztcbn0pO1xuLyoqIEB0eXBlIHs/fSAqL1xudmFyIHNldENsYXNzZXMgPSAoLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gY2xhc3Nlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzZXMpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgdmFyIGNsYXNzTGlzdCA9IGVsZW1lbnQuY2xhc3NMaXN0O1xuICAgIFtcbiAgICAgICAgJ2lvbi12YWxpZCcsXG4gICAgICAgICdpb24taW52YWxpZCcsXG4gICAgICAgICdpb24tdG91Y2hlZCcsXG4gICAgICAgICdpb24tdW50b3VjaGVkJyxcbiAgICAgICAgJ2lvbi1kaXJ0eScsXG4gICAgICAgICdpb24tcHJpc3RpbmUnXG4gICAgXS5mb3JFYWNoKCgvKipcbiAgICAgKiBAcGFyYW0gez99IGNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjbGFzc0xpc3QucmVtb3ZlKGMpOyB9KSk7XG4gICAgY2xhc3Nlcy5mb3JFYWNoKCgvKipcbiAgICAgKiBAcGFyYW0gez99IGNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjbGFzc0xpc3QuYWRkKGMpOyB9KSk7XG59KTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBzdGFydHNXaXRoID0gKC8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHBhcmFtIHs/fSBzZWFyY2hcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIChpbnB1dCwgc2VhcmNoKSB7XG4gICAgcmV0dXJuIGlucHV0LnN1YnN0cigwLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQm9vbGVhblZhbHVlQWNjZXNzb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJvb2xlYW5WYWx1ZUFjY2Vzc29yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJvb2xlYW5WYWx1ZUFjY2Vzc29yKGVsKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBlbCkgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQm9vbGVhblZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoZWNrZWQgPSB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlID09IG51bGwgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgICBzZXRJb25pY0NsYXNzZXModGhpcy5lbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCb29sZWFuVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2hhbmRsZUlvbkNoYW5nZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZUV2ZW50KGVsLCBlbC5jaGVja2VkKTtcbiAgICB9O1xuICAgIEJvb2xlYW5WYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGlyZWN0aXZlLXNlbGVjdG9yICovXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW9uLWNoZWNrYm94LGlvbi10b2dnbGUnLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogQm9vbGVhblZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgQm9vbGVhblZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG4gICAgXTsgfTtcbiAgICBCb29sZWFuVmFsdWVBY2Nlc3Nvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgX2hhbmRsZUlvbkNoYW5nZTogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2lvbkNoYW5nZScsIFsnJGV2ZW50LnRhcmdldCddLF0gfV1cbiAgICB9O1xuICAgIHJldHVybiBCb29sZWFuVmFsdWVBY2Nlc3Nvcjtcbn0oVmFsdWVBY2Nlc3NvcikpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIE51bWVyaWNWYWx1ZUFjY2Vzc29yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOdW1lcmljVmFsdWVBY2Nlc3NvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdW1lcmljVmFsdWVBY2Nlc3NvcihlbCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZWwpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE51bWVyaWNWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5faGFuZGxlSW9uQ2hhbmdlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlRXZlbnQoZWwsIGVsLnZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE51bWVyaWNWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZS5jYWxsKHRoaXMsICgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmbih2YWx1ZSA9PT0gJycgPyBudWxsIDogcGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBOdW1lcmljVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvciAqL1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lvbi1pbnB1dFt0eXBlPW51bWJlcl0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogTnVtZXJpY1ZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgTnVtZXJpY1ZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG4gICAgXTsgfTtcbiAgICBOdW1lcmljVmFsdWVBY2Nlc3Nvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgX2hhbmRsZUlvbkNoYW5nZTogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2lvbkNoYW5nZScsIFsnJGV2ZW50LnRhcmdldCddLF0gfV1cbiAgICB9O1xuICAgIHJldHVybiBOdW1lcmljVmFsdWVBY2Nlc3Nvcjtcbn0oVmFsdWVBY2Nlc3NvcikpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFJhZGlvVmFsdWVBY2Nlc3NvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFkaW9WYWx1ZUFjY2Vzc29yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhZGlvVmFsdWVBY2Nlc3NvcihlbCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZWwpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJhZGlvVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2hhbmRsZUlvblNlbGVjdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZUV2ZW50KGVsLCBlbC5jaGVja2VkKTtcbiAgICB9O1xuICAgIFJhZGlvVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvciAqL1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lvbi1yYWRpbycsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBSYWRpb1ZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgUmFkaW9WYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuICAgIF07IH07XG4gICAgUmFkaW9WYWx1ZUFjY2Vzc29yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICBfaGFuZGxlSW9uU2VsZWN0OiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnaW9uU2VsZWN0JywgWyckZXZlbnQudGFyZ2V0J10sXSB9XVxuICAgIH07XG4gICAgcmV0dXJuIFJhZGlvVmFsdWVBY2Nlc3Nvcjtcbn0oVmFsdWVBY2Nlc3NvcikpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFNlbGVjdFZhbHVlQWNjZXNzb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlbGVjdFZhbHVlQWNjZXNzb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VsZWN0VmFsdWVBY2Nlc3NvcihlbCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZWwpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9oYW5kbGVDaGFuZ2VFdmVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZUV2ZW50KGVsLCBlbC52YWx1ZSk7XG4gICAgfTtcbiAgICBTZWxlY3RWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGlyZWN0aXZlLXNlbGVjdG9yICovXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW9uLXJhbmdlLCBpb24tc2VsZWN0LCBpb24tcmFkaW8tZ3JvdXAsIGlvbi1zZWdtZW50LCBpb24tZGF0ZXRpbWUnLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogU2VsZWN0VmFsdWVBY2Nlc3NvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBTZWxlY3RWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuICAgIF07IH07XG4gICAgU2VsZWN0VmFsdWVBY2Nlc3Nvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgX2hhbmRsZUNoYW5nZUV2ZW50OiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnaW9uQ2hhbmdlJywgWyckZXZlbnQudGFyZ2V0J10sXSB9XVxuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdFZhbHVlQWNjZXNzb3I7XG59KFZhbHVlQWNjZXNzb3IpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBUZXh0VmFsdWVBY2Nlc3NvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dFZhbHVlQWNjZXNzb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dFZhbHVlQWNjZXNzb3IoZWwpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGVsKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZXh0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2hhbmRsZUlucHV0RXZlbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2VFdmVudChlbCwgZWwudmFsdWUpO1xuICAgIH07XG4gICAgVGV4dFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkaXJlY3RpdmUtc2VsZWN0b3IgKi9cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpb24taW5wdXQ6bm90KFt0eXBlPW51bWJlcl0pLGlvbi10ZXh0YXJlYSxpb24tc2VhcmNoYmFyJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IFRleHRWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFRleHRWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuICAgIF07IH07XG4gICAgVGV4dFZhbHVlQWNjZXNzb3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgIF9oYW5kbGVJbnB1dEV2ZW50OiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnaW9uQ2hhbmdlJywgWyckZXZlbnQudGFyZ2V0J10sXSB9XVxuICAgIH07XG4gICAgcmV0dXJuIFRleHRWYWx1ZUFjY2Vzc29yO1xufShWYWx1ZUFjY2Vzc29yKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgUGxhdGZvcm0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhdGZvcm0oZG9jLCB6b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYWNrQnV0dG9uID0gKC8qKiBAdHlwZSB7P30gKi8gKG5ldyBTdWJqZWN0KCkpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXVzZSBldmVudCBlbWl0cyB3aGVuIHRoZSBuYXRpdmUgcGxhdGZvcm0gcHV0cyB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgICogaW50byB0aGUgYmFja2dyb3VuZCwgdHlwaWNhbGx5IHdoZW4gdGhlIHVzZXIgc3dpdGNoZXMgdG8gYSBkaWZmZXJlbnRcbiAgICAgICAgICogYXBwbGljYXRpb24uIFRoaXMgZXZlbnQgd291bGQgZW1pdCB3aGVuIGEgQ29yZG92YSBhcHAgaXMgcHV0IGludG9cbiAgICAgICAgICogdGhlIGJhY2tncm91bmQsIGhvd2V2ZXIsIGl0IHdvdWxkIG5vdCBmaXJlIG9uIGEgc3RhbmRhcmQgd2ViIGJyb3dzZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdXNlID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXN1bWUgZXZlbnQgZW1pdHMgd2hlbiB0aGUgbmF0aXZlIHBsYXRmb3JtIHB1bGxzIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICAgKiBvdXQgZnJvbSB0aGUgYmFja2dyb3VuZC4gVGhpcyBldmVudCB3b3VsZCBlbWl0IHdoZW4gYSBDb3Jkb3ZhIGFwcCBjb21lc1xuICAgICAgICAgKiBvdXQgZnJvbSB0aGUgYmFja2dyb3VuZCwgaG93ZXZlciwgaXQgd291bGQgbm90IGZpcmUgb24gYSBzdGFuZGFyZCB3ZWIgYnJvd3Nlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzdW1lID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXNpemUgZXZlbnQgZW1pdHMgd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaGFzIGNoYW5nZWQgZGltZW5zaW9ucy4gVGhpc1xuICAgICAgICAgKiBjb3VsZCBiZSBmcm9tIGEgYnJvd3NlciB3aW5kb3cgYmVpbmcgcGh5c2ljYWxseSByZXNpemVkLCBvciBmcm9tIGEgZGV2aWNlXG4gICAgICAgICAqIGNoYW5naW5nIG9yaWVudGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNpemUgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB6b25lLnJ1bigoLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy53aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICBfdGhpcy5iYWNrQnV0dG9uLnN1YnNjcmliZVdpdGhQcmlvcml0eSA9ICgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gcHJpb3JpdHlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChwcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUoKC8qKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gZXZcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChldikgeyByZXR1cm4gKGV2LnJlZ2lzdGVyKHByaW9yaXR5LCAoLyoqXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB6b25lLnJ1bihjYWxsYmFjayk7IH0pKSk7IH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJveHlFdmVudChfdGhpcy5wYXVzZSwgZG9jLCAncGF1c2UnKTtcbiAgICAgICAgICAgIHByb3h5RXZlbnQoX3RoaXMucmVzdW1lLCBkb2MsICdyZXN1bWUnKTtcbiAgICAgICAgICAgIHByb3h5RXZlbnQoX3RoaXMuYmFja0J1dHRvbiwgZG9jLCAnaW9uQmFja0J1dHRvbicpO1xuICAgICAgICAgICAgcHJveHlFdmVudChfdGhpcy5yZXNpemUsIF90aGlzLndpbiwgJ3Jlc2l6ZScpO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIHJlYWR5UmVzb2x2ZTtcbiAgICAgICAgICAgIF90aGlzLl9yZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZSgoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHJlc1xuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHJlcykgeyByZWFkeVJlc29sdmUgPSByZXM7IH0pKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy53aW4gJiYgX3RoaXMud2luWydjb3Jkb3ZhJ10pIHtcbiAgICAgICAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCAoLyoqXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5UmVzb2x2ZSgnY29yZG92YScpO1xuICAgICAgICAgICAgICAgIH0pLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAocmVhZHlSZXNvbHZlKSkoJ2RvbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHJldHVybnMgdHJ1ZS9mYWxzZSBiYXNlZCBvbiBwbGF0Zm9ybS5cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtIHRoZSB1c2VyIGlzIG9uLCBgaXMocGxhdGZvcm1OYW1lKWAgd2lsbFxuICAgICAqIHJldHVybiBgdHJ1ZWAgb3IgYGZhbHNlYC4gTm90ZSB0aGF0IHRoZSBzYW1lIGFwcCBjYW4gcmV0dXJuIGB0cnVlYFxuICAgICAqIGZvciBtb3JlIHRoYW4gb25lIHBsYXRmb3JtIG5hbWUuIEZvciBleGFtcGxlLCBhbiBhcHAgcnVubmluZyBmcm9tXG4gICAgICogYW4gaVBhZCB3b3VsZCByZXR1cm4gYHRydWVgIGZvciB0aGUgcGxhdGZvcm0gbmFtZXM6IGBtb2JpbGVgLFxuICAgICAqIGBpb3NgLCBgaXBhZGAsIGFuZCBgdGFibGV0YC4gQWRkaXRpb25hbGx5LCBpZiB0aGUgYXBwIHdhcyBydW5uaW5nXG4gICAgICogZnJvbSBDb3Jkb3ZhIHRoZW4gYGNvcmRvdmFgIHdvdWxkIGJlIHRydWUsIGFuZCBpZiBpdCB3YXMgcnVubmluZ1xuICAgICAqIGZyb20gYSB3ZWIgYnJvd3NlciBvbiB0aGUgaVBhZCB0aGVuIGBtb2JpbGV3ZWJgIHdvdWxkIGJlIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnaW9uaWMtYW5ndWxhcic7XG4gICAgICpcbiAgICAgKiBAQ29tcG9uZW50KHsuLi59KVxuICAgICAqIGV4cG9ydCBNeVBhZ2Uge1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIHBsYXRmb3JtOiBQbGF0Zm9ybSkge1xuICAgICAqICAgICBpZiAodGhpcy5wbGF0Zm9ybS5pcygnaW9zJykpIHtcbiAgICAgKiAgICAgICAvLyBUaGlzIHdpbGwgb25seSBwcmludCB3aGVuIG9uIGlPU1xuICAgICAqICAgICAgIGNvbnNvbGUubG9nKCdJIGFtIGFuIGlPUyBkZXZpY2UhJyk7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiB8IFBsYXRmb3JtIE5hbWUgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqIHwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICogfCBhbmRyb2lkICAgICAgICAgfCBvbiBhIGRldmljZSBydW5uaW5nIEFuZHJvaWQuICAgICAgIHxcbiAgICAgKiB8IGNvcmRvdmEgICAgICAgICB8IG9uIGEgZGV2aWNlIHJ1bm5pbmcgQ29yZG92YS4gICAgICAgfFxuICAgICAqIHwgaW9zICAgICAgICAgICAgIHwgb24gYSBkZXZpY2UgcnVubmluZyBpT1MuICAgICAgICAgICB8XG4gICAgICogfCBpcGFkICAgICAgICAgICAgfCBvbiBhbiBpUGFkIGRldmljZS4gICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IGlwaG9uZSAgICAgICAgICB8IG9uIGFuIGlQaG9uZSBkZXZpY2UuICAgICAgICAgICAgICAgfFxuICAgICAqIHwgcGhhYmxldCAgICAgICAgIHwgb24gYSBwaGFibGV0IGRldmljZS4gICAgICAgICAgICAgICB8XG4gICAgICogfCB0YWJsZXQgICAgICAgICAgfCBvbiBhIHRhYmxldCBkZXZpY2UuICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IGVsZWN0cm9uICAgICAgICB8IGluIEVsZWN0cm9uIG9uIGEgZGVza3RvcCBkZXZpY2UuICAgfFxuICAgICAqIHwgcHdhICAgICAgICAgICAgIHwgYXMgYSBQV0EgYXBwLiAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogfCBtb2JpbGUgICAgICAgICAgfCBvbiBhIG1vYmlsZSBkZXZpY2UuICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IG1vYmlsZXdlYiAgICAgICB8IG9uIGEgbW9iaWxlIGRldmljZSBpbiBhIGJyb3dzZXIuICAgfFxuICAgICAqIHwgZGVza3RvcCAgICAgICAgIHwgb24gYSBkZXNrdG9wIGRldmljZS4gICAgICAgICAgICAgICB8XG4gICAgICogfCBoeWJyaWQgICAgICAgICAgfCBpcyBhIGNvcmRvdmEgb3IgY2FwYWNpdG9yIGFwcC4gICAgIHxcbiAgICAgKlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFxcQGRlc2NyaXB0aW9uXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSB0aGUgdXNlciBpcyBvbiwgYGlzKHBsYXRmb3JtTmFtZSlgIHdpbGxcbiAgICAgKiByZXR1cm4gYHRydWVgIG9yIGBmYWxzZWAuIE5vdGUgdGhhdCB0aGUgc2FtZSBhcHAgY2FuIHJldHVybiBgdHJ1ZWBcbiAgICAgKiBmb3IgbW9yZSB0aGFuIG9uZSBwbGF0Zm9ybSBuYW1lLiBGb3IgZXhhbXBsZSwgYW4gYXBwIHJ1bm5pbmcgZnJvbVxuICAgICAqIGFuIGlQYWQgd291bGQgcmV0dXJuIGB0cnVlYCBmb3IgdGhlIHBsYXRmb3JtIG5hbWVzOiBgbW9iaWxlYCxcbiAgICAgKiBgaW9zYCwgYGlwYWRgLCBhbmQgYHRhYmxldGAuIEFkZGl0aW9uYWxseSwgaWYgdGhlIGFwcCB3YXMgcnVubmluZ1xuICAgICAqIGZyb20gQ29yZG92YSB0aGVuIGBjb3Jkb3ZhYCB3b3VsZCBiZSB0cnVlLCBhbmQgaWYgaXQgd2FzIHJ1bm5pbmdcbiAgICAgKiBmcm9tIGEgd2ViIGJyb3dzZXIgb24gdGhlIGlQYWQgdGhlbiBgbW9iaWxld2ViYCB3b3VsZCBiZSBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ2lvbmljLWFuZ3VsYXInO1xuICAgICAqXG4gICAgICogXFxAQ29tcG9uZW50KHsuLi59KVxuICAgICAqIGV4cG9ydCBNeVBhZ2Uge1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIHBsYXRmb3JtOiBQbGF0Zm9ybSkge1xuICAgICAqICAgICBpZiAodGhpcy5wbGF0Zm9ybS5pcygnaW9zJykpIHtcbiAgICAgKiAgICAgICAvLyBUaGlzIHdpbGwgb25seSBwcmludCB3aGVuIG9uIGlPU1xuICAgICAqICAgICAgIGNvbnNvbGUubG9nKCdJIGFtIGFuIGlPUyBkZXZpY2UhJyk7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiB8IFBsYXRmb3JtIE5hbWUgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqIHwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICogfCBhbmRyb2lkICAgICAgICAgfCBvbiBhIGRldmljZSBydW5uaW5nIEFuZHJvaWQuICAgICAgIHxcbiAgICAgKiB8IGNvcmRvdmEgICAgICAgICB8IG9uIGEgZGV2aWNlIHJ1bm5pbmcgQ29yZG92YS4gICAgICAgfFxuICAgICAqIHwgaW9zICAgICAgICAgICAgIHwgb24gYSBkZXZpY2UgcnVubmluZyBpT1MuICAgICAgICAgICB8XG4gICAgICogfCBpcGFkICAgICAgICAgICAgfCBvbiBhbiBpUGFkIGRldmljZS4gICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IGlwaG9uZSAgICAgICAgICB8IG9uIGFuIGlQaG9uZSBkZXZpY2UuICAgICAgICAgICAgICAgfFxuICAgICAqIHwgcGhhYmxldCAgICAgICAgIHwgb24gYSBwaGFibGV0IGRldmljZS4gICAgICAgICAgICAgICB8XG4gICAgICogfCB0YWJsZXQgICAgICAgICAgfCBvbiBhIHRhYmxldCBkZXZpY2UuICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IGVsZWN0cm9uICAgICAgICB8IGluIEVsZWN0cm9uIG9uIGEgZGVza3RvcCBkZXZpY2UuICAgfFxuICAgICAqIHwgcHdhICAgICAgICAgICAgIHwgYXMgYSBQV0EgYXBwLiAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogfCBtb2JpbGUgICAgICAgICAgfCBvbiBhIG1vYmlsZSBkZXZpY2UuICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IG1vYmlsZXdlYiAgICAgICB8IG9uIGEgbW9iaWxlIGRldmljZSBpbiBhIGJyb3dzZXIuICAgfFxuICAgICAqIHwgZGVza3RvcCAgICAgICAgIHwgb24gYSBkZXNrdG9wIGRldmljZS4gICAgICAgICAgICAgICB8XG4gICAgICogfCBoeWJyaWQgICAgICAgICAgfCBpcyBhIGNvcmRvdmEgb3IgY2FwYWNpdG9yIGFwcC4gICAgIHxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gcGxhdGZvcm1OYW1lXG4gICAgICogQHJldHVybiB7P30gcmV0dXJucyB0cnVlL2ZhbHNlIGJhc2VkIG9uIHBsYXRmb3JtLlxuICAgICAqL1xuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5pcyA9IC8qKlxuICAgICAqIFxcQGRlc2NyaXB0aW9uXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSB0aGUgdXNlciBpcyBvbiwgYGlzKHBsYXRmb3JtTmFtZSlgIHdpbGxcbiAgICAgKiByZXR1cm4gYHRydWVgIG9yIGBmYWxzZWAuIE5vdGUgdGhhdCB0aGUgc2FtZSBhcHAgY2FuIHJldHVybiBgdHJ1ZWBcbiAgICAgKiBmb3IgbW9yZSB0aGFuIG9uZSBwbGF0Zm9ybSBuYW1lLiBGb3IgZXhhbXBsZSwgYW4gYXBwIHJ1bm5pbmcgZnJvbVxuICAgICAqIGFuIGlQYWQgd291bGQgcmV0dXJuIGB0cnVlYCBmb3IgdGhlIHBsYXRmb3JtIG5hbWVzOiBgbW9iaWxlYCxcbiAgICAgKiBgaW9zYCwgYGlwYWRgLCBhbmQgYHRhYmxldGAuIEFkZGl0aW9uYWxseSwgaWYgdGhlIGFwcCB3YXMgcnVubmluZ1xuICAgICAqIGZyb20gQ29yZG92YSB0aGVuIGBjb3Jkb3ZhYCB3b3VsZCBiZSB0cnVlLCBhbmQgaWYgaXQgd2FzIHJ1bm5pbmdcbiAgICAgKiBmcm9tIGEgd2ViIGJyb3dzZXIgb24gdGhlIGlQYWQgdGhlbiBgbW9iaWxld2ViYCB3b3VsZCBiZSBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ2lvbmljLWFuZ3VsYXInO1xuICAgICAqXG4gICAgICogXFxAQ29tcG9uZW50KHsuLi59KVxuICAgICAqIGV4cG9ydCBNeVBhZ2Uge1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIHBsYXRmb3JtOiBQbGF0Zm9ybSkge1xuICAgICAqICAgICBpZiAodGhpcy5wbGF0Zm9ybS5pcygnaW9zJykpIHtcbiAgICAgKiAgICAgICAvLyBUaGlzIHdpbGwgb25seSBwcmludCB3aGVuIG9uIGlPU1xuICAgICAqICAgICAgIGNvbnNvbGUubG9nKCdJIGFtIGFuIGlPUyBkZXZpY2UhJyk7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiB8IFBsYXRmb3JtIE5hbWUgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqIHwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICogfCBhbmRyb2lkICAgICAgICAgfCBvbiBhIGRldmljZSBydW5uaW5nIEFuZHJvaWQuICAgICAgIHxcbiAgICAgKiB8IGNvcmRvdmEgICAgICAgICB8IG9uIGEgZGV2aWNlIHJ1bm5pbmcgQ29yZG92YS4gICAgICAgfFxuICAgICAqIHwgaW9zICAgICAgICAgICAgIHwgb24gYSBkZXZpY2UgcnVubmluZyBpT1MuICAgICAgICAgICB8XG4gICAgICogfCBpcGFkICAgICAgICAgICAgfCBvbiBhbiBpUGFkIGRldmljZS4gICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IGlwaG9uZSAgICAgICAgICB8IG9uIGFuIGlQaG9uZSBkZXZpY2UuICAgICAgICAgICAgICAgfFxuICAgICAqIHwgcGhhYmxldCAgICAgICAgIHwgb24gYSBwaGFibGV0IGRldmljZS4gICAgICAgICAgICAgICB8XG4gICAgICogfCB0YWJsZXQgICAgICAgICAgfCBvbiBhIHRhYmxldCBkZXZpY2UuICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IGVsZWN0cm9uICAgICAgICB8IGluIEVsZWN0cm9uIG9uIGEgZGVza3RvcCBkZXZpY2UuICAgfFxuICAgICAqIHwgcHdhICAgICAgICAgICAgIHwgYXMgYSBQV0EgYXBwLiAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogfCBtb2JpbGUgICAgICAgICAgfCBvbiBhIG1vYmlsZSBkZXZpY2UuICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IG1vYmlsZXdlYiAgICAgICB8IG9uIGEgbW9iaWxlIGRldmljZSBpbiBhIGJyb3dzZXIuICAgfFxuICAgICAqIHwgZGVza3RvcCAgICAgICAgIHwgb24gYSBkZXNrdG9wIGRldmljZS4gICAgICAgICAgICAgICB8XG4gICAgICogfCBoeWJyaWQgICAgICAgICAgfCBpcyBhIGNvcmRvdmEgb3IgY2FwYWNpdG9yIGFwcC4gICAgIHxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gcGxhdGZvcm1OYW1lXG4gICAgICogQHJldHVybiB7P30gcmV0dXJucyB0cnVlL2ZhbHNlIGJhc2VkIG9uIHBsYXRmb3JtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwbGF0Zm9ybU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGlzUGxhdGZvcm0odGhpcy53aW4sIHBsYXRmb3JtTmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgYXJyYXkgb2YgcGxhdGZvcm1zXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRGVwZW5kaW5nIG9uIHdoYXQgZGV2aWNlIHlvdSBhcmUgb24sIGBwbGF0Zm9ybXNgIGNhbiByZXR1cm4gbXVsdGlwbGUgdmFsdWVzLlxuICAgICAqIEVhY2ggcG9zc2libGUgdmFsdWUgaXMgYSBoaWVyYXJjaHkgb2YgcGxhdGZvcm1zLiBGb3IgZXhhbXBsZSwgb24gYW4gaVBob25lLFxuICAgICAqIGl0IHdvdWxkIHJldHVybiBgbW9iaWxlYCwgYGlvc2AsIGFuZCBgaXBob25lYC5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnaW9uaWMtYW5ndWxhcic7XG4gICAgICpcbiAgICAgKiBAQ29tcG9uZW50KHsuLi59KVxuICAgICAqIGV4cG9ydCBNeVBhZ2Uge1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIHBsYXRmb3JtOiBQbGF0Zm9ybSkge1xuICAgICAqICAgICAvLyBUaGlzIHdpbGwgcHJpbnQgYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgcGxhdGZvcm1zXG4gICAgICogICAgIGNvbnNvbGUubG9nKHRoaXMucGxhdGZvcm0ucGxhdGZvcm1zKCkpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBcXEBkZXNjcmlwdGlvblxuICAgICAqIERlcGVuZGluZyBvbiB3aGF0IGRldmljZSB5b3UgYXJlIG9uLCBgcGxhdGZvcm1zYCBjYW4gcmV0dXJuIG11bHRpcGxlIHZhbHVlcy5cbiAgICAgKiBFYWNoIHBvc3NpYmxlIHZhbHVlIGlzIGEgaGllcmFyY2h5IG9mIHBsYXRmb3Jtcy4gRm9yIGV4YW1wbGUsIG9uIGFuIGlQaG9uZSxcbiAgICAgKiBpdCB3b3VsZCByZXR1cm4gYG1vYmlsZWAsIGBpb3NgLCBhbmQgYGlwaG9uZWAuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ2lvbmljLWFuZ3VsYXInO1xuICAgICAqXG4gICAgICogXFxAQ29tcG9uZW50KHsuLi59KVxuICAgICAqIGV4cG9ydCBNeVBhZ2Uge1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIHBsYXRmb3JtOiBQbGF0Zm9ybSkge1xuICAgICAqICAgICAvLyBUaGlzIHdpbGwgcHJpbnQgYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgcGxhdGZvcm1zXG4gICAgICogICAgIGNvbnNvbGUubG9nKHRoaXMucGxhdGZvcm0ucGxhdGZvcm1zKCkpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAcmV0dXJuIHs/fSB0aGUgYXJyYXkgb2YgcGxhdGZvcm1zXG4gICAgICovXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLnBsYXRmb3JtcyA9IC8qKlxuICAgICAqIFxcQGRlc2NyaXB0aW9uXG4gICAgICogRGVwZW5kaW5nIG9uIHdoYXQgZGV2aWNlIHlvdSBhcmUgb24sIGBwbGF0Zm9ybXNgIGNhbiByZXR1cm4gbXVsdGlwbGUgdmFsdWVzLlxuICAgICAqIEVhY2ggcG9zc2libGUgdmFsdWUgaXMgYSBoaWVyYXJjaHkgb2YgcGxhdGZvcm1zLiBGb3IgZXhhbXBsZSwgb24gYW4gaVBob25lLFxuICAgICAqIGl0IHdvdWxkIHJldHVybiBgbW9iaWxlYCwgYGlvc2AsIGFuZCBgaXBob25lYC5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnaW9uaWMtYW5ndWxhcic7XG4gICAgICpcbiAgICAgKiBcXEBDb21wb25lbnQoey4uLn0pXG4gICAgICogZXhwb3J0IE15UGFnZSB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgcGxhdGZvcm06IFBsYXRmb3JtKSB7XG4gICAgICogICAgIC8vIFRoaXMgd2lsbCBwcmludCBhbiBhcnJheSBvZiB0aGUgY3VycmVudCBwbGF0Zm9ybXNcbiAgICAgKiAgICAgY29uc29sZS5sb2codGhpcy5wbGF0Zm9ybS5wbGF0Zm9ybXMoKSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEByZXR1cm4gez99IHRoZSBhcnJheSBvZiBwbGF0Zm9ybXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQbGF0Zm9ybXModGhpcy53aW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2Ugd2hlbiB0aGUgcGxhdGZvcm0gaXMgcmVhZHkgYW5kIG5hdGl2ZSBmdW5jdGlvbmFsaXR5XG4gICAgICogY2FuIGJlIGNhbGxlZC4gSWYgdGhlIGFwcCBpcyBydW5uaW5nIGZyb20gd2l0aGluIGEgd2ViIGJyb3dzZXIsIHRoZW5cbiAgICAgKiB0aGUgcHJvbWlzZSB3aWxsIHJlc29sdmUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5LiBXaGVuIHRoZSBhcHAgaXMgcnVubmluZ1xuICAgICAqIGZyb20gYW4gYXBwbGljYXRpb24gZW5naW5lIHN1Y2ggYXMgQ29yZG92YSwgdGhlbiB0aGUgcHJvbWlzZSB3aWxsXG4gICAgICogcmVzb2x2ZSB3aGVuIENvcmRvdmEgdHJpZ2dlcnMgdGhlIGBkZXZpY2VyZWFkeWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzb2x2ZWQgdmFsdWUgaXMgdGhlIGByZWFkeVNvdXJjZWAsIHdoaWNoIHN0YXRlcyB3aGljaCBwbGF0Zm9ybVxuICAgICAqIHJlYWR5IHdhcyB1c2VkLiBGb3IgZXhhbXBsZSwgd2hlbiBDb3Jkb3ZhIGlzIHJlYWR5LCB0aGUgcmVzb2x2ZWQgcmVhZHlcbiAgICAgKiBzb3VyY2UgaXMgYGNvcmRvdmFgLiBUaGUgZGVmYXVsdCByZWFkeSBzb3VyY2UgdmFsdWUgd2lsbCBiZSBgZG9tYC4gVGhlXG4gICAgICogYHJlYWR5U291cmNlYCBpcyB1c2VmdWwgaWYgZGlmZmVyZW50IGxvZ2ljIHNob3VsZCBydW4gZGVwZW5kaW5nIG9uIHRoZVxuICAgICAqIHBsYXRmb3JtIHRoZSBhcHAgaXMgcnVubmluZyBmcm9tLiBGb3IgZXhhbXBsZSwgb25seSBDb3Jkb3ZhIGNhbiBleGVjdXRlXG4gICAgICogdGhlIHN0YXR1cyBiYXIgcGx1Z2luLCBzbyB0aGUgd2ViIHNob3VsZCBub3QgcnVuIHN0YXR1cyBiYXIgcGx1Z2luIGxvZ2ljLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gICAgICogaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICdpb25pYy1hbmd1bGFyJztcbiAgICAgKlxuICAgICAqIEBDb21wb25lbnQoey4uLn0pXG4gICAgICogZXhwb3J0IE15QXBwIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBwbGF0Zm9ybTogUGxhdGZvcm0pIHtcbiAgICAgKiAgICAgdGhpcy5wbGF0Zm9ybS5yZWFkeSgpLnRoZW4oKHJlYWR5U291cmNlKSA9PiB7XG4gICAgICogICAgICAgY29uc29sZS5sb2coJ1BsYXRmb3JtIHJlYWR5IGZyb20nLCByZWFkeVNvdXJjZSk7XG4gICAgICogICAgICAgLy8gUGxhdGZvcm0gbm93IHJlYWR5LCBleGVjdXRlIGFueSByZXF1aXJlZCBuYXRpdmUgY29kZVxuICAgICAqICAgICB9KTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2Ugd2hlbiB0aGUgcGxhdGZvcm0gaXMgcmVhZHkgYW5kIG5hdGl2ZSBmdW5jdGlvbmFsaXR5XG4gICAgICogY2FuIGJlIGNhbGxlZC4gSWYgdGhlIGFwcCBpcyBydW5uaW5nIGZyb20gd2l0aGluIGEgd2ViIGJyb3dzZXIsIHRoZW5cbiAgICAgKiB0aGUgcHJvbWlzZSB3aWxsIHJlc29sdmUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5LiBXaGVuIHRoZSBhcHAgaXMgcnVubmluZ1xuICAgICAqIGZyb20gYW4gYXBwbGljYXRpb24gZW5naW5lIHN1Y2ggYXMgQ29yZG92YSwgdGhlbiB0aGUgcHJvbWlzZSB3aWxsXG4gICAgICogcmVzb2x2ZSB3aGVuIENvcmRvdmEgdHJpZ2dlcnMgdGhlIGBkZXZpY2VyZWFkeWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzb2x2ZWQgdmFsdWUgaXMgdGhlIGByZWFkeVNvdXJjZWAsIHdoaWNoIHN0YXRlcyB3aGljaCBwbGF0Zm9ybVxuICAgICAqIHJlYWR5IHdhcyB1c2VkLiBGb3IgZXhhbXBsZSwgd2hlbiBDb3Jkb3ZhIGlzIHJlYWR5LCB0aGUgcmVzb2x2ZWQgcmVhZHlcbiAgICAgKiBzb3VyY2UgaXMgYGNvcmRvdmFgLiBUaGUgZGVmYXVsdCByZWFkeSBzb3VyY2UgdmFsdWUgd2lsbCBiZSBgZG9tYC4gVGhlXG4gICAgICogYHJlYWR5U291cmNlYCBpcyB1c2VmdWwgaWYgZGlmZmVyZW50IGxvZ2ljIHNob3VsZCBydW4gZGVwZW5kaW5nIG9uIHRoZVxuICAgICAqIHBsYXRmb3JtIHRoZSBhcHAgaXMgcnVubmluZyBmcm9tLiBGb3IgZXhhbXBsZSwgb25seSBDb3Jkb3ZhIGNhbiBleGVjdXRlXG4gICAgICogdGhlIHN0YXR1cyBiYXIgcGx1Z2luLCBzbyB0aGUgd2ViIHNob3VsZCBub3QgcnVuIHN0YXR1cyBiYXIgcGx1Z2luIGxvZ2ljLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnXFxAYW5ndWxhci9jb3JlJztcbiAgICAgKiBpbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ2lvbmljLWFuZ3VsYXInO1xuICAgICAqXG4gICAgICogXFxAQ29tcG9uZW50KHsuLi59KVxuICAgICAqIGV4cG9ydCBNeUFwcCB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgcGxhdGZvcm06IFBsYXRmb3JtKSB7XG4gICAgICogICAgIHRoaXMucGxhdGZvcm0ucmVhZHkoKS50aGVuKChyZWFkeVNvdXJjZSkgPT4ge1xuICAgICAqICAgICAgIGNvbnNvbGUubG9nKCdQbGF0Zm9ybSByZWFkeSBmcm9tJywgcmVhZHlTb3VyY2UpO1xuICAgICAqICAgICAgIC8vIFBsYXRmb3JtIG5vdyByZWFkeSwgZXhlY3V0ZSBhbnkgcmVxdWlyZWQgbmF0aXZlIGNvZGVcbiAgICAgKiAgICAgfSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLnJlYWR5ID0gLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2Ugd2hlbiB0aGUgcGxhdGZvcm0gaXMgcmVhZHkgYW5kIG5hdGl2ZSBmdW5jdGlvbmFsaXR5XG4gICAgICogY2FuIGJlIGNhbGxlZC4gSWYgdGhlIGFwcCBpcyBydW5uaW5nIGZyb20gd2l0aGluIGEgd2ViIGJyb3dzZXIsIHRoZW5cbiAgICAgKiB0aGUgcHJvbWlzZSB3aWxsIHJlc29sdmUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5LiBXaGVuIHRoZSBhcHAgaXMgcnVubmluZ1xuICAgICAqIGZyb20gYW4gYXBwbGljYXRpb24gZW5naW5lIHN1Y2ggYXMgQ29yZG92YSwgdGhlbiB0aGUgcHJvbWlzZSB3aWxsXG4gICAgICogcmVzb2x2ZSB3aGVuIENvcmRvdmEgdHJpZ2dlcnMgdGhlIGBkZXZpY2VyZWFkeWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzb2x2ZWQgdmFsdWUgaXMgdGhlIGByZWFkeVNvdXJjZWAsIHdoaWNoIHN0YXRlcyB3aGljaCBwbGF0Zm9ybVxuICAgICAqIHJlYWR5IHdhcyB1c2VkLiBGb3IgZXhhbXBsZSwgd2hlbiBDb3Jkb3ZhIGlzIHJlYWR5LCB0aGUgcmVzb2x2ZWQgcmVhZHlcbiAgICAgKiBzb3VyY2UgaXMgYGNvcmRvdmFgLiBUaGUgZGVmYXVsdCByZWFkeSBzb3VyY2UgdmFsdWUgd2lsbCBiZSBgZG9tYC4gVGhlXG4gICAgICogYHJlYWR5U291cmNlYCBpcyB1c2VmdWwgaWYgZGlmZmVyZW50IGxvZ2ljIHNob3VsZCBydW4gZGVwZW5kaW5nIG9uIHRoZVxuICAgICAqIHBsYXRmb3JtIHRoZSBhcHAgaXMgcnVubmluZyBmcm9tLiBGb3IgZXhhbXBsZSwgb25seSBDb3Jkb3ZhIGNhbiBleGVjdXRlXG4gICAgICogdGhlIHN0YXR1cyBiYXIgcGx1Z2luLCBzbyB0aGUgd2ViIHNob3VsZCBub3QgcnVuIHN0YXR1cyBiYXIgcGx1Z2luIGxvZ2ljLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnXFxAYW5ndWxhci9jb3JlJztcbiAgICAgKiBpbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ2lvbmljLWFuZ3VsYXInO1xuICAgICAqXG4gICAgICogXFxAQ29tcG9uZW50KHsuLi59KVxuICAgICAqIGV4cG9ydCBNeUFwcCB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgcGxhdGZvcm06IFBsYXRmb3JtKSB7XG4gICAgICogICAgIHRoaXMucGxhdGZvcm0ucmVhZHkoKS50aGVuKChyZWFkeVNvdXJjZSkgPT4ge1xuICAgICAqICAgICAgIGNvbnNvbGUubG9nKCdQbGF0Zm9ybSByZWFkeSBmcm9tJywgcmVhZHlTb3VyY2UpO1xuICAgICAqICAgICAgIC8vIFBsYXRmb3JtIG5vdyByZWFkeSwgZXhlY3V0ZSBhbnkgcmVxdWlyZWQgbmF0aXZlIGNvZGVcbiAgICAgKiAgICAgfSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlQcm9taXNlO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtLnByb3RvdHlwZSwgXCJpc1JUTFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGlmIHRoaXMgYXBwIGlzIHVzaW5nIHJpZ2h0LXRvLWxlZnQgbGFuZ3VhZ2UgZGlyZWN0aW9uIG9yIG5vdC5cbiAgICAgICAgICogV2UgcmVjb21tZW5kIHRoZSBhcHAncyBgaW5kZXguaHRtbGAgZmlsZSBhbHJlYWR5IGhhcyB0aGUgY29ycmVjdCBgZGlyYFxuICAgICAgICAgKiBhdHRyaWJ1dGUgdmFsdWUgc2V0LCBzdWNoIGFzIGA8aHRtbCBkaXI9XCJsdHJcIj5gIG9yIGA8aHRtbCBkaXI9XCJydGxcIj5gLlxuICAgICAgICAgKiBbVzNDOiBTdHJ1Y3R1cmFsIG1hcmt1cCBhbmQgcmlnaHQtdG8tbGVmdCB0ZXh0IGluIEhUTUxdKGh0dHA6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWh0bWwtZGlyKVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogUmV0dXJucyBpZiB0aGlzIGFwcCBpcyB1c2luZyByaWdodC10by1sZWZ0IGxhbmd1YWdlIGRpcmVjdGlvbiBvciBub3QuXG4gICAgICAgICAqIFdlIHJlY29tbWVuZCB0aGUgYXBwJ3MgYGluZGV4Lmh0bWxgIGZpbGUgYWxyZWFkeSBoYXMgdGhlIGNvcnJlY3QgYGRpcmBcbiAgICAgICAgICogYXR0cmlidXRlIHZhbHVlIHNldCwgc3VjaCBhcyBgPGh0bWwgZGlyPVwibHRyXCI+YCBvciBgPGh0bWwgZGlyPVwicnRsXCI+YC5cbiAgICAgICAgICogW1czQzogU3RydWN0dXJhbCBtYXJrdXAgYW5kIHJpZ2h0LXRvLWxlZnQgdGV4dCBpbiBIVE1MXShodHRwOi8vd3d3LnczLm9yZy9JbnRlcm5hdGlvbmFsL3F1ZXN0aW9ucy9xYS1odG1sLWRpcilcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvYy5kaXIgPT09ICdydGwnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmdldFF1ZXJ5UGFyYW0gPSAvKipcbiAgICAgKiBHZXQgdGhlIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gcmVhZFF1ZXJ5UGFyYW0odGhpcy53aW4ubG9jYXRpb24uaHJlZiwga2V5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBhcHAgaXMgaW4gbGFuZHNjYXBlIG1vZGUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFwcCBpcyBpbiBsYW5kc2NhcGUgbW9kZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5pc0xhbmRzY2FwZSA9IC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBhcHAgaXMgaW4gbGFuZHNjYXBlIG1vZGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc1BvcnRyYWl0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXBwIGlzIGluIHBvcnRhaXQgbW9kZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXBwIGlzIGluIHBvcnRhaXQgbW9kZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5pc1BvcnRyYWl0ID0gLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFwcCBpcyBpbiBwb3J0YWl0IG1vZGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbi5tYXRjaE1lZGlhICYmIHRoaXMud2luLm1hdGNoTWVkaWEoJyhvcmllbnRhdGlvbjogcG9ydHJhaXQpJykubWF0Y2hlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLnRlc3RVc2VyQWdlbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIG5hdiA9IHRoaXMud2luLm5hdmlnYXRvcjtcbiAgICAgICAgcmV0dXJuICEhKG5hdiAmJiBuYXYudXNlckFnZW50ICYmIG5hdi51c2VyQWdlbnQuaW5kZXhPZihleHByZXNzaW9uKSA+PSAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB1cmwuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHVybC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYXRmb3JtLnByb3RvdHlwZS51cmwgPSAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdXJsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aW4ubG9jYXRpb24uaHJlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBwbGF0Zm9ybSdzIHZpZXdwb3J0IHVzaW5nIGB3aW5kb3cuaW5uZXJXaWR0aGAuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgd2lkdGggb2YgdGhlIHBsYXRmb3JtJ3Mgdmlld3BvcnQgdXNpbmcgYHdpbmRvdy5pbm5lcldpZHRoYC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYXRmb3JtLnByb3RvdHlwZS53aWR0aCA9IC8qKlxuICAgICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBwbGF0Zm9ybSdzIHZpZXdwb3J0IHVzaW5nIGB3aW5kb3cuaW5uZXJXaWR0aGAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbi5pbm5lcldpZHRoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBwbGF0Zm9ybSdzIHZpZXdwb3J0IHVzaW5nIGB3aW5kb3cuaW5uZXJIZWlnaHRgLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgcGxhdGZvcm0ncyB2aWV3cG9ydCB1c2luZyBgd2luZG93LmlubmVySGVpZ2h0YC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5oZWlnaHQgPSAvKipcbiAgICAgKiBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIHBsYXRmb3JtJ3Mgdmlld3BvcnQgdXNpbmcgYHdpbmRvdy5pbm5lckhlaWdodGAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbi5pbm5lckhlaWdodDtcbiAgICB9O1xuICAgIFBsYXRmb3JtLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgUGxhdGZvcm0uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtET0NVTUVOVCxdIH1dIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqLyBQbGF0Zm9ybS5uZ0luamVjdGFibGVEZWYgPSBkZWZpbmVJbmplY3RhYmxlKHsgZmFjdG9yeTogZnVuY3Rpb24gUGxhdGZvcm1fRmFjdG9yeSgpIHsgcmV0dXJuIG5ldyBQbGF0Zm9ybShpbmplY3QoRE9DVU1FTlQpLCBpbmplY3QoTmdab25lKSk7IH0sIHRva2VuOiBQbGF0Zm9ybSwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG4gICAgcmV0dXJuIFBsYXRmb3JtO1xufSgpKTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciByZWFkUXVlcnlQYXJhbSA9ICgvKipcbiAqIEBwYXJhbSB7P30gdXJsXG4gKiBAcGFyYW0gez99IGtleVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKHVybCwga2V5KSB7XG4gICAga2V5ID0ga2V5LnJlcGxhY2UoL1tcXFtdLywgJ1xcXFxbJykucmVwbGFjZSgvW1xcXV0vLCAnXFxcXF0nKTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW1xcXFw/Jl0nICsga2V5ICsgJz0oW14mI10qKScpO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICB2YXIgcmVzdWx0cyA9IHJlZ2V4LmV4ZWModXJsKTtcbiAgICByZXR1cm4gcmVzdWx0cyA/IGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHRzWzFdLnJlcGxhY2UoL1xcKy9nLCAnICcpKSA6IG51bGw7XG59KTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBwcm94eUV2ZW50ID0gKC8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gZW1pdHRlclxuICogQHBhcmFtIHs/fSBlbFxuICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIChlbWl0dGVyLCBlbCwgZXZlbnROYW1lKSB7XG4gICAgaWYgKCgoLyoqIEB0eXBlIHs/fSAqLyAoZWwpKSkpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsICgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBldlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAvLyA/PyBjb3Jkb3ZhIG1pZ2h0IGVtaXQgXCJudWxsXCIgZXZlbnRzXG4gICAgICAgICAgICBlbWl0dGVyLm5leHQoZXYgIT0gbnVsbCA/ICgvKiogQHR5cGUgez99ICovICgoKC8qKiBAdHlwZSB7P30gKi8gKGV2KSkpLmRldGFpbCkpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIE5hdkNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmF2Q29udHJvbGxlcihwbGF0Zm9ybSwgbG9jYXRpb24sIHNlcmlhbGl6ZXIsIHJvdXRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IERFRkFVTFRfRElSRUNUSU9OO1xuICAgICAgICB0aGlzLmFuaW1hdGVkID0gREVGQVVMVF9BTklNQVRFRDtcbiAgICAgICAgdGhpcy5ndWVzc0RpcmVjdGlvbiA9ICdmb3J3YXJkJztcbiAgICAgICAgdGhpcy5sYXN0TmF2SWQgPSAtMTtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHJvdXRlciBldmVudHMgdG8gZGV0ZWN0IGRpcmVjdGlvblxuICAgICAgICBpZiAocm91dGVyKSB7XG4gICAgICAgICAgICByb3V0ZXIuZXZlbnRzLnN1YnNjcmliZSgoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGV2XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXYgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSAoZXYucmVzdG9yZWRTdGF0ZSkgPyBldi5yZXN0b3JlZFN0YXRlLm5hdmlnYXRpb25JZCA6IGV2LmlkO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ndWVzc0RpcmVjdGlvbiA9IGlkIDwgX3RoaXMubGFzdE5hdklkID8gJ2JhY2snIDogJ2ZvcndhcmQnO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ndWVzc0FuaW1hdGlvbiA9ICFldi5yZXN0b3JlZFN0YXRlID8gX3RoaXMuZ3Vlc3NEaXJlY3Rpb24gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3ROYXZJZCA9IF90aGlzLmd1ZXNzRGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyBldi5pZCA6IGlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gYmFja0J1dHRvbiBldmVudHNcbiAgICAgICAgcGxhdGZvcm0uYmFja0J1dHRvbi5zdWJzY3JpYmVXaXRoUHJpb3JpdHkoMCwgKC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucG9wKCk7IH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyBBbmd1bGFyJ3MgW1JvdXRlcl0oaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9yb3V0ZXIvUm91dGVyKSB1bmRlciB0aGUgaG9vZCxcbiAgICAgKiBpdCdzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybCgpYCwgYnV0IGl0J3MgZXhwbGljaXQgYWJvdXQgdGhlICoqZGlyZWN0aW9uKiogb2YgdGhlIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBHb2luZyAqKmZvcndhcmQqKiBtZWFucyB0aGF0IGEgbmV3IHBhZ2UgaXMgZ29pbmcgdG8gYmUgcHVzaGVkIHRvIHRoZSBzdGFjayBvZiB0aGUgb3V0bGV0IChpb24tcm91dGVyLW91dGxldCksXG4gICAgICogYW5kIHRoYXQgaXQgd2lsbCBzaG93IGEgXCJmb3J3YXJkXCIgYW5pbWF0aW9uIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBOYXZpZ2F0aW5nIGZvcndhcmQgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIGluIGEgZGVjbGFyYXRpdmUgbWFubmVyIGJ5IHVzaW5nIHRoZSBgW3JvdXRlckRpcmVjdGlvbl1gIGRpcmVjdGl2ZTpcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8YSByb3V0ZXJMaW5rPVwiL3BhdGgvdG8vcGFnZVwiIHJvdXRlckRpcmVjdGlvbj1cImZvcndhcmRcIj5MaW5rPC9hPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgQW5ndWxhcidzIFtSb3V0ZXJdKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvcm91dGVyL1JvdXRlcikgdW5kZXIgdGhlIGhvb2QsXG4gICAgICogaXQncyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgYHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwoKWAsIGJ1dCBpdCdzIGV4cGxpY2l0IGFib3V0IHRoZSAqKmRpcmVjdGlvbioqIG9mIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogR29pbmcgKipmb3J3YXJkKiogbWVhbnMgdGhhdCBhIG5ldyBwYWdlIGlzIGdvaW5nIHRvIGJlIHB1c2hlZCB0byB0aGUgc3RhY2sgb2YgdGhlIG91dGxldCAoaW9uLXJvdXRlci1vdXRsZXQpLFxuICAgICAqIGFuZCB0aGF0IGl0IHdpbGwgc2hvdyBhIFwiZm9yd2FyZFwiIGFuaW1hdGlvbiBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogTmF2aWdhdGluZyBmb3J3YXJkIGNhbiBhbHNvIGJlIHRyaWdnZXJlZCBpbiBhIGRlY2xhcmF0aXZlIG1hbm5lciBieSB1c2luZyB0aGUgYFtyb3V0ZXJEaXJlY3Rpb25dYCBkaXJlY3RpdmU6XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGEgcm91dGVyTGluaz1cIi9wYXRoL3RvL3BhZ2VcIiByb3V0ZXJEaXJlY3Rpb249XCJmb3J3YXJkXCI+TGluazwvYT5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdkNvbnRyb2xsZXIucHJvdG90eXBlLm5hdmlnYXRlRm9yd2FyZCA9IC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgQW5ndWxhcidzIFtSb3V0ZXJdKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvcm91dGVyL1JvdXRlcikgdW5kZXIgdGhlIGhvb2QsXG4gICAgICogaXQncyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgYHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwoKWAsIGJ1dCBpdCdzIGV4cGxpY2l0IGFib3V0IHRoZSAqKmRpcmVjdGlvbioqIG9mIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogR29pbmcgKipmb3J3YXJkKiogbWVhbnMgdGhhdCBhIG5ldyBwYWdlIGlzIGdvaW5nIHRvIGJlIHB1c2hlZCB0byB0aGUgc3RhY2sgb2YgdGhlIG91dGxldCAoaW9uLXJvdXRlci1vdXRsZXQpLFxuICAgICAqIGFuZCB0aGF0IGl0IHdpbGwgc2hvdyBhIFwiZm9yd2FyZFwiIGFuaW1hdGlvbiBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogTmF2aWdhdGluZyBmb3J3YXJkIGNhbiBhbHNvIGJlIHRyaWdnZXJlZCBpbiBhIGRlY2xhcmF0aXZlIG1hbm5lciBieSB1c2luZyB0aGUgYFtyb3V0ZXJEaXJlY3Rpb25dYCBkaXJlY3RpdmU6XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGEgcm91dGVyTGluaz1cIi9wYXRoL3RvL3BhZ2VcIiByb3V0ZXJEaXJlY3Rpb249XCJmb3J3YXJkXCI+TGluazwvYT5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5zZXREaXJlY3Rpb24oJ2ZvcndhcmQnLCBvcHRpb25zLmFuaW1hdGVkLCBvcHRpb25zLmFuaW1hdGlvbkRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRlKHVybCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1c2VzIEFuZ3VsYXIncyBbUm91dGVyXShodHRwczovL2FuZ3VsYXIuaW8vYXBpL3JvdXRlci9Sb3V0ZXIpIHVuZGVyIHRoZSBob29kLFxuICAgICAqIGl0J3MgZXF1aXZhbGVudCB0byBjYWxsaW5nOlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiB0aGlzLm5hdkNvbnRyb2xsZXIuc2V0RGlyZWN0aW9uKCdiYWNrJyk7XG4gICAgICogdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybChwYXRoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEdvaW5nICoqYmFjayoqIG1lYW5zIHRoYXQgYWxsIHRoZSBwYWdlcyBpbiB0aGUgc3RhY2sgdW50aWwgdGhlIG5hdmlnYXRlZCBwYWdlIGlzIGZvdW5kIHdpbGwgYmUgcG9wcGVkLFxuICAgICAqIGFuZCB0aGF0IGl0IHdpbGwgc2hvdyBhIFwiYmFja1wiIGFuaW1hdGlvbiBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogTmF2aWdhdGluZyBiYWNrIGNhbiBhbHNvIGJlIHRyaWdnZXJlZCBpbiBhIGRlY2xhcmF0aXZlIG1hbm5lciBieSB1c2luZyB0aGUgYFtyb3V0ZXJEaXJlY3Rpb25dYCBkaXJlY3RpdmU6XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGEgcm91dGVyTGluaz1cIi9wYXRoL3RvL3BhZ2VcIiByb3V0ZXJEaXJlY3Rpb249XCJiYWNrXCI+TGluazwvYT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1c2VzIEFuZ3VsYXIncyBbUm91dGVyXShodHRwczovL2FuZ3VsYXIuaW8vYXBpL3JvdXRlci9Sb3V0ZXIpIHVuZGVyIHRoZSBob29kLFxuICAgICAqIGl0J3MgZXF1aXZhbGVudCB0byBjYWxsaW5nOlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiB0aGlzLm5hdkNvbnRyb2xsZXIuc2V0RGlyZWN0aW9uKCdiYWNrJyk7XG4gICAgICogdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybChwYXRoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEdvaW5nICoqYmFjayoqIG1lYW5zIHRoYXQgYWxsIHRoZSBwYWdlcyBpbiB0aGUgc3RhY2sgdW50aWwgdGhlIG5hdmlnYXRlZCBwYWdlIGlzIGZvdW5kIHdpbGwgYmUgcG9wcGVkLFxuICAgICAqIGFuZCB0aGF0IGl0IHdpbGwgc2hvdyBhIFwiYmFja1wiIGFuaW1hdGlvbiBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogTmF2aWdhdGluZyBiYWNrIGNhbiBhbHNvIGJlIHRyaWdnZXJlZCBpbiBhIGRlY2xhcmF0aXZlIG1hbm5lciBieSB1c2luZyB0aGUgYFtyb3V0ZXJEaXJlY3Rpb25dYCBkaXJlY3RpdmU6XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGEgcm91dGVyTGluaz1cIi9wYXRoL3RvL3BhZ2VcIiByb3V0ZXJEaXJlY3Rpb249XCJiYWNrXCI+TGluazwvYT5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdkNvbnRyb2xsZXIucHJvdG90eXBlLm5hdmlnYXRlQmFjayA9IC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgQW5ndWxhcidzIFtSb3V0ZXJdKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvcm91dGVyL1JvdXRlcikgdW5kZXIgdGhlIGhvb2QsXG4gICAgICogaXQncyBlcXVpdmFsZW50IHRvIGNhbGxpbmc6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIHRoaXMubmF2Q29udHJvbGxlci5zZXREaXJlY3Rpb24oJ2JhY2snKTtcbiAgICAgKiB0aGlzLnJvdXRlci5uYXZpZ2F0ZUJ5VXJsKHBhdGgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogR29pbmcgKipiYWNrKiogbWVhbnMgdGhhdCBhbGwgdGhlIHBhZ2VzIGluIHRoZSBzdGFjayB1bnRpbCB0aGUgbmF2aWdhdGVkIHBhZ2UgaXMgZm91bmQgd2lsbCBiZSBwb3BwZWQsXG4gICAgICogYW5kIHRoYXQgaXQgd2lsbCBzaG93IGEgXCJiYWNrXCIgYW5pbWF0aW9uIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBOYXZpZ2F0aW5nIGJhY2sgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIGluIGEgZGVjbGFyYXRpdmUgbWFubmVyIGJ5IHVzaW5nIHRoZSBgW3JvdXRlckRpcmVjdGlvbl1gIGRpcmVjdGl2ZTpcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8YSByb3V0ZXJMaW5rPVwiL3BhdGgvdG8vcGFnZVwiIHJvdXRlckRpcmVjdGlvbj1cImJhY2tcIj5MaW5rPC9hPlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLnNldERpcmVjdGlvbignYmFjaycsIG9wdGlvbnMuYW5pbWF0ZWQsIG9wdGlvbnMuYW5pbWF0aW9uRGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGUodXJsLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgQW5ndWxhcidzIFtSb3V0ZXJdKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvcm91dGVyL1JvdXRlcikgdW5kZXIgdGhlIGhvb2QsXG4gICAgICogaXQncyBlcXVpdmFsZW50IHRvIGNhbGxpbmc6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIHRoaXMubmF2Q29udHJvbGxlci5zZXREaXJlY3Rpb24oJ3Jvb3QnKTtcbiAgICAgKiB0aGlzLnJvdXRlci5uYXZpZ2F0ZUJ5VXJsKHBhdGgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogR29pbmcgKipyb290KiogbWVhbnMgdGhhdCBhbGwgZXhpc3RpbmcgcGFnZXMgaW4gdGhlIHN0YWNrIHdpbGwgYmUgcmVtb3ZlZCxcbiAgICAgKiBhbmQgdGhlIG5hdmlnYXRlZCBwYWdlIHdpbGwgYmVjb21lIHRoZSBzaW5nbGUgcGFnZSBpbiB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBOYXZpZ2F0aW5nIHJvb3QgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIGluIGEgZGVjbGFyYXRpdmUgbWFubmVyIGJ5IHVzaW5nIHRoZSBgW3JvdXRlckRpcmVjdGlvbl1gIGRpcmVjdGl2ZTpcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8YSByb3V0ZXJMaW5rPVwiL3BhdGgvdG8vcGFnZVwiIHJvdXRlckRpcmVjdGlvbj1cInJvb3RcIj5MaW5rPC9hPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgQW5ndWxhcidzIFtSb3V0ZXJdKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvcm91dGVyL1JvdXRlcikgdW5kZXIgdGhlIGhvb2QsXG4gICAgICogaXQncyBlcXVpdmFsZW50IHRvIGNhbGxpbmc6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIHRoaXMubmF2Q29udHJvbGxlci5zZXREaXJlY3Rpb24oJ3Jvb3QnKTtcbiAgICAgKiB0aGlzLnJvdXRlci5uYXZpZ2F0ZUJ5VXJsKHBhdGgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogR29pbmcgKipyb290KiogbWVhbnMgdGhhdCBhbGwgZXhpc3RpbmcgcGFnZXMgaW4gdGhlIHN0YWNrIHdpbGwgYmUgcmVtb3ZlZCxcbiAgICAgKiBhbmQgdGhlIG5hdmlnYXRlZCBwYWdlIHdpbGwgYmVjb21lIHRoZSBzaW5nbGUgcGFnZSBpbiB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBOYXZpZ2F0aW5nIHJvb3QgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIGluIGEgZGVjbGFyYXRpdmUgbWFubmVyIGJ5IHVzaW5nIHRoZSBgW3JvdXRlckRpcmVjdGlvbl1gIGRpcmVjdGl2ZTpcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8YSByb3V0ZXJMaW5rPVwiL3BhdGgvdG8vcGFnZVwiIHJvdXRlckRpcmVjdGlvbj1cInJvb3RcIj5MaW5rPC9hPlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF2Q29udHJvbGxlci5wcm90b3R5cGUubmF2aWdhdGVSb290ID0gLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyBBbmd1bGFyJ3MgW1JvdXRlcl0oaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9yb3V0ZXIvUm91dGVyKSB1bmRlciB0aGUgaG9vZCxcbiAgICAgKiBpdCdzIGVxdWl2YWxlbnQgdG8gY2FsbGluZzpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogdGhpcy5uYXZDb250cm9sbGVyLnNldERpcmVjdGlvbigncm9vdCcpO1xuICAgICAqIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwocGF0aCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBHb2luZyAqKnJvb3QqKiBtZWFucyB0aGF0IGFsbCBleGlzdGluZyBwYWdlcyBpbiB0aGUgc3RhY2sgd2lsbCBiZSByZW1vdmVkLFxuICAgICAqIGFuZCB0aGUgbmF2aWdhdGVkIHBhZ2Ugd2lsbCBiZWNvbWUgdGhlIHNpbmdsZSBwYWdlIGluIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIE5hdmlnYXRpbmcgcm9vdCBjYW4gYWxzbyBiZSB0cmlnZ2VyZWQgaW4gYSBkZWNsYXJhdGl2ZSBtYW5uZXIgYnkgdXNpbmcgdGhlIGBbcm91dGVyRGlyZWN0aW9uXWAgZGlyZWN0aXZlOlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxhIHJvdXRlckxpbms9XCIvcGF0aC90by9wYWdlXCIgcm91dGVyRGlyZWN0aW9uPVwicm9vdFwiPkxpbms8L2E+XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKCdyb290Jywgb3B0aW9ucy5hbmltYXRlZCwgb3B0aW9ucy5hbmltYXRpb25EaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZSh1cmwsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBbTG9jYXRpb25dKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvY29tbW9uL0xvY2F0aW9uKSdzIGJhY2soKSBtZXRob2QuXG4gICAgICogSXQgd2lsbCB1c2UgdGhlIHN0YW5kYXJkIGB3aW5kb3cuaGlzdG9yeS5iYWNrKClgIHVuZGVyIHRoZSBob29kLCBidXQgZmVhdHVyaW5nIGEgYGJhY2tgIGFuaW1hdGlvblxuICAgICAqIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBbTG9jYXRpb25dKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvY29tbW9uL0xvY2F0aW9uKSdzIGJhY2soKSBtZXRob2QuXG4gICAgICogSXQgd2lsbCB1c2UgdGhlIHN0YW5kYXJkIGB3aW5kb3cuaGlzdG9yeS5iYWNrKClgIHVuZGVyIHRoZSBob29kLCBidXQgZmVhdHVyaW5nIGEgYGJhY2tgIGFuaW1hdGlvblxuICAgICAqIGJ5IGRlZmF1bHQuXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF2Q29udHJvbGxlci5wcm90b3R5cGUuYmFjayA9IC8qKlxuICAgICAqIFNhbWUgYXMgW0xvY2F0aW9uXShodHRwczovL2FuZ3VsYXIuaW8vYXBpL2NvbW1vbi9Mb2NhdGlvbikncyBiYWNrKCkgbWV0aG9kLlxuICAgICAqIEl0IHdpbGwgdXNlIHRoZSBzdGFuZGFyZCBgd2luZG93Lmhpc3RvcnkuYmFjaygpYCB1bmRlciB0aGUgaG9vZCwgYnV0IGZlYXR1cmluZyBhIGBiYWNrYCBhbmltYXRpb25cbiAgICAgKiBieSBkZWZhdWx0LlxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgYW5pbWF0ZWQ6IHRydWUsIGFuaW1hdGlvbkRpcmVjdGlvbjogJ2JhY2snIH07IH1cbiAgICAgICAgdGhpcy5zZXREaXJlY3Rpb24oJ2JhY2snLCBvcHRpb25zLmFuaW1hdGVkLCBvcHRpb25zLmFuaW1hdGlvbkRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLmJhY2soKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kcyBnb2VzIGJhY2sgaW4gdGhlIGNvbnRleHQgb2YgSW9uaWMncyBzdGFjayBuYXZpZ2F0aW9uLlxuICAgICAqXG4gICAgICogSXQgcmVjdXJzaXZlbHkgZmluZHMgdGhlIHRvcCBhY3RpdmUgYGlvbi1yb3V0ZXItb3V0bGV0YCBhbmQgY2FsbHMgYHBvcCgpYC5cbiAgICAgKiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gZ28gYmFjayB3aGVuIHlvdSBhcmUgdXNpbmcgYGlvbi1yb3V0ZXItb3V0bGV0YC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZHMgZ29lcyBiYWNrIGluIHRoZSBjb250ZXh0IG9mIElvbmljJ3Mgc3RhY2sgbmF2aWdhdGlvbi5cbiAgICAgKlxuICAgICAqIEl0IHJlY3Vyc2l2ZWx5IGZpbmRzIHRoZSB0b3AgYWN0aXZlIGBpb24tcm91dGVyLW91dGxldGAgYW5kIGNhbGxzIGBwb3AoKWAuXG4gICAgICogVGhpcyBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIGdvIGJhY2sgd2hlbiB5b3UgYXJlIHVzaW5nIGBpb24tcm91dGVyLW91dGxldGAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXZDb250cm9sbGVyLnByb3RvdHlwZS5wb3AgPSAvKipcbiAgICAgKiBUaGlzIG1ldGhvZHMgZ29lcyBiYWNrIGluIHRoZSBjb250ZXh0IG9mIElvbmljJ3Mgc3RhY2sgbmF2aWdhdGlvbi5cbiAgICAgKlxuICAgICAqIEl0IHJlY3Vyc2l2ZWx5IGZpbmRzIHRoZSB0b3AgYWN0aXZlIGBpb24tcm91dGVyLW91dGxldGAgYW5kIGNhbGxzIGBwb3AoKWAuXG4gICAgICogVGhpcyBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIGdvIGJhY2sgd2hlbiB5b3UgYXJlIHVzaW5nIGBpb24tcm91dGVyLW91dGxldGAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdXRsZXQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsZXQgPSB0aGlzLnRvcE91dGxldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdXRsZXQpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgb3V0bGV0LnBvcCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9hLnNlbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGV0ID0gb3V0bGV0LnBhcmVudE91dGxldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZHMgc3BlY2lmaWVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG5leHQgbmF2aWdhdGlvbiBwZXJmb3JtZWQgYnkgdGhlIEFuZ3VsYXIgcm91dGVyLlxuICAgICAqXG4gICAgICogYHNldERpcmVjdGlvbigpYCBkb2VzIG5vdCB0cmlnZ2VyIGFueSB0cmFuc2l0aW9uLCBpdCBqdXN0IHNldHMgc29tZSBmbGFncyB0byBiZSBjb25zdW1lZCBieSBgaW9uLXJvdXRlci1vdXRsZXRgLlxuICAgICAqXG4gICAgICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgYG5hdmlnYXRlRm9yd2FyZCgpYCwgYG5hdmlnYXRlQmFjaygpYCBhbmQgYG5hdmlnYXRlUm9vdCgpYCBpbnN0ZWFkIG9mIGBzZXREaXJlY3Rpb24oKWAuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2RzIHNwZWNpZmllcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBuZXh0IG5hdmlnYXRpb24gcGVyZm9ybWVkIGJ5IHRoZSBBbmd1bGFyIHJvdXRlci5cbiAgICAgKlxuICAgICAqIGBzZXREaXJlY3Rpb24oKWAgZG9lcyBub3QgdHJpZ2dlciBhbnkgdHJhbnNpdGlvbiwgaXQganVzdCBzZXRzIHNvbWUgZmxhZ3MgdG8gYmUgY29uc3VtZWQgYnkgYGlvbi1yb3V0ZXItb3V0bGV0YC5cbiAgICAgKlxuICAgICAqIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIGBuYXZpZ2F0ZUZvcndhcmQoKWAsIGBuYXZpZ2F0ZUJhY2soKWAgYW5kIGBuYXZpZ2F0ZVJvb3QoKWAgaW5zdGVhZCBvZiBgc2V0RGlyZWN0aW9uKClgLlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gYW5pbWF0ZWRcbiAgICAgKiBAcGFyYW0gez89fSBhbmltYXRpb25EaXJlY3Rpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdkNvbnRyb2xsZXIucHJvdG90eXBlLnNldERpcmVjdGlvbiA9IC8qKlxuICAgICAqIFRoaXMgbWV0aG9kcyBzcGVjaWZpZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgbmV4dCBuYXZpZ2F0aW9uIHBlcmZvcm1lZCBieSB0aGUgQW5ndWxhciByb3V0ZXIuXG4gICAgICpcbiAgICAgKiBgc2V0RGlyZWN0aW9uKClgIGRvZXMgbm90IHRyaWdnZXIgYW55IHRyYW5zaXRpb24sIGl0IGp1c3Qgc2V0cyBzb21lIGZsYWdzIHRvIGJlIGNvbnN1bWVkIGJ5IGBpb24tcm91dGVyLW91dGxldGAuXG4gICAgICpcbiAgICAgKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSBgbmF2aWdhdGVGb3J3YXJkKClgLCBgbmF2aWdhdGVCYWNrKClgIGFuZCBgbmF2aWdhdGVSb290KClgIGluc3RlYWQgb2YgYHNldERpcmVjdGlvbigpYC5cbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGFuaW1hdGVkXG4gICAgICogQHBhcmFtIHs/PX0gYW5pbWF0aW9uRGlyZWN0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZGlyZWN0aW9uLCBhbmltYXRlZCwgYW5pbWF0aW9uRGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLmFuaW1hdGVkID0gZ2V0QW5pbWF0aW9uKGRpcmVjdGlvbiwgYW5pbWF0ZWQsIGFuaW1hdGlvbkRpcmVjdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gb3V0bGV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXZDb250cm9sbGVyLnByb3RvdHlwZS5zZXRUb3BPdXRsZXQgPSAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gb3V0bGV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAob3V0bGV0KSB7XG4gICAgICAgIHRoaXMudG9wT3V0bGV0ID0gb3V0bGV0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdkNvbnRyb2xsZXIucHJvdG90eXBlLmNvbnN1bWVUcmFuc2l0aW9uID0gLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gJ3Jvb3QnO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBhbmltYXRpb247XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLmd1ZXNzRGlyZWN0aW9uO1xuICAgICAgICAgICAgYW5pbWF0aW9uID0gdGhpcy5ndWVzc0FuaW1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0ZWQ7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IERFRkFVTFRfRElSRUNUSU9OO1xuICAgICAgICB0aGlzLmFuaW1hdGVkID0gREVGQVVMVF9BTklNQVRFRDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiBhbmltYXRpb25cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdkNvbnRyb2xsZXIucHJvdG90eXBlLm5hdmlnYXRlID0gLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMucm91dGVyKSkubmF2aWdhdGUodXJsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbmF2aWdhdGVCeVVybCBpZ25vcmVzIGFueSBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgICAgICAgICAqIHdvdWxkIGNoYW5nZSB0aGUgdXJsLCBzbyB0aGluZ3MgbGlrZSBxdWVyeVBhcmFtc1xuICAgICAgICAgICAgICogd291bGQgYmUgaWdub3JlZCB1bmxlc3Mgd2UgY3JlYXRlIGEgdXJsIHRyZWVcbiAgICAgICAgICAgICAqIE1vcmUgSW5mbzogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTg3OThcbiAgICAgICAgICAgICAqIEB0eXBlIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgdXJsVHJlZSA9IHRoaXMuc2VyaWFsaXplci5wYXJzZSh1cmwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5xdWVyeVBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdXJsVHJlZS5xdWVyeVBhcmFtcyA9IF9fYXNzaWduKHt9LCBvcHRpb25zLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1cmxUcmVlLmZyYWdtZW50ID0gb3B0aW9ucy5mcmFnbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogYG5hdmlnYXRlQnlVcmxgIHdpbGwgc3RpbGwgYXBwbHkgYE5hdmlnYXRpb25FeHRyYXNgIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAqIHRoYXQgZG8gbm90IG1vZGlmeSB0aGUgdXJsLCBzdWNoIGFzIGByZXBsYWNlVXJsYCB3aGljaCBpcyB3aHlcbiAgICAgICAgICAgICAqIGBvcHRpb25zYCBpcyBwYXNzZWQgaW4gaGVyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgez99ICovICh0aGlzLnJvdXRlcikpLm5hdmlnYXRlQnlVcmwodXJsVHJlZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5hdkNvbnRyb2xsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBOYXZDb250cm9sbGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IFBsYXRmb3JtIH0sXG4gICAgICAgIHsgdHlwZTogTG9jYXRpb24gfSxcbiAgICAgICAgeyB0eXBlOiBVcmxTZXJpYWxpemVyIH0sXG4gICAgICAgIHsgdHlwZTogUm91dGVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG4gICAgXTsgfTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi8gTmF2Q29udHJvbGxlci5uZ0luamVjdGFibGVEZWYgPSBkZWZpbmVJbmplY3RhYmxlKHsgZmFjdG9yeTogZnVuY3Rpb24gTmF2Q29udHJvbGxlcl9GYWN0b3J5KCkgeyByZXR1cm4gbmV3IE5hdkNvbnRyb2xsZXIoaW5qZWN0KFBsYXRmb3JtKSwgaW5qZWN0KExvY2F0aW9uKSwgaW5qZWN0KFVybFNlcmlhbGl6ZXIpLCBpbmplY3QoUm91dGVyLCA4KSk7IH0sIHRva2VuOiBOYXZDb250cm9sbGVyLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbiAgICByZXR1cm4gTmF2Q29udHJvbGxlcjtcbn0oKSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgZ2V0QW5pbWF0aW9uID0gKC8qKlxuICogQHBhcmFtIHs/fSBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7P30gYW5pbWF0ZWRcbiAqIEBwYXJhbSB7P30gYW5pbWF0aW9uRGlyZWN0aW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiAoZGlyZWN0aW9uLCBhbmltYXRlZCwgYW5pbWF0aW9uRGlyZWN0aW9uKSB7XG4gICAgaWYgKGFuaW1hdGVkID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRGlyZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbkRpcmVjdGlvbjtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnIHx8IGRpcmVjdGlvbiA9PT0gJ2JhY2snKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3Jvb3QnICYmIGFuaW1hdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAnZm9yd2FyZCc7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59KTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBERUZBVUxUX0RJUkVDVElPTiA9ICdhdXRvJztcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBERUZBVUxUX0FOSU1BVEVEID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqIEB0eXBlIHs/fSAqL1xudmFyIHByb3h5SW5wdXRzID0gKC8qKlxuICogQHBhcmFtIHs/fSBDbXBcbiAqIEBwYXJhbSB7P30gaW5wdXRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiAoQ21wLCBpbnB1dHMpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgdmFyIFByb3RvdHlwZSA9IENtcC5wcm90b3R5cGU7XG4gICAgaW5wdXRzLmZvckVhY2goKC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXRlbVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3RvdHlwZSwgaXRlbSwge1xuICAgICAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZWxbaXRlbV07IH0sXG4gICAgICAgICAgICBzZXQ6IC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB2YWxcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuei5ydW5PdXRzaWRlQW5ndWxhcigoLyoqXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5lbFtpdGVtXSA9IHZhbDsgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgcHJveHlNZXRob2RzID0gKC8qKlxuICogQHBhcmFtIHs/fSBDbXBcbiAqIEBwYXJhbSB7P30gbWV0aG9kc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKENtcCwgbWV0aG9kcykge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICB2YXIgUHJvdG90eXBlID0gQ21wLnByb3RvdHlwZTtcbiAgICBtZXRob2RzLmZvckVhY2goKC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0aG9kTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgUHJvdG90eXBlW21ldGhvZE5hbWVdID0gKC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuei5ydW5PdXRzaWRlQW5ndWxhcigoLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5lbFttZXRob2ROYW1lXS5hcHBseShfdGhpcy5lbCwgYXJncyk7IH0pKTtcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgcHJveHlPdXRwdXRzID0gKC8qKlxuICogQHBhcmFtIHs/fSBpbnN0YW5jZVxuICogQHBhcmFtIHs/fSBlbFxuICogQHBhcmFtIHs/fSBldmVudHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIChpbnN0YW5jZSwgZWwsIGV2ZW50cykge1xuICAgIGV2ZW50cy5mb3JFYWNoKCgvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGV2ZW50TmFtZSkgeyByZXR1cm4gaW5zdGFuY2VbZXZlbnROYW1lXSA9IGZyb21FdmVudChlbCwgZXZlbnROYW1lKTsgfSkpO1xufSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgSW9uQXBwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkFwcChjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvbkFwcC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tYXBwJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25BcHAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25BcHA7XG59KCkpO1xudmFyIElvbkF2YXRhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25BdmF0YXIoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25BdmF0YXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWF2YXRhcicsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uQXZhdGFyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uQXZhdGFyO1xufSgpKTtcbnZhciBJb25CYWNrQnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkJhY2tCdXR0b24oYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25CYWNrQnV0dG9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1iYWNrLWJ1dHRvbicsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnY29sb3InLCAnZGVmYXVsdEhyZWYnLCAnZGlzYWJsZWQnLCAnaWNvbicsICdtb2RlJywgJ3RleHQnLCAndHlwZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uQmFja0J1dHRvbi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvbkJhY2tCdXR0b247XG59KCkpO1xucHJveHlJbnB1dHMoSW9uQmFja0J1dHRvbiwgWydjb2xvcicsICdkZWZhdWx0SHJlZicsICdkaXNhYmxlZCcsICdpY29uJywgJ21vZGUnLCAndGV4dCcsICd0eXBlJ10pO1xudmFyIElvbkJhY2tkcm9wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkJhY2tkcm9wKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uQmFja2Ryb3BUYXAnXSk7XG4gICAgfVxuICAgIElvbkJhY2tkcm9wLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1iYWNrZHJvcCcsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnc3RvcFByb3BhZ2F0aW9uJywgJ3RhcHBhYmxlJywgJ3Zpc2libGUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvbkJhY2tkcm9wLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uQmFja2Ryb3A7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uQmFja2Ryb3AsIFsnc3RvcFByb3BhZ2F0aW9uJywgJ3RhcHBhYmxlJywgJ3Zpc2libGUnXSk7XG52YXIgSW9uQmFkZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uQmFkZ2UoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25CYWRnZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tYmFkZ2UnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2NvbG9yJywgJ21vZGUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvbkJhZGdlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uQmFkZ2U7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uQmFkZ2UsIFsnY29sb3InLCAnbW9kZSddKTtcbnZhciBJb25CdXR0b24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uQnV0dG9uKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uRm9jdXMnLCAnaW9uQmx1ciddKTtcbiAgICB9XG4gICAgSW9uQnV0dG9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1idXR0b24nLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2J1dHRvblR5cGUnLCAnY29sb3InLCAnZGlzYWJsZWQnLCAnZG93bmxvYWQnLCAnZXhwYW5kJywgJ2ZpbGwnLCAnaHJlZicsICdtb2RlJywgJ3JlbCcsICdyb3V0ZXJEaXJlY3Rpb24nLCAnc2hhcGUnLCAnc2l6ZScsICdzdHJvbmcnLCAndGFyZ2V0JywgJ3R5cGUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvbkJ1dHRvbi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvbkJ1dHRvbjtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25CdXR0b24sIFsnYnV0dG9uVHlwZScsICdjb2xvcicsICdkaXNhYmxlZCcsICdkb3dubG9hZCcsICdleHBhbmQnLCAnZmlsbCcsICdocmVmJywgJ21vZGUnLCAncmVsJywgJ3JvdXRlckRpcmVjdGlvbicsICdzaGFwZScsICdzaXplJywgJ3N0cm9uZycsICd0YXJnZXQnLCAndHlwZSddKTtcbnZhciBJb25CdXR0b25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkJ1dHRvbnMoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25CdXR0b25zLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1idXR0b25zJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb2xsYXBzZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uQnV0dG9ucy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvbkJ1dHRvbnM7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uQnV0dG9ucywgWydjb2xsYXBzZSddKTtcbnZhciBJb25DYXJkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkNhcmQoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25DYXJkLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1jYXJkJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydidXR0b24nLCAnY29sb3InLCAnZGlzYWJsZWQnLCAnZG93bmxvYWQnLCAnaHJlZicsICdtb2RlJywgJ3JlbCcsICdyb3V0ZXJEaXJlY3Rpb24nLCAndGFyZ2V0JywgJ3R5cGUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvbkNhcmQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25DYXJkO1xufSgpKTtcbnByb3h5SW5wdXRzKElvbkNhcmQsIFsnYnV0dG9uJywgJ2NvbG9yJywgJ2Rpc2FibGVkJywgJ2Rvd25sb2FkJywgJ2hyZWYnLCAnbW9kZScsICdyZWwnLCAncm91dGVyRGlyZWN0aW9uJywgJ3RhcmdldCcsICd0eXBlJ10pO1xudmFyIElvbkNhcmRDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkNhcmRDb250ZW50KGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgSW9uQ2FyZENvbnRlbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWNhcmQtY29udGVudCcsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnbW9kZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uQ2FyZENvbnRlbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25DYXJkQ29udGVudDtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25DYXJkQ29udGVudCwgWydtb2RlJ10pO1xudmFyIElvbkNhcmRIZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uQ2FyZEhlYWRlcihjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvbkNhcmRIZWFkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWNhcmQtaGVhZGVyJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb2xvcicsICdtb2RlJywgJ3RyYW5zbHVjZW50J10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25DYXJkSGVhZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uQ2FyZEhlYWRlcjtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25DYXJkSGVhZGVyLCBbJ2NvbG9yJywgJ21vZGUnLCAndHJhbnNsdWNlbnQnXSk7XG52YXIgSW9uQ2FyZFN1YnRpdGxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkNhcmRTdWJ0aXRsZShjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvbkNhcmRTdWJ0aXRsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tY2FyZC1zdWJ0aXRsZScsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnY29sb3InLCAnbW9kZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uQ2FyZFN1YnRpdGxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uQ2FyZFN1YnRpdGxlO1xufSgpKTtcbnByb3h5SW5wdXRzKElvbkNhcmRTdWJ0aXRsZSwgWydjb2xvcicsICdtb2RlJ10pO1xudmFyIElvbkNhcmRUaXRsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25DYXJkVGl0bGUoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25DYXJkVGl0bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWNhcmQtdGl0bGUnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2NvbG9yJywgJ21vZGUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvbkNhcmRUaXRsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvbkNhcmRUaXRsZTtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25DYXJkVGl0bGUsIFsnY29sb3InLCAnbW9kZSddKTtcbnZhciBJb25DaGVja2JveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25DaGVja2JveChjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHByb3h5T3V0cHV0cyh0aGlzLCB0aGlzLmVsLCBbJ2lvbkNoYW5nZScsICdpb25Gb2N1cycsICdpb25CbHVyJ10pO1xuICAgIH1cbiAgICBJb25DaGVja2JveC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tY2hlY2tib3gnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2NoZWNrZWQnLCAnY29sb3InLCAnZGlzYWJsZWQnLCAnaW5kZXRlcm1pbmF0ZScsICdtb2RlJywgJ25hbWUnLCAndmFsdWUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvbkNoZWNrYm94LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uQ2hlY2tib3g7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uQ2hlY2tib3gsIFsnY2hlY2tlZCcsICdjb2xvcicsICdkaXNhYmxlZCcsICdpbmRldGVybWluYXRlJywgJ21vZGUnLCAnbmFtZScsICd2YWx1ZSddKTtcbnZhciBJb25DaGlwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkNoaXAoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25DaGlwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1jaGlwJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb2xvcicsICdtb2RlJywgJ291dGxpbmUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvbkNoaXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25DaGlwO1xufSgpKTtcbnByb3h5SW5wdXRzKElvbkNoaXAsIFsnY29sb3InLCAnbW9kZScsICdvdXRsaW5lJ10pO1xudmFyIElvbkNvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25Db2woYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25Db2wuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWNvbCcsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnb2Zmc2V0JywgJ29mZnNldExnJywgJ29mZnNldE1kJywgJ29mZnNldFNtJywgJ29mZnNldFhsJywgJ29mZnNldFhzJywgJ3B1bGwnLCAncHVsbExnJywgJ3B1bGxNZCcsICdwdWxsU20nLCAncHVsbFhsJywgJ3B1bGxYcycsICdwdXNoJywgJ3B1c2hMZycsICdwdXNoTWQnLCAncHVzaFNtJywgJ3B1c2hYbCcsICdwdXNoWHMnLCAnc2l6ZScsICdzaXplTGcnLCAnc2l6ZU1kJywgJ3NpemVTbScsICdzaXplWGwnLCAnc2l6ZVhzJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25Db2wuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25Db2w7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uQ29sLCBbJ29mZnNldCcsICdvZmZzZXRMZycsICdvZmZzZXRNZCcsICdvZmZzZXRTbScsICdvZmZzZXRYbCcsICdvZmZzZXRYcycsICdwdWxsJywgJ3B1bGxMZycsICdwdWxsTWQnLCAncHVsbFNtJywgJ3B1bGxYbCcsICdwdWxsWHMnLCAncHVzaCcsICdwdXNoTGcnLCAncHVzaE1kJywgJ3B1c2hTbScsICdwdXNoWGwnLCAncHVzaFhzJywgJ3NpemUnLCAnc2l6ZUxnJywgJ3NpemVNZCcsICdzaXplU20nLCAnc2l6ZVhsJywgJ3NpemVYcyddKTtcbnZhciBJb25Db250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkNvbnRlbnQoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgICAgICBwcm94eU91dHB1dHModGhpcywgdGhpcy5lbCwgWydpb25TY3JvbGxTdGFydCcsICdpb25TY3JvbGwnLCAnaW9uU2Nyb2xsRW5kJ10pO1xuICAgIH1cbiAgICBJb25Db250ZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1jb250ZW50JywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb2xvcicsICdmb3JjZU92ZXJzY3JvbGwnLCAnZnVsbHNjcmVlbicsICdzY3JvbGxFdmVudHMnLCAnc2Nyb2xsWCcsICdzY3JvbGxZJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25Db250ZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uQ29udGVudDtcbn0oKSk7XG5wcm94eU1ldGhvZHMoSW9uQ29udGVudCwgWydnZXRTY3JvbGxFbGVtZW50JywgJ3Njcm9sbFRvVG9wJywgJ3Njcm9sbFRvQm90dG9tJywgJ3Njcm9sbEJ5UG9pbnQnLCAnc2Nyb2xsVG9Qb2ludCddKTtcbnByb3h5SW5wdXRzKElvbkNvbnRlbnQsIFsnY29sb3InLCAnZm9yY2VPdmVyc2Nyb2xsJywgJ2Z1bGxzY3JlZW4nLCAnc2Nyb2xsRXZlbnRzJywgJ3Njcm9sbFgnLCAnc2Nyb2xsWSddKTtcbnZhciBJb25EYXRldGltZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25EYXRldGltZShjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHByb3h5T3V0cHV0cyh0aGlzLCB0aGlzLmVsLCBbJ2lvbkNhbmNlbCcsICdpb25DaGFuZ2UnLCAnaW9uRm9jdXMnLCAnaW9uQmx1ciddKTtcbiAgICB9XG4gICAgSW9uRGF0ZXRpbWUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWRhdGV0aW1lJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjYW5jZWxUZXh0JywgJ2RheU5hbWVzJywgJ2RheVNob3J0TmFtZXMnLCAnZGF5VmFsdWVzJywgJ2Rpc2FibGVkJywgJ2Rpc3BsYXlGb3JtYXQnLCAnZG9uZVRleHQnLCAnaG91clZhbHVlcycsICdtYXgnLCAnbWluJywgJ21pbnV0ZVZhbHVlcycsICdtb2RlJywgJ21vbnRoTmFtZXMnLCAnbW9udGhTaG9ydE5hbWVzJywgJ21vbnRoVmFsdWVzJywgJ25hbWUnLCAncGlja2VyRm9ybWF0JywgJ3BpY2tlck9wdGlvbnMnLCAncGxhY2Vob2xkZXInLCAncmVhZG9ubHknLCAndmFsdWUnLCAneWVhclZhbHVlcyddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uRGF0ZXRpbWUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25EYXRldGltZTtcbn0oKSk7XG5wcm94eU1ldGhvZHMoSW9uRGF0ZXRpbWUsIFsnb3BlbiddKTtcbnByb3h5SW5wdXRzKElvbkRhdGV0aW1lLCBbJ2NhbmNlbFRleHQnLCAnZGF5TmFtZXMnLCAnZGF5U2hvcnROYW1lcycsICdkYXlWYWx1ZXMnLCAnZGlzYWJsZWQnLCAnZGlzcGxheUZvcm1hdCcsICdkb25lVGV4dCcsICdob3VyVmFsdWVzJywgJ21heCcsICdtaW4nLCAnbWludXRlVmFsdWVzJywgJ21vZGUnLCAnbW9udGhOYW1lcycsICdtb250aFNob3J0TmFtZXMnLCAnbW9udGhWYWx1ZXMnLCAnbmFtZScsICdwaWNrZXJGb3JtYXQnLCAncGlja2VyT3B0aW9ucycsICdwbGFjZWhvbGRlcicsICdyZWFkb25seScsICd2YWx1ZScsICd5ZWFyVmFsdWVzJ10pO1xudmFyIElvbkZhYiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25GYWIoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25GYWIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWZhYicsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnYWN0aXZhdGVkJywgJ2VkZ2UnLCAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uRmFiLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uRmFiO1xufSgpKTtcbnByb3h5TWV0aG9kcyhJb25GYWIsIFsnY2xvc2UnXSk7XG5wcm94eUlucHV0cyhJb25GYWIsIFsnYWN0aXZhdGVkJywgJ2VkZ2UnLCAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddKTtcbnZhciBJb25GYWJCdXR0b24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uRmFiQnV0dG9uKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uRm9jdXMnLCAnaW9uQmx1ciddKTtcbiAgICB9XG4gICAgSW9uRmFiQnV0dG9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1mYWItYnV0dG9uJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydhY3RpdmF0ZWQnLCAnY29sb3InLCAnZGlzYWJsZWQnLCAnZG93bmxvYWQnLCAnaHJlZicsICdtb2RlJywgJ3JlbCcsICdyb3V0ZXJEaXJlY3Rpb24nLCAnc2hvdycsICdzaXplJywgJ3RhcmdldCcsICd0cmFuc2x1Y2VudCcsICd0eXBlJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25GYWJCdXR0b24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25GYWJCdXR0b247XG59KCkpO1xucHJveHlJbnB1dHMoSW9uRmFiQnV0dG9uLCBbJ2FjdGl2YXRlZCcsICdjb2xvcicsICdkaXNhYmxlZCcsICdkb3dubG9hZCcsICdocmVmJywgJ21vZGUnLCAncmVsJywgJ3JvdXRlckRpcmVjdGlvbicsICdzaG93JywgJ3NpemUnLCAndGFyZ2V0JywgJ3RyYW5zbHVjZW50JywgJ3R5cGUnXSk7XG52YXIgSW9uRmFiTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25GYWJMaXN0KGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgSW9uRmFiTGlzdC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tZmFiLWxpc3QnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2FjdGl2YXRlZCcsICdzaWRlJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25GYWJMaXN0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uRmFiTGlzdDtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25GYWJMaXN0LCBbJ2FjdGl2YXRlZCcsICdzaWRlJ10pO1xudmFyIElvbkZvb3RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25Gb290ZXIoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25Gb290ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWZvb3RlcicsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnbW9kZScsICd0cmFuc2x1Y2VudCddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uRm9vdGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uRm9vdGVyO1xufSgpKTtcbnByb3h5SW5wdXRzKElvbkZvb3RlciwgWydtb2RlJywgJ3RyYW5zbHVjZW50J10pO1xudmFyIElvbkdyaWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uR3JpZChjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvbkdyaWQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWdyaWQnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2ZpeGVkJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25HcmlkLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uR3JpZDtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25HcmlkLCBbJ2ZpeGVkJ10pO1xudmFyIElvbkhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25IZWFkZXIoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25IZWFkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWhlYWRlcicsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnY29sbGFwc2UnLCAnbW9kZScsICd0cmFuc2x1Y2VudCddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uSGVhZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uSGVhZGVyO1xufSgpKTtcbnByb3h5SW5wdXRzKElvbkhlYWRlciwgWydjb2xsYXBzZScsICdtb2RlJywgJ3RyYW5zbHVjZW50J10pO1xudmFyIElvbkljb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uSWNvbihjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvbkljb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWljb24nLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2FyaWFMYWJlbCcsICdjb2xvcicsICdmbGlwUnRsJywgJ2ljb24nLCAnaW9zJywgJ2xhenknLCAnbWQnLCAnbW9kZScsICduYW1lJywgJ3NpemUnLCAnc3JjJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25JY29uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uSWNvbjtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25JY29uLCBbJ2FyaWFMYWJlbCcsICdjb2xvcicsICdmbGlwUnRsJywgJ2ljb24nLCAnaW9zJywgJ2xhenknLCAnbWQnLCAnbW9kZScsICduYW1lJywgJ3NpemUnLCAnc3JjJ10pO1xudmFyIElvbkltZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25JbWcoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgICAgICBwcm94eU91dHB1dHModGhpcywgdGhpcy5lbCwgWydpb25JbWdXaWxsTG9hZCcsICdpb25JbWdEaWRMb2FkJywgJ2lvbkVycm9yJ10pO1xuICAgIH1cbiAgICBJb25JbWcuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWltZycsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnYWx0JywgJ3NyYyddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uSW1nLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uSW1nO1xufSgpKTtcbnByb3h5SW5wdXRzKElvbkltZywgWydhbHQnLCAnc3JjJ10pO1xudmFyIElvbkluZmluaXRlU2Nyb2xsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkluZmluaXRlU2Nyb2xsKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uSW5maW5pdGUnXSk7XG4gICAgfVxuICAgIElvbkluZmluaXRlU2Nyb2xsLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1pbmZpbml0ZS1zY3JvbGwnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2Rpc2FibGVkJywgJ3Bvc2l0aW9uJywgJ3RocmVzaG9sZCddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uSW5maW5pdGVTY3JvbGwuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25JbmZpbml0ZVNjcm9sbDtcbn0oKSk7XG5wcm94eU1ldGhvZHMoSW9uSW5maW5pdGVTY3JvbGwsIFsnY29tcGxldGUnXSk7XG5wcm94eUlucHV0cyhJb25JbmZpbml0ZVNjcm9sbCwgWydkaXNhYmxlZCcsICdwb3NpdGlvbicsICd0aHJlc2hvbGQnXSk7XG52YXIgSW9uSW5maW5pdGVTY3JvbGxDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkluZmluaXRlU2Nyb2xsQ29udGVudChjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvbkluZmluaXRlU2Nyb2xsQ29udGVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24taW5maW5pdGUtc2Nyb2xsLWNvbnRlbnQnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2xvYWRpbmdTcGlubmVyJywgJ2xvYWRpbmdUZXh0J10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25JbmZpbml0ZVNjcm9sbENvbnRlbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25JbmZpbml0ZVNjcm9sbENvbnRlbnQ7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uSW5maW5pdGVTY3JvbGxDb250ZW50LCBbJ2xvYWRpbmdTcGlubmVyJywgJ2xvYWRpbmdUZXh0J10pO1xudmFyIElvbklucHV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbklucHV0KGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uSW5wdXQnLCAnaW9uQ2hhbmdlJywgJ2lvbkJsdXInLCAnaW9uRm9jdXMnXSk7XG4gICAgfVxuICAgIElvbklucHV0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1pbnB1dCcsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnYWNjZXB0JywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9jb21wbGV0ZScsICdhdXRvY29ycmVjdCcsICdhdXRvZm9jdXMnLCAnY2xlYXJJbnB1dCcsICdjbGVhck9uRWRpdCcsICdjb2xvcicsICdkZWJvdW5jZScsICdkaXNhYmxlZCcsICdpbnB1dG1vZGUnLCAnbWF4JywgJ21heGxlbmd0aCcsICdtaW4nLCAnbWlubGVuZ3RoJywgJ21vZGUnLCAnbXVsdGlwbGUnLCAnbmFtZScsICdwYXR0ZXJuJywgJ3BsYWNlaG9sZGVyJywgJ3JlYWRvbmx5JywgJ3JlcXVpcmVkJywgJ3NpemUnLCAnc3BlbGxjaGVjaycsICdzdGVwJywgJ3R5cGUnLCAndmFsdWUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvbklucHV0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uSW5wdXQ7XG59KCkpO1xucHJveHlNZXRob2RzKElvbklucHV0LCBbJ3NldEZvY3VzJywgJ2dldElucHV0RWxlbWVudCddKTtcbnByb3h5SW5wdXRzKElvbklucHV0LCBbJ2FjY2VwdCcsICdhdXRvY2FwaXRhbGl6ZScsICdhdXRvY29tcGxldGUnLCAnYXV0b2NvcnJlY3QnLCAnYXV0b2ZvY3VzJywgJ2NsZWFySW5wdXQnLCAnY2xlYXJPbkVkaXQnLCAnY29sb3InLCAnZGVib3VuY2UnLCAnZGlzYWJsZWQnLCAnaW5wdXRtb2RlJywgJ21heCcsICdtYXhsZW5ndGgnLCAnbWluJywgJ21pbmxlbmd0aCcsICdtb2RlJywgJ211bHRpcGxlJywgJ25hbWUnLCAncGF0dGVybicsICdwbGFjZWhvbGRlcicsICdyZWFkb25seScsICdyZXF1aXJlZCcsICdzaXplJywgJ3NwZWxsY2hlY2snLCAnc3RlcCcsICd0eXBlJywgJ3ZhbHVlJ10pO1xudmFyIElvbkl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uSXRlbShjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvbkl0ZW0uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWl0ZW0nLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2J1dHRvbicsICdjb2xvcicsICdkZXRhaWwnLCAnZGV0YWlsSWNvbicsICdkaXNhYmxlZCcsICdkb3dubG9hZCcsICdocmVmJywgJ2xpbmVzJywgJ21vZGUnLCAncmVsJywgJ3JvdXRlckRpcmVjdGlvbicsICd0YXJnZXQnLCAndHlwZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uSXRlbS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvbkl0ZW07XG59KCkpO1xucHJveHlJbnB1dHMoSW9uSXRlbSwgWydidXR0b24nLCAnY29sb3InLCAnZGV0YWlsJywgJ2RldGFpbEljb24nLCAnZGlzYWJsZWQnLCAnZG93bmxvYWQnLCAnaHJlZicsICdsaW5lcycsICdtb2RlJywgJ3JlbCcsICdyb3V0ZXJEaXJlY3Rpb24nLCAndGFyZ2V0JywgJ3R5cGUnXSk7XG52YXIgSW9uSXRlbURpdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uSXRlbURpdmlkZXIoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25JdGVtRGl2aWRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24taXRlbS1kaXZpZGVyJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb2xvcicsICdtb2RlJywgJ3N0aWNreSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uSXRlbURpdmlkZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25JdGVtRGl2aWRlcjtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25JdGVtRGl2aWRlciwgWydjb2xvcicsICdtb2RlJywgJ3N0aWNreSddKTtcbnZhciBJb25JdGVtR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uSXRlbUdyb3VwKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgSW9uSXRlbUdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1pdGVtLWdyb3VwJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25JdGVtR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25JdGVtR3JvdXA7XG59KCkpO1xudmFyIElvbkl0ZW1PcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uSXRlbU9wdGlvbihjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvbkl0ZW1PcHRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLWl0ZW0tb3B0aW9uJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb2xvcicsICdkaXNhYmxlZCcsICdkb3dubG9hZCcsICdleHBhbmRhYmxlJywgJ2hyZWYnLCAnbW9kZScsICdyZWwnLCAndGFyZ2V0JywgJ3R5cGUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvbkl0ZW1PcHRpb24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25JdGVtT3B0aW9uO1xufSgpKTtcbnByb3h5SW5wdXRzKElvbkl0ZW1PcHRpb24sIFsnY29sb3InLCAnZGlzYWJsZWQnLCAnZG93bmxvYWQnLCAnZXhwYW5kYWJsZScsICdocmVmJywgJ21vZGUnLCAncmVsJywgJ3RhcmdldCcsICd0eXBlJ10pO1xudmFyIElvbkl0ZW1PcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkl0ZW1PcHRpb25zKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uU3dpcGUnXSk7XG4gICAgfVxuICAgIElvbkl0ZW1PcHRpb25zLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1pdGVtLW9wdGlvbnMnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ3NpZGUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvbkl0ZW1PcHRpb25zLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uSXRlbU9wdGlvbnM7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uSXRlbU9wdGlvbnMsIFsnc2lkZSddKTtcbnZhciBJb25JdGVtU2xpZGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25JdGVtU2xpZGluZyhjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHByb3h5T3V0cHV0cyh0aGlzLCB0aGlzLmVsLCBbJ2lvbkRyYWcnXSk7XG4gICAgfVxuICAgIElvbkl0ZW1TbGlkaW5nLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1pdGVtLXNsaWRpbmcnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2Rpc2FibGVkJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25JdGVtU2xpZGluZy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvbkl0ZW1TbGlkaW5nO1xufSgpKTtcbnByb3h5TWV0aG9kcyhJb25JdGVtU2xpZGluZywgWydnZXRPcGVuQW1vdW50JywgJ2dldFNsaWRpbmdSYXRpbycsICdvcGVuJywgJ2Nsb3NlJywgJ2Nsb3NlT3BlbmVkJ10pO1xucHJveHlJbnB1dHMoSW9uSXRlbVNsaWRpbmcsIFsnZGlzYWJsZWQnXSk7XG52YXIgSW9uTGFiZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uTGFiZWwoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25MYWJlbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tbGFiZWwnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2NvbG9yJywgJ21vZGUnLCAncG9zaXRpb24nXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvbkxhYmVsLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uTGFiZWw7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uTGFiZWwsIFsnY29sb3InLCAnbW9kZScsICdwb3NpdGlvbiddKTtcbnZhciBJb25MaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkxpc3QoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25MaXN0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1saXN0JywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydpbnNldCcsICdsaW5lcycsICdtb2RlJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25MaXN0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uTGlzdDtcbn0oKSk7XG5wcm94eU1ldGhvZHMoSW9uTGlzdCwgWydjbG9zZVNsaWRpbmdJdGVtcyddKTtcbnByb3h5SW5wdXRzKElvbkxpc3QsIFsnaW5zZXQnLCAnbGluZXMnLCAnbW9kZSddKTtcbnZhciBJb25MaXN0SGVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkxpc3RIZWFkZXIoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25MaXN0SGVhZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1saXN0LWhlYWRlcicsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnY29sb3InLCAnbW9kZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uTGlzdEhlYWRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvbkxpc3RIZWFkZXI7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uTGlzdEhlYWRlciwgWydjb2xvcicsICdtb2RlJ10pO1xudmFyIElvbk1lbnUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uTWVudShjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHByb3h5T3V0cHV0cyh0aGlzLCB0aGlzLmVsLCBbJ2lvbldpbGxPcGVuJywgJ2lvbldpbGxDbG9zZScsICdpb25EaWRPcGVuJywgJ2lvbkRpZENsb3NlJ10pO1xuICAgIH1cbiAgICBJb25NZW51LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1tZW51JywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb250ZW50SWQnLCAnZGlzYWJsZWQnLCAnbWF4RWRnZVN0YXJ0JywgJ21lbnVJZCcsICdzaWRlJywgJ3N3aXBlR2VzdHVyZScsICd0eXBlJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25NZW51LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uTWVudTtcbn0oKSk7XG5wcm94eU1ldGhvZHMoSW9uTWVudSwgWydpc09wZW4nLCAnaXNBY3RpdmUnLCAnb3BlbicsICdjbG9zZScsICd0b2dnbGUnLCAnc2V0T3BlbiddKTtcbnByb3h5SW5wdXRzKElvbk1lbnUsIFsnY29udGVudElkJywgJ2Rpc2FibGVkJywgJ21heEVkZ2VTdGFydCcsICdtZW51SWQnLCAnc2lkZScsICdzd2lwZUdlc3R1cmUnLCAndHlwZSddKTtcbnZhciBJb25NZW51QnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbk1lbnVCdXR0b24oYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25NZW51QnV0dG9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1tZW51LWJ1dHRvbicsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnYXV0b0hpZGUnLCAnY29sb3InLCAnZGlzYWJsZWQnLCAnbWVudScsICd0eXBlJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25NZW51QnV0dG9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uTWVudUJ1dHRvbjtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25NZW51QnV0dG9uLCBbJ2F1dG9IaWRlJywgJ2NvbG9yJywgJ2Rpc2FibGVkJywgJ21lbnUnLCAndHlwZSddKTtcbnZhciBJb25NZW51VG9nZ2xlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbk1lbnVUb2dnbGUoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25NZW51VG9nZ2xlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1tZW51LXRvZ2dsZScsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnYXV0b0hpZGUnLCAnbWVudSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uTWVudVRvZ2dsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvbk1lbnVUb2dnbGU7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uTWVudVRvZ2dsZSwgWydhdXRvSGlkZScsICdtZW51J10pO1xudmFyIElvbk5hdiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25OYXYoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgICAgICBwcm94eU91dHB1dHModGhpcywgdGhpcy5lbCwgWydpb25OYXZXaWxsQ2hhbmdlJywgJ2lvbk5hdkRpZENoYW5nZSddKTtcbiAgICB9XG4gICAgSW9uTmF2LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1uYXYnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2FuaW1hdGVkJywgJ2FuaW1hdGlvbicsICdyb290JywgJ3Jvb3RQYXJhbXMnLCAnc3dpcGVHZXN0dXJlJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25OYXYuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25OYXY7XG59KCkpO1xucHJveHlNZXRob2RzKElvbk5hdiwgWydwdXNoJywgJ2luc2VydCcsICdpbnNlcnRQYWdlcycsICdwb3AnLCAncG9wVG8nLCAncG9wVG9Sb290JywgJ3JlbW92ZUluZGV4JywgJ3NldFJvb3QnLCAnc2V0UGFnZXMnLCAnZ2V0QWN0aXZlJywgJ2dldEJ5SW5kZXgnLCAnY2FuR29CYWNrJywgJ2dldFByZXZpb3VzJ10pO1xucHJveHlJbnB1dHMoSW9uTmF2LCBbJ2FuaW1hdGVkJywgJ2FuaW1hdGlvbicsICdyb290JywgJ3Jvb3RQYXJhbXMnLCAnc3dpcGVHZXN0dXJlJ10pO1xudmFyIElvbk5hdkxpbmsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uTmF2TGluayhjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvbk5hdkxpbmsuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLW5hdi1saW5rJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb21wb25lbnQnLCAnY29tcG9uZW50UHJvcHMnLCAncm91dGVyRGlyZWN0aW9uJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25OYXZMaW5rLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uTmF2TGluaztcbn0oKSk7XG5wcm94eUlucHV0cyhJb25OYXZMaW5rLCBbJ2NvbXBvbmVudCcsICdjb21wb25lbnRQcm9wcycsICdyb3V0ZXJEaXJlY3Rpb24nXSk7XG52YXIgSW9uTmF2UG9wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbk5hdlBvcChjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvbk5hdlBvcC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tbmF2LXBvcCcsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uTmF2UG9wLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uTmF2UG9wO1xufSgpKTtcbnZhciBJb25OYXZQdXNoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbk5hdlB1c2goYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25OYXZQdXNoLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1uYXYtcHVzaCcsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnY29tcG9uZW50JywgJ2NvbXBvbmVudFByb3BzJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25OYXZQdXNoLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uTmF2UHVzaDtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25OYXZQdXNoLCBbJ2NvbXBvbmVudCcsICdjb21wb25lbnRQcm9wcyddKTtcbnZhciBJb25OYXZTZXRSb290ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbk5hdlNldFJvb3QoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25OYXZTZXRSb290LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1uYXYtc2V0LXJvb3QnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2NvbXBvbmVudCcsICdjb21wb25lbnRQcm9wcyddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uTmF2U2V0Um9vdC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvbk5hdlNldFJvb3Q7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uTmF2U2V0Um9vdCwgWydjb21wb25lbnQnLCAnY29tcG9uZW50UHJvcHMnXSk7XG52YXIgSW9uTm90ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25Ob3RlKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgSW9uTm90ZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tbm90ZScsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnY29sb3InLCAnbW9kZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uTm90ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvbk5vdGU7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uTm90ZSwgWydjb2xvcicsICdtb2RlJ10pO1xudmFyIElvblByb2dyZXNzQmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblByb2dyZXNzQmFyKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgSW9uUHJvZ3Jlc3NCYXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLXByb2dyZXNzLWJhcicsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnYnVmZmVyJywgJ2NvbG9yJywgJ21vZGUnLCAncmV2ZXJzZWQnLCAndHlwZScsICd2YWx1ZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uUHJvZ3Jlc3NCYXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25Qcm9ncmVzc0Jhcjtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25Qcm9ncmVzc0JhciwgWydidWZmZXInLCAnY29sb3InLCAnbW9kZScsICdyZXZlcnNlZCcsICd0eXBlJywgJ3ZhbHVlJ10pO1xudmFyIElvblJhZGlvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblJhZGlvKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uU2VsZWN0JywgJ2lvbkZvY3VzJywgJ2lvbkJsdXInXSk7XG4gICAgfVxuICAgIElvblJhZGlvLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1yYWRpbycsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnY2hlY2tlZCcsICdjb2xvcicsICdkaXNhYmxlZCcsICdtb2RlJywgJ25hbWUnLCAndmFsdWUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvblJhZGlvLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uUmFkaW87XG59KCkpO1xucHJveHlJbnB1dHMoSW9uUmFkaW8sIFsnY2hlY2tlZCcsICdjb2xvcicsICdkaXNhYmxlZCcsICdtb2RlJywgJ25hbWUnLCAndmFsdWUnXSk7XG52YXIgSW9uUmFkaW9Hcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25SYWRpb0dyb3VwKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uQ2hhbmdlJ10pO1xuICAgIH1cbiAgICBJb25SYWRpb0dyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1yYWRpby1ncm91cCcsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnYWxsb3dFbXB0eVNlbGVjdGlvbicsICduYW1lJywgJ3ZhbHVlJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25SYWRpb0dyb3VwLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uUmFkaW9Hcm91cDtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25SYWRpb0dyb3VwLCBbJ2FsbG93RW1wdHlTZWxlY3Rpb24nLCAnbmFtZScsICd2YWx1ZSddKTtcbnZhciBJb25SYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25SYW5nZShjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHByb3h5T3V0cHV0cyh0aGlzLCB0aGlzLmVsLCBbJ2lvbkNoYW5nZScsICdpb25Gb2N1cycsICdpb25CbHVyJ10pO1xuICAgIH1cbiAgICBJb25SYW5nZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tcmFuZ2UnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2NvbG9yJywgJ2RlYm91bmNlJywgJ2Rpc2FibGVkJywgJ2R1YWxLbm9icycsICdtYXgnLCAnbWluJywgJ21vZGUnLCAnbmFtZScsICdwaW4nLCAnc25hcHMnLCAnc3RlcCcsICd0aWNrcycsICd2YWx1ZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uUmFuZ2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25SYW5nZTtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25SYW5nZSwgWydjb2xvcicsICdkZWJvdW5jZScsICdkaXNhYmxlZCcsICdkdWFsS25vYnMnLCAnbWF4JywgJ21pbicsICdtb2RlJywgJ25hbWUnLCAncGluJywgJ3NuYXBzJywgJ3N0ZXAnLCAndGlja3MnLCAndmFsdWUnXSk7XG52YXIgSW9uUmVmcmVzaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblJlZnJlc2hlcihjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHByb3h5T3V0cHV0cyh0aGlzLCB0aGlzLmVsLCBbJ2lvblJlZnJlc2gnLCAnaW9uUHVsbCcsICdpb25TdGFydCddKTtcbiAgICB9XG4gICAgSW9uUmVmcmVzaGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1yZWZyZXNoZXInLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2Nsb3NlRHVyYXRpb24nLCAnZGlzYWJsZWQnLCAncHVsbEZhY3RvcicsICdwdWxsTWF4JywgJ3B1bGxNaW4nLCAnc25hcGJhY2tEdXJhdGlvbiddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uUmVmcmVzaGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uUmVmcmVzaGVyO1xufSgpKTtcbnByb3h5TWV0aG9kcyhJb25SZWZyZXNoZXIsIFsnY29tcGxldGUnLCAnY2FuY2VsJywgJ2dldFByb2dyZXNzJ10pO1xucHJveHlJbnB1dHMoSW9uUmVmcmVzaGVyLCBbJ2Nsb3NlRHVyYXRpb24nLCAnZGlzYWJsZWQnLCAncHVsbEZhY3RvcicsICdwdWxsTWF4JywgJ3B1bGxNaW4nLCAnc25hcGJhY2tEdXJhdGlvbiddKTtcbnZhciBJb25SZWZyZXNoZXJDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblJlZnJlc2hlckNvbnRlbnQoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25SZWZyZXNoZXJDb250ZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1yZWZyZXNoZXItY29udGVudCcsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsncHVsbGluZ0ljb24nLCAncHVsbGluZ1RleHQnLCAncmVmcmVzaGluZ1NwaW5uZXInLCAncmVmcmVzaGluZ1RleHQnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvblJlZnJlc2hlckNvbnRlbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25SZWZyZXNoZXJDb250ZW50O1xufSgpKTtcbnByb3h5SW5wdXRzKElvblJlZnJlc2hlckNvbnRlbnQsIFsncHVsbGluZ0ljb24nLCAncHVsbGluZ1RleHQnLCAncmVmcmVzaGluZ1NwaW5uZXInLCAncmVmcmVzaGluZ1RleHQnXSk7XG52YXIgSW9uUmVvcmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25SZW9yZGVyKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgSW9uUmVvcmRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tcmVvcmRlcicsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uUmVvcmRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvblJlb3JkZXI7XG59KCkpO1xudmFyIElvblJlb3JkZXJHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25SZW9yZGVyR3JvdXAoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgICAgICBwcm94eU91dHB1dHModGhpcywgdGhpcy5lbCwgWydpb25JdGVtUmVvcmRlciddKTtcbiAgICB9XG4gICAgSW9uUmVvcmRlckdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1yZW9yZGVyLWdyb3VwJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydkaXNhYmxlZCddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uUmVvcmRlckdyb3VwLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uUmVvcmRlckdyb3VwO1xufSgpKTtcbnByb3h5TWV0aG9kcyhJb25SZW9yZGVyR3JvdXAsIFsnY29tcGxldGUnXSk7XG5wcm94eUlucHV0cyhJb25SZW9yZGVyR3JvdXAsIFsnZGlzYWJsZWQnXSk7XG52YXIgSW9uUmlwcGxlRWZmZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblJpcHBsZUVmZmVjdChjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvblJpcHBsZUVmZmVjdC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tcmlwcGxlLWVmZmVjdCcsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsndHlwZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uUmlwcGxlRWZmZWN0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uUmlwcGxlRWZmZWN0O1xufSgpKTtcbnByb3h5TWV0aG9kcyhJb25SaXBwbGVFZmZlY3QsIFsnYWRkUmlwcGxlJ10pO1xucHJveHlJbnB1dHMoSW9uUmlwcGxlRWZmZWN0LCBbJ3R5cGUnXSk7XG52YXIgSW9uUm93ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblJvdyhjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvblJvdy5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tcm93JywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25Sb3cuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25Sb3c7XG59KCkpO1xudmFyIElvblNlYXJjaGJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25TZWFyY2hiYXIoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgICAgICBwcm94eU91dHB1dHModGhpcywgdGhpcy5lbCwgWydpb25JbnB1dCcsICdpb25DaGFuZ2UnLCAnaW9uQ2FuY2VsJywgJ2lvbkNsZWFyJywgJ2lvbkJsdXInLCAnaW9uRm9jdXMnXSk7XG4gICAgfVxuICAgIElvblNlYXJjaGJhci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tc2VhcmNoYmFyJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydhbmltYXRlZCcsICdhdXRvY29tcGxldGUnLCAnYXV0b2NvcnJlY3QnLCAnY2FuY2VsQnV0dG9uSWNvbicsICdjYW5jZWxCdXR0b25UZXh0JywgJ2NsZWFySWNvbicsICdjb2xvcicsICdkZWJvdW5jZScsICdkaXNhYmxlZCcsICdpbnB1dG1vZGUnLCAnbW9kZScsICdwbGFjZWhvbGRlcicsICdzZWFyY2hJY29uJywgJ3Nob3dDYW5jZWxCdXR0b24nLCAnc3BlbGxjaGVjaycsICd0eXBlJywgJ3ZhbHVlJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25TZWFyY2hiYXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25TZWFyY2hiYXI7XG59KCkpO1xucHJveHlNZXRob2RzKElvblNlYXJjaGJhciwgWydzZXRGb2N1cycsICdnZXRJbnB1dEVsZW1lbnQnXSk7XG5wcm94eUlucHV0cyhJb25TZWFyY2hiYXIsIFsnYW5pbWF0ZWQnLCAnYXV0b2NvbXBsZXRlJywgJ2F1dG9jb3JyZWN0JywgJ2NhbmNlbEJ1dHRvbkljb24nLCAnY2FuY2VsQnV0dG9uVGV4dCcsICdjbGVhckljb24nLCAnY29sb3InLCAnZGVib3VuY2UnLCAnZGlzYWJsZWQnLCAnaW5wdXRtb2RlJywgJ21vZGUnLCAncGxhY2Vob2xkZXInLCAnc2VhcmNoSWNvbicsICdzaG93Q2FuY2VsQnV0dG9uJywgJ3NwZWxsY2hlY2snLCAndHlwZScsICd2YWx1ZSddKTtcbnZhciBJb25TZWdtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblNlZ21lbnQoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgICAgICBwcm94eU91dHB1dHModGhpcywgdGhpcy5lbCwgWydpb25DaGFuZ2UnXSk7XG4gICAgfVxuICAgIElvblNlZ21lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLXNlZ21lbnQnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2NvbG9yJywgJ2Rpc2FibGVkJywgJ21vZGUnLCAnc2Nyb2xsYWJsZScsICd2YWx1ZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uU2VnbWVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvblNlZ21lbnQ7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uU2VnbWVudCwgWydjb2xvcicsICdkaXNhYmxlZCcsICdtb2RlJywgJ3Njcm9sbGFibGUnLCAndmFsdWUnXSk7XG52YXIgSW9uU2VnbWVudEJ1dHRvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25TZWdtZW50QnV0dG9uKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uU2VsZWN0J10pO1xuICAgIH1cbiAgICBJb25TZWdtZW50QnV0dG9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1zZWdtZW50LWJ1dHRvbicsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnY2hlY2tlZCcsICdkaXNhYmxlZCcsICdsYXlvdXQnLCAnbW9kZScsICd0eXBlJywgJ3ZhbHVlJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25TZWdtZW50QnV0dG9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uU2VnbWVudEJ1dHRvbjtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25TZWdtZW50QnV0dG9uLCBbJ2NoZWNrZWQnLCAnZGlzYWJsZWQnLCAnbGF5b3V0JywgJ21vZGUnLCAndHlwZScsICd2YWx1ZSddKTtcbnZhciBJb25TZWxlY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uU2VsZWN0KGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uQ2hhbmdlJywgJ2lvbkNhbmNlbCcsICdpb25Gb2N1cycsICdpb25CbHVyJ10pO1xuICAgIH1cbiAgICBJb25TZWxlY3QuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLXNlbGVjdCcsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnY2FuY2VsVGV4dCcsICdjb21wYXJlV2l0aCcsICdkaXNhYmxlZCcsICdpbnRlcmZhY2UnLCAnaW50ZXJmYWNlT3B0aW9ucycsICdtb2RlJywgJ211bHRpcGxlJywgJ25hbWUnLCAnb2tUZXh0JywgJ3BsYWNlaG9sZGVyJywgJ3NlbGVjdGVkVGV4dCcsICd2YWx1ZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uU2VsZWN0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uU2VsZWN0O1xufSgpKTtcbnByb3h5TWV0aG9kcyhJb25TZWxlY3QsIFsnb3BlbiddKTtcbnByb3h5SW5wdXRzKElvblNlbGVjdCwgWydjYW5jZWxUZXh0JywgJ2NvbXBhcmVXaXRoJywgJ2Rpc2FibGVkJywgJ2ludGVyZmFjZScsICdpbnRlcmZhY2VPcHRpb25zJywgJ21vZGUnLCAnbXVsdGlwbGUnLCAnbmFtZScsICdva1RleHQnLCAncGxhY2Vob2xkZXInLCAnc2VsZWN0ZWRUZXh0JywgJ3ZhbHVlJ10pO1xudmFyIElvblNlbGVjdE9wdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25TZWxlY3RPcHRpb24oYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25TZWxlY3RPcHRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLXNlbGVjdC1vcHRpb24nLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2Rpc2FibGVkJywgJ3NlbGVjdGVkJywgJ3ZhbHVlJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25TZWxlY3RPcHRpb24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25TZWxlY3RPcHRpb247XG59KCkpO1xucHJveHlJbnB1dHMoSW9uU2VsZWN0T3B0aW9uLCBbJ2Rpc2FibGVkJywgJ3NlbGVjdGVkJywgJ3ZhbHVlJ10pO1xudmFyIElvblNrZWxldG9uVGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25Ta2VsZXRvblRleHQoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25Ta2VsZXRvblRleHQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLXNrZWxldG9uLXRleHQnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2FuaW1hdGVkJywgJ3dpZHRoJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25Ta2VsZXRvblRleHQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25Ta2VsZXRvblRleHQ7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uU2tlbGV0b25UZXh0LCBbJ2FuaW1hdGVkJywgJ3dpZHRoJ10pO1xudmFyIElvblNsaWRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblNsaWRlKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgSW9uU2xpZGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLXNsaWRlJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25TbGlkZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvblNsaWRlO1xufSgpKTtcbnZhciBJb25TbGlkZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uU2xpZGVzKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uU2xpZGVzRGlkTG9hZCcsICdpb25TbGlkZVRhcCcsICdpb25TbGlkZURvdWJsZVRhcCcsICdpb25TbGlkZVdpbGxDaGFuZ2UnLCAnaW9uU2xpZGVEaWRDaGFuZ2UnLCAnaW9uU2xpZGVOZXh0U3RhcnQnLCAnaW9uU2xpZGVQcmV2U3RhcnQnLCAnaW9uU2xpZGVOZXh0RW5kJywgJ2lvblNsaWRlUHJldkVuZCcsICdpb25TbGlkZVRyYW5zaXRpb25TdGFydCcsICdpb25TbGlkZVRyYW5zaXRpb25FbmQnLCAnaW9uU2xpZGVEcmFnJywgJ2lvblNsaWRlUmVhY2hTdGFydCcsICdpb25TbGlkZVJlYWNoRW5kJywgJ2lvblNsaWRlVG91Y2hTdGFydCcsICdpb25TbGlkZVRvdWNoRW5kJ10pO1xuICAgIH1cbiAgICBJb25TbGlkZXMuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLXNsaWRlcycsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnbW9kZScsICdvcHRpb25zJywgJ3BhZ2VyJywgJ3Njcm9sbGJhciddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uU2xpZGVzLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uU2xpZGVzO1xufSgpKTtcbnByb3h5TWV0aG9kcyhJb25TbGlkZXMsIFsndXBkYXRlJywgJ3VwZGF0ZUF1dG9IZWlnaHQnLCAnc2xpZGVUbycsICdzbGlkZU5leHQnLCAnc2xpZGVQcmV2JywgJ2dldEFjdGl2ZUluZGV4JywgJ2dldFByZXZpb3VzSW5kZXgnLCAnbGVuZ3RoJywgJ2lzRW5kJywgJ2lzQmVnaW5uaW5nJywgJ3N0YXJ0QXV0b3BsYXknLCAnc3RvcEF1dG9wbGF5JywgJ2xvY2tTd2lwZVRvTmV4dCcsICdsb2NrU3dpcGVUb1ByZXYnLCAnbG9ja1N3aXBlcycsICdnZXRTd2lwZXInXSk7XG5wcm94eUlucHV0cyhJb25TbGlkZXMsIFsnbW9kZScsICdvcHRpb25zJywgJ3BhZ2VyJywgJ3Njcm9sbGJhciddKTtcbnZhciBJb25TcGlubmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblNwaW5uZXIoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25TcGlubmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1zcGlubmVyJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb2xvcicsICdkdXJhdGlvbicsICduYW1lJywgJ3BhdXNlZCddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uU3Bpbm5lci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvblNwaW5uZXI7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uU3Bpbm5lciwgWydjb2xvcicsICdkdXJhdGlvbicsICduYW1lJywgJ3BhdXNlZCddKTtcbnZhciBJb25TcGxpdFBhbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uU3BsaXRQYW5lKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uU3BsaXRQYW5lVmlzaWJsZSddKTtcbiAgICB9XG4gICAgSW9uU3BsaXRQYW5lLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi1zcGxpdC1wYW5lJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb250ZW50SWQnLCAnZGlzYWJsZWQnLCAnd2hlbiddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uU3BsaXRQYW5lLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uU3BsaXRQYW5lO1xufSgpKTtcbnByb3h5SW5wdXRzKElvblNwbGl0UGFuZSwgWydjb250ZW50SWQnLCAnZGlzYWJsZWQnLCAnd2hlbiddKTtcbnZhciBJb25UYWJCYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uVGFiQmFyKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgSW9uVGFiQmFyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi10YWItYmFyJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb2xvcicsICdtb2RlJywgJ3NlbGVjdGVkVGFiJywgJ3RyYW5zbHVjZW50J10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25UYWJCYXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25UYWJCYXI7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uVGFiQmFyLCBbJ2NvbG9yJywgJ21vZGUnLCAnc2VsZWN0ZWRUYWInLCAndHJhbnNsdWNlbnQnXSk7XG52YXIgSW9uVGFiQnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblRhYkJ1dHRvbihjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvblRhYkJ1dHRvbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tdGFiLWJ1dHRvbicsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLCBpbnB1dHM6IFsnZGlzYWJsZWQnLCAnZG93bmxvYWQnLCAnaHJlZicsICdsYXlvdXQnLCAnbW9kZScsICdyZWwnLCAnc2VsZWN0ZWQnLCAndGFiJywgJ3RhcmdldCddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uVGFiQnV0dG9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uVGFiQnV0dG9uO1xufSgpKTtcbnByb3h5SW5wdXRzKElvblRhYkJ1dHRvbiwgWydkaXNhYmxlZCcsICdkb3dubG9hZCcsICdocmVmJywgJ2xheW91dCcsICdtb2RlJywgJ3JlbCcsICdzZWxlY3RlZCcsICd0YWInLCAndGFyZ2V0J10pO1xudmFyIElvblRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uVGV4dChjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIElvblRleHQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnaW9uLXRleHQnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2NvbG9yJywgJ21vZGUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvblRleHQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBJb25UZXh0O1xufSgpKTtcbnByb3h5SW5wdXRzKElvblRleHQsIFsnY29sb3InLCAnbW9kZSddKTtcbnZhciBJb25UZXh0YXJlYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJb25UZXh0YXJlYShjLCByLCB6KSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIGMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHByb3h5T3V0cHV0cyh0aGlzLCB0aGlzLmVsLCBbJ2lvbkNoYW5nZScsICdpb25JbnB1dCcsICdpb25CbHVyJywgJ2lvbkZvY3VzJ10pO1xuICAgIH1cbiAgICBJb25UZXh0YXJlYS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tdGV4dGFyZWEnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2F1dG9Hcm93JywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9mb2N1cycsICdjbGVhck9uRWRpdCcsICdjb2xvcicsICdjb2xzJywgJ2RlYm91bmNlJywgJ2Rpc2FibGVkJywgJ21heGxlbmd0aCcsICdtaW5sZW5ndGgnLCAnbW9kZScsICduYW1lJywgJ3BsYWNlaG9sZGVyJywgJ3JlYWRvbmx5JywgJ3JlcXVpcmVkJywgJ3Jvd3MnLCAnc3BlbGxjaGVjaycsICd2YWx1ZScsICd3cmFwJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25UZXh0YXJlYS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvblRleHRhcmVhO1xufSgpKTtcbnByb3h5TWV0aG9kcyhJb25UZXh0YXJlYSwgWydzZXRGb2N1cycsICdnZXRJbnB1dEVsZW1lbnQnXSk7XG5wcm94eUlucHV0cyhJb25UZXh0YXJlYSwgWydhdXRvR3JvdycsICdhdXRvY2FwaXRhbGl6ZScsICdhdXRvZm9jdXMnLCAnY2xlYXJPbkVkaXQnLCAnY29sb3InLCAnY29scycsICdkZWJvdW5jZScsICdkaXNhYmxlZCcsICdtYXhsZW5ndGgnLCAnbWlubGVuZ3RoJywgJ21vZGUnLCAnbmFtZScsICdwbGFjZWhvbGRlcicsICdyZWFkb25seScsICdyZXF1aXJlZCcsICdyb3dzJywgJ3NwZWxsY2hlY2snLCAndmFsdWUnLCAnd3JhcCddKTtcbnZhciBJb25UaHVtYm5haWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uVGh1bWJuYWlsKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgSW9uVGh1bWJuYWlsLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi10aHVtYm5haWwnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvblRodW1ibmFpbC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIElvblRodW1ibmFpbDtcbn0oKSk7XG52YXIgSW9uVGl0bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uVGl0bGUoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25UaXRsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tdGl0bGUnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JywgaW5wdXRzOiBbJ2NvbG9yJywgJ3NpemUnXSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIElvblRpdGxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uVGl0bGU7XG59KCkpO1xucHJveHlJbnB1dHMoSW9uVGl0bGUsIFsnY29sb3InLCAnc2l6ZSddKTtcbnZhciBJb25Ub2dnbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uVG9nZ2xlKGMsIHIsIHopIHtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgYy5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uQ2hhbmdlJywgJ2lvbkZvY3VzJywgJ2lvbkJsdXInXSk7XG4gICAgfVxuICAgIElvblRvZ2dsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdpb24tdG9nZ2xlJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjaGVja2VkJywgJ2NvbG9yJywgJ2Rpc2FibGVkJywgJ21vZGUnLCAnbmFtZScsICd2YWx1ZSddIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uVG9nZ2xlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uVG9nZ2xlO1xufSgpKTtcbnByb3h5SW5wdXRzKElvblRvZ2dsZSwgWydjaGVja2VkJywgJ2NvbG9yJywgJ2Rpc2FibGVkJywgJ21vZGUnLCAnbmFtZScsICd2YWx1ZSddKTtcbnZhciBJb25Ub29sYmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblRvb2xiYXIoYywgciwgeikge1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICBjLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBJb25Ub29sYmFyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2lvbi10b29sYmFyJywgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsIGlucHV0czogWydjb2xvcicsICdtb2RlJ10gfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25Ub29sYmFyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW9uVG9vbGJhcjtcbn0oKSk7XG5wcm94eUlucHV0cyhJb25Ub29sYmFyLCBbJ2NvbG9yJywgJ21vZGUnXSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmZpZygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgKiBAcGFyYW0gez89fSBmYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29uZmlnLnByb3RvdHlwZS5nZXQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAqIEBwYXJhbSB7Pz19IGZhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoa2V5LCBmYWxsYmFjaykge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBjID0gZ2V0Q29uZmlnKCk7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5nZXQoa2V5LCBmYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAqIEBwYXJhbSB7Pz19IGZhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25maWcucHJvdG90eXBlLmdldEJvb2xlYW4gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAqIEBwYXJhbSB7Pz19IGZhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoa2V5LCBmYWxsYmFjaykge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBjID0gZ2V0Q29uZmlnKCk7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5nZXRCb29sZWFuKGtleSwgZmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICogQHBhcmFtIHs/PX0gZmFsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbmZpZy5wcm90b3R5cGUuZ2V0TnVtYmVyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgKiBAcGFyYW0gez89fSBmYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGtleSwgZmFsbGJhY2spIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgYyA9IGdldENvbmZpZygpO1xuICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGMuZ2V0TnVtYmVyKGtleSwgZmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29uZmlnLnByb3RvdHlwZS5zZXQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbREVQUkVDQVRJT05dW0NvbmZpZ106IFRoZSBDb25maWcuc2V0KCkgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBJb25pYyBGcmFtZXdvcmsgNi4wLiBQbGVhc2Ugc2VlIGh0dHBzOi8vaW9uaWNmcmFtZXdvcmsuY29tL2RvY3MvYW5ndWxhci9jb25maWcgZm9yIGFsdGVybmF0aXZlcy5cIik7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGMgPSBnZXRDb25maWcoKTtcbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgIGMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25maWcuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqLyBDb25maWcubmdJbmplY3RhYmxlRGVmID0gZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIENvbmZpZ19GYWN0b3J5KCkgeyByZXR1cm4gbmV3IENvbmZpZygpOyB9LCB0b2tlbjogQ29uZmlnLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbiAgICByZXR1cm4gQ29uZmlnO1xufSgpKTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBDb25maWdUb2tlbiA9IG5ldyBJbmplY3Rpb25Ub2tlbignVVNFUkNPTkZJRycpO1xuLyoqIEB0eXBlIHs/fSAqL1xudmFyIGdldENvbmZpZyA9ICgvKipcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mICgoLyoqIEB0eXBlIHs/fSAqLyAod2luZG93KSkpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBJb25pYyA9ICgoLyoqIEB0eXBlIHs/fSAqLyAoKC8qKiBAdHlwZSB7P30gKi8gKHdpbmRvdykpKSkpLklvbmljO1xuICAgICAgICBpZiAoSW9uaWMgJiYgSW9uaWMuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gSW9uaWMuY29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIFxcQGRlc2NyaXB0aW9uXG4gKiBOYXZQYXJhbXMgYXJlIGFuIG9iamVjdCB0aGF0IGV4aXN0cyBvbiBhIHBhZ2UgYW5kIGNhbiBjb250YWluIGRhdGEgZm9yIHRoYXQgcGFydGljdWxhciB2aWV3LlxuICogU2ltaWxhciB0byBob3cgZGF0YSB3YXMgcGFzcyB0byBhIHZpZXcgaW4gVjEgd2l0aCBgJHN0YXRlUGFyYW1zYCwgTmF2UGFyYW1zIG9mZmVyIGEgbXVjaCBtb3JlIGZsZXhpYmxlXG4gKiBvcHRpb24gd2l0aCBhIHNpbXBsZSBgZ2V0YCBtZXRob2QuXG4gKlxuICogXFxAdXNhZ2VcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBOYXZQYXJhbXMgfSBmcm9tICdcXEBpb25pYy9hbmd1bGFyJztcbiAqXG4gKiBleHBvcnQgY2xhc3MgTXlDbGFzc3tcbiAqXG4gKiAgY29uc3RydWN0b3IobmF2UGFyYW1zOiBOYXZQYXJhbXMpe1xuICogICAgLy8gdXNlclBhcmFtcyBpcyBhbiBvYmplY3Qgd2UgaGF2ZSBpbiBvdXIgbmF2LXBhcmFtZXRlcnNcbiAqICAgIG5hdlBhcmFtcy5nZXQoJ3VzZXJQYXJhbXMnKTtcbiAqICB9XG4gKlxuICogfVxuICogYGBgXG4gKi9cbnZhciAgLyoqXG4gKiBcXEBkZXNjcmlwdGlvblxuICogTmF2UGFyYW1zIGFyZSBhbiBvYmplY3QgdGhhdCBleGlzdHMgb24gYSBwYWdlIGFuZCBjYW4gY29udGFpbiBkYXRhIGZvciB0aGF0IHBhcnRpY3VsYXIgdmlldy5cbiAqIFNpbWlsYXIgdG8gaG93IGRhdGEgd2FzIHBhc3MgdG8gYSB2aWV3IGluIFYxIHdpdGggYCRzdGF0ZVBhcmFtc2AsIE5hdlBhcmFtcyBvZmZlciBhIG11Y2ggbW9yZSBmbGV4aWJsZVxuICogb3B0aW9uIHdpdGggYSBzaW1wbGUgYGdldGAgbWV0aG9kLlxuICpcbiAqIFxcQHVzYWdlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgTmF2UGFyYW1zIH0gZnJvbSAnXFxAaW9uaWMvYW5ndWxhcic7XG4gKlxuICogZXhwb3J0IGNsYXNzIE15Q2xhc3N7XG4gKlxuICogIGNvbnN0cnVjdG9yKG5hdlBhcmFtczogTmF2UGFyYW1zKXtcbiAqICAgIC8vIHVzZXJQYXJhbXMgaXMgYW4gb2JqZWN0IHdlIGhhdmUgaW4gb3VyIG5hdi1wYXJhbWV0ZXJzXG4gKiAgICBuYXZQYXJhbXMuZ2V0KCd1c2VyUGFyYW1zJyk7XG4gKiAgfVxuICpcbiAqIH1cbiAqIGBgYFxuICovXG5OYXZQYXJhbXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmF2UGFyYW1zKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkgeyBkYXRhID0ge307IH1cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiBhIG5hdi1wYXJhbWV0ZXIgZm9yIHRoZSBjdXJyZW50IHZpZXdcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgTmF2UGFyYW1zIH0gZnJvbSAnaW9uaWMtYW5ndWxhcic7XG4gICAgICpcbiAgICAgKiBleHBvcnQgY2xhc3MgTXlDbGFzc3tcbiAgICAgKiAgY29uc3RydWN0b3IocHVibGljIG5hdlBhcmFtczogTmF2UGFyYW1zKXtcbiAgICAgKiAgICAvLyB1c2VyUGFyYW1zIGlzIGFuIG9iamVjdCB3ZSBoYXZlIGluIG91ciBuYXYtcGFyYW1ldGVyc1xuICAgICAqICAgIHRoaXMubmF2UGFyYW1zLmdldCgndXNlclBhcmFtcycpO1xuICAgICAqICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtIFdoaWNoIHBhcmFtIHlvdSB3YW50IHRvIGxvb2sgdXBcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgbmF2LXBhcmFtZXRlciBmb3IgdGhlIGN1cnJlbnQgdmlld1xuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBOYXZQYXJhbXMgfSBmcm9tICdpb25pYy1hbmd1bGFyJztcbiAgICAgKlxuICAgICAqIGV4cG9ydCBjbGFzcyBNeUNsYXNze1xuICAgICAqICBjb25zdHJ1Y3RvcihwdWJsaWMgbmF2UGFyYW1zOiBOYXZQYXJhbXMpe1xuICAgICAqICAgIC8vIHVzZXJQYXJhbXMgaXMgYW4gb2JqZWN0IHdlIGhhdmUgaW4gb3VyIG5hdi1wYXJhbWV0ZXJzXG4gICAgICogICAgdGhpcy5uYXZQYXJhbXMuZ2V0KCd1c2VyUGFyYW1zJyk7XG4gICAgICogIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtIFdoaWNoIHBhcmFtIHlvdSB3YW50IHRvIGxvb2sgdXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdlBhcmFtcy5wcm90b3R5cGUuZ2V0ID0gLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiBhIG5hdi1wYXJhbWV0ZXIgZm9yIHRoZSBjdXJyZW50IHZpZXdcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgTmF2UGFyYW1zIH0gZnJvbSAnaW9uaWMtYW5ndWxhcic7XG4gICAgICpcbiAgICAgKiBleHBvcnQgY2xhc3MgTXlDbGFzc3tcbiAgICAgKiAgY29uc3RydWN0b3IocHVibGljIG5hdlBhcmFtczogTmF2UGFyYW1zKXtcbiAgICAgKiAgICAvLyB1c2VyUGFyYW1zIGlzIGFuIG9iamVjdCB3ZSBoYXZlIGluIG91ciBuYXYtcGFyYW1ldGVyc1xuICAgICAqICAgIHRoaXMubmF2UGFyYW1zLmdldCgndXNlclBhcmFtcycpO1xuICAgICAqICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbSBXaGljaCBwYXJhbSB5b3Ugd2FudCB0byBsb29rIHVwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtwYXJhbV07XG4gICAgfTtcbiAgICByZXR1cm4gTmF2UGFyYW1zO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBBbmd1bGFyRGVsZWdhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5ndWxhckRlbGVnYXRlKHpvbmUsIGFwcFJlZikge1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLmFwcFJlZiA9IGFwcFJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gaW5qZWN0b3JcbiAgICAgKiBAcGFyYW0gez89fSBsb2NhdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5ndWxhckRlbGVnYXRlLnByb3RvdHlwZS5jcmVhdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBpbmplY3RvclxuICAgICAqIEBwYXJhbSB7Pz19IGxvY2F0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVzb2x2ZXIsIGluamVjdG9yLCBsb2NhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IEFuZ3VsYXJGcmFtZXdvcmtEZWxlZ2F0ZShyZXNvbHZlciwgaW5qZWN0b3IsIGxvY2F0aW9uLCB0aGlzLmFwcFJlZiwgdGhpcy56b25lKTtcbiAgICB9O1xuICAgIEFuZ3VsYXJEZWxlZ2F0ZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEFuZ3VsYXJEZWxlZ2F0ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICAgICAgeyB0eXBlOiBBcHBsaWNhdGlvblJlZiB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gQW5ndWxhckRlbGVnYXRlO1xufSgpKTtcbnZhciBBbmd1bGFyRnJhbWV3b3JrRGVsZWdhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5ndWxhckZyYW1ld29ya0RlbGVnYXRlKHJlc29sdmVyLCBpbmplY3RvciwgbG9jYXRpb24sIGFwcFJlZiwgem9uZSkge1xuICAgICAgICB0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLmFwcFJlZiA9IGFwcFJlZjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5lbFJlZk1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuZWxFdmVudHNNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHs/PX0gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/PX0gY3NzQ2xhc3Nlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5ndWxhckZyYW1ld29ya0RlbGVnYXRlLnByb3RvdHlwZS5hdHRhY2hWaWV3VG9Eb20gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHs/PX0gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/PX0gY3NzQ2xhc3Nlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvbnRhaW5lciwgY29tcG9uZW50LCBwYXJhbXMsIGNzc0NsYXNzZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuem9uZS5ydW4oKC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gcmVzb2x2ZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIGVsID0gYXR0YWNoVmlldyhfdGhpcy56b25lLCBfdGhpcy5yZXNvbHZlciwgX3RoaXMuaW5qZWN0b3IsIF90aGlzLmxvY2F0aW9uLCBfdGhpcy5hcHBSZWYsIF90aGlzLmVsUmVmTWFwLCBfdGhpcy5lbEV2ZW50c01hcCwgY29udGFpbmVyLCBjb21wb25lbnQsIHBhcmFtcywgY3NzQ2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2NvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmd1bGFyRnJhbWV3b3JrRGVsZWdhdGUucHJvdG90eXBlLnJlbW92ZVZpZXdGcm9tRG9tID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBfY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChfY29udGFpbmVyLCBjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuem9uZS5ydW4oKC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gcmVzb2x2ZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFJlZiA9IF90aGlzLmVsUmVmTWFwLmdldChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZWxSZWZNYXAuZGVsZXRlKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVuYmluZEV2ZW50cyA9IF90aGlzLmVsRXZlbnRzTWFwLmdldChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5iaW5kRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVsRXZlbnRzTWFwLmRlbGV0ZShjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEFuZ3VsYXJGcmFtZXdvcmtEZWxlZ2F0ZTtcbn0oKSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgYXR0YWNoVmlldyA9ICgvKipcbiAqIEBwYXJhbSB7P30gem9uZVxuICogQHBhcmFtIHs/fSByZXNvbHZlclxuICogQHBhcmFtIHs/fSBpbmplY3RvclxuICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICogQHBhcmFtIHs/fSBhcHBSZWZcbiAqIEBwYXJhbSB7P30gZWxSZWZNYXBcbiAqIEBwYXJhbSB7P30gZWxFdmVudHNNYXBcbiAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICogQHBhcmFtIHs/fSBwYXJhbXNcbiAqIEBwYXJhbSB7P30gY3NzQ2xhc3Nlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKHpvbmUsIHJlc29sdmVyLCBpbmplY3RvciwgbG9jYXRpb24sIGFwcFJlZiwgZWxSZWZNYXAsIGVsRXZlbnRzTWFwLCBjb250YWluZXIsIGNvbXBvbmVudCwgcGFyYW1zLCBjc3NDbGFzc2VzKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIHZhciBmYWN0b3J5ID0gcmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50KTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgdmFyIGNoaWxkSW5qZWN0b3IgPSBJbmplY3Rvci5jcmVhdGUoe1xuICAgICAgICBwcm92aWRlcnM6IGdldFByb3ZpZGVycyhwYXJhbXMpLFxuICAgICAgICBwYXJlbnQ6IGluamVjdG9yXG4gICAgfSk7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIHZhciBjb21wb25lbnRSZWYgPSAobG9jYXRpb24pXG4gICAgICAgID8gbG9jYXRpb24uY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIGxvY2F0aW9uLmxlbmd0aCwgY2hpbGRJbmplY3RvcilcbiAgICAgICAgOiBmYWN0b3J5LmNyZWF0ZShjaGlsZEluamVjdG9yKTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgdmFyIGluc3RhbmNlID0gY29tcG9uZW50UmVmLmluc3RhbmNlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICB2YXIgaG9zdEVsZW1lbnQgPSBjb21wb25lbnRSZWYubG9jYXRpb24ubmF0aXZlRWxlbWVudDtcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgfVxuICAgIGlmIChjc3NDbGFzc2VzKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgY3NzQ2xhc3Nlc18xID0gY3NzQ2xhc3NlczsgX2kgPCBjc3NDbGFzc2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2xhenogPSBjc3NDbGFzc2VzXzFbX2ldO1xuICAgICAgICAgICAgaG9zdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGF6eik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIHZhciB1bmJpbmRFdmVudHMgPSBiaW5kTGlmZWN5Y2xlRXZlbnRzKHpvbmUsIGluc3RhbmNlLCBob3N0RWxlbWVudCk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGhvc3RFbGVtZW50KTtcbiAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICAgIGFwcFJlZi5hdHRhY2hWaWV3KGNvbXBvbmVudFJlZi5ob3N0Vmlldyk7XG4gICAgfVxuICAgIGNvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZi5yZWF0dGFjaCgpO1xuICAgIGVsUmVmTWFwLnNldChob3N0RWxlbWVudCwgY29tcG9uZW50UmVmKTtcbiAgICBlbEV2ZW50c01hcC5zZXQoaG9zdEVsZW1lbnQsIHVuYmluZEV2ZW50cyk7XG4gICAgcmV0dXJuIGhvc3RFbGVtZW50O1xufSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgTElGRUNZQ0xFUyA9IFtcbiAgICBMSUZFQ1lDTEVfV0lMTF9FTlRFUixcbiAgICBMSUZFQ1lDTEVfRElEX0VOVEVSLFxuICAgIExJRkVDWUNMRV9XSUxMX0xFQVZFLFxuICAgIExJRkVDWUNMRV9ESURfTEVBVkUsXG4gICAgTElGRUNZQ0xFX1dJTExfVU5MT0FEXG5dO1xuLyoqIEB0eXBlIHs/fSAqL1xudmFyIGJpbmRMaWZlY3ljbGVFdmVudHMgPSAoLyoqXG4gKiBAcGFyYW0gez99IHpvbmVcbiAqIEBwYXJhbSB7P30gaW5zdGFuY2VcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKHpvbmUsIGluc3RhbmNlLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIHpvbmUucnVuKCgvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgdW5yZWdpc3RlcnMgPSBMSUZFQ1lDTEVTXG4gICAgICAgICAgICAuZmlsdGVyKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIChldmVudE5hbWUpIHsgcmV0dXJuIHR5cGVvZiBpbnN0YW5jZVtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nOyB9KSlcbiAgICAgICAgICAgIC5tYXAoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSAoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGV2XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIGluc3RhbmNlW2V2ZW50TmFtZV0oZXYuZGV0YWlsKTsgfSk7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiAoLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTsgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuICgvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVucmVnaXN0ZXJzLmZvckVhY2goKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pKTsgfSk7XG4gICAgfSkpO1xufSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgTmF2UGFyYW1zVG9rZW4gPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05hdlBhcmFtc1Rva2VuJyk7XG4vKiogQHR5cGUgez99ICovXG52YXIgZ2V0UHJvdmlkZXJzID0gKC8qKlxuICogQHBhcmFtIHs/fSBwYXJhbXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBOYXZQYXJhbXNUb2tlbiwgdXNlVmFsdWU6IHBhcmFtc1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBOYXZQYXJhbXMsIHVzZUZhY3Rvcnk6IHByb3ZpZGVOYXZQYXJhbXNJbmplY3RhYmxlLCBkZXBzOiBbTmF2UGFyYW1zVG9rZW5dXG4gICAgICAgIH1cbiAgICBdO1xufSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgcHJvdmlkZU5hdlBhcmFtc0luamVjdGFibGUgPSAoLyoqXG4gKiBAcGFyYW0gez99IHBhcmFtc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgTmF2UGFyYW1zKHBhcmFtcyk7XG59KTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKiBAdHlwZSB7P30gKi9cbnZhciBpbnNlcnRWaWV3ID0gKC8qKlxuICogQHBhcmFtIHs/fSB2aWV3c1xuICogQHBhcmFtIHs/fSB2aWV3XG4gKiBAcGFyYW0gez99IGRpcmVjdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKHZpZXdzLCB2aWV3LCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAncm9vdCcpIHtcbiAgICAgICAgcmV0dXJuIHNldFJvb3Qodmlld3MsIHZpZXcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgICByZXR1cm4gc2V0Rm9yd2FyZCh2aWV3cywgdmlldyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2V0QmFjayh2aWV3cywgdmlldyk7XG4gICAgfVxufSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgc2V0Um9vdCA9ICgvKipcbiAqIEBwYXJhbSB7P30gdmlld3NcbiAqIEBwYXJhbSB7P30gdmlld1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKHZpZXdzLCB2aWV3KSB7XG4gICAgdmlld3MgPSB2aWV3cy5maWx0ZXIoKC8qKlxuICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuc3RhY2tJZCAhPT0gdmlldy5zdGFja0lkOyB9KSk7XG4gICAgdmlld3MucHVzaCh2aWV3KTtcbiAgICByZXR1cm4gdmlld3M7XG59KTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBzZXRGb3J3YXJkID0gKC8qKlxuICogQHBhcmFtIHs/fSB2aWV3c1xuICogQHBhcmFtIHs/fSB2aWV3XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiAodmlld3MsIHZpZXcpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgdmFyIGluZGV4ID0gdmlld3MuaW5kZXhPZih2aWV3KTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2aWV3cyA9IHZpZXdzLmZpbHRlcigoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuc3RhY2tJZCAhPT0gdmlldy5zdGFja0lkIHx8IHYuaWQgPD0gdmlldy5pZDsgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlld3MucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdzO1xufSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgc2V0QmFjayA9ICgvKipcbiAqIEBwYXJhbSB7P30gdmlld3NcbiAqIEBwYXJhbSB7P30gdmlld1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKHZpZXdzLCB2aWV3KSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIHZhciBpbmRleCA9IHZpZXdzLmluZGV4T2Yodmlldyk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIHZpZXdzLmZpbHRlcigoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuc3RhY2tJZCAhPT0gdmlldy5zdGFja0lkIHx8IHYuaWQgPD0gdmlldy5pZDsgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNldFJvb3Qodmlld3MsIHZpZXcpO1xuICAgIH1cbn0pO1xuLyoqIEB0eXBlIHs/fSAqL1xudmFyIGdldFVybCA9ICgvKipcbiAqIEBwYXJhbSB7P30gcm91dGVyXG4gKiBAcGFyYW0gez99IGFjdGl2YXRlZFJvdXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiAocm91dGVyLCBhY3RpdmF0ZWRSb3V0ZSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICB2YXIgdXJsVHJlZSA9IHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnLiddLCB7IHJlbGF0aXZlVG86IGFjdGl2YXRlZFJvdXRlIH0pO1xuICAgIHJldHVybiByb3V0ZXIuc2VyaWFsaXplVXJsKHVybFRyZWUpO1xufSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgaXNUYWJTd2l0Y2ggPSAoLyoqXG4gKiBAcGFyYW0gez99IGVudGVyaW5nVmlld1xuICogQHBhcmFtIHs/fSBsZWF2aW5nVmlld1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKGVudGVyaW5nVmlldywgbGVhdmluZ1ZpZXcpIHtcbiAgICBpZiAoIWxlYXZpbmdWaWV3KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZW50ZXJpbmdWaWV3LnN0YWNrSWQgIT09IGxlYXZpbmdWaWV3LnN0YWNrSWQ7XG59KTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBjb21wdXRlU3RhY2tJZCA9ICgvKipcbiAqIEBwYXJhbSB7P30gcHJlZml4VXJsXG4gKiBAcGFyYW0gez99IHVybFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKHByZWZpeFVybCwgdXJsKSB7XG4gICAgaWYgKCFwcmVmaXhVcmwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIHZhciBzZWdtZW50cyA9IHRvU2VnbWVudHModXJsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID49IHByZWZpeFVybC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VnbWVudHNbaV0gIT09IHByZWZpeFVybFtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufSk7XG4vKiogQHR5cGUgez99ICovXG52YXIgdG9TZWdtZW50cyA9ICgvKipcbiAqIEBwYXJhbSB7P30gcGF0aFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aFxuICAgICAgICAuc3BsaXQoJy8nKVxuICAgICAgICAubWFwKCgvKipcbiAgICAgKiBAcGFyYW0gez99IHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRyaW0oKTsgfSkpXG4gICAgICAgIC5maWx0ZXIoKC8qKlxuICAgICAqIEBwYXJhbSB7P30gc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMgIT09ICcnOyB9KSk7XG59KTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBkZXN0cm95VmlldyA9ICgvKipcbiAqIEBwYXJhbSB7P30gdmlld1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gKHZpZXcpIHtcbiAgICBpZiAodmlldykge1xuICAgICAgICAvLyBUT0RPIGxpZmVjeWNsZSBldmVudFxuICAgICAgICB2aWV3LnJlZi5kZXN0cm95KCk7XG4gICAgICAgIHZpZXcudW5saXN0ZW5FdmVudHMoKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBTdGFja0NvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhY2tDb250cm9sbGVyKHRhYnNQcmVmaXgsIGNvbnRhaW5lckVsLCByb3V0ZXIsIG5hdkN0cmwsIHpvbmUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwgPSBjb250YWluZXJFbDtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMubmF2Q3RybCA9IG5hdkN0cmw7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnNraXBUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV4dElkID0gMDtcbiAgICAgICAgdGhpcy50YWJzUHJlZml4ID0gdGFic1ByZWZpeCAhPT0gdW5kZWZpbmVkID8gdG9TZWdtZW50cyh0YWJzUHJlZml4KSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZWZcbiAgICAgKiBAcGFyYW0gez99IGFjdGl2YXRlZFJvdXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGFja0NvbnRyb2xsZXIucHJvdG90eXBlLmNyZWF0ZVZpZXcgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlZlxuICAgICAqIEBwYXJhbSB7P30gYWN0aXZhdGVkUm91dGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZWYsIGFjdGl2YXRlZFJvdXRlKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHVybCA9IGdldFVybCh0aGlzLnJvdXRlciwgYWN0aXZhdGVkUm91dGUpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBlbGVtZW50ID0gKC8qKiBAdHlwZSB7P30gKi8gKChyZWYgJiYgcmVmLmxvY2F0aW9uICYmIHJlZi5sb2NhdGlvbi5uYXRpdmVFbGVtZW50KSkpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciB1bmxpc3RlbkV2ZW50cyA9IGJpbmRMaWZlY3ljbGVFdmVudHModGhpcy56b25lLCByZWYuaW5zdGFuY2UsIGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMubmV4dElkKyssXG4gICAgICAgICAgICBzdGFja0lkOiBjb21wdXRlU3RhY2tJZCh0aGlzLnRhYnNQcmVmaXgsIHVybCksXG4gICAgICAgICAgICB1bmxpc3RlbkV2ZW50czogdW5saXN0ZW5FdmVudHMsXG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgcmVmOiByZWYsXG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYWN0aXZhdGVkUm91dGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YWNrQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0RXhpc3RpbmdWaWV3ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhY3RpdmF0ZWRSb3V0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFjdGl2YXRlZFJvdXRlKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGFjdGl2YXRlZFVybEtleSA9IGdldFVybCh0aGlzLnJvdXRlciwgYWN0aXZhdGVkUm91dGUpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3cy5maW5kKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2d1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHZ3KSB7IHJldHVybiB2dy51cmwgPT09IGFjdGl2YXRlZFVybEtleTsgfSkpO1xuICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgdmlldy5yZWYuY2hhbmdlRGV0ZWN0b3JSZWYucmVhdHRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZW50ZXJpbmdWaWV3XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGFja0NvbnRyb2xsZXIucHJvdG90eXBlLnNldEFjdGl2ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZW50ZXJpbmdWaWV3XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZW50ZXJpbmdWaWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMubmF2Q3RybC5jb25zdW1lVHJhbnNpdGlvbigpLCBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb24sIGFuaW1hdGlvbiA9IF9hLmFuaW1hdGlvbjtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgbGVhdmluZ1ZpZXcgPSB0aGlzLmFjdGl2ZVZpZXc7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHRhYlN3aXRjaCA9IGlzVGFiU3dpdGNoKGVudGVyaW5nVmlldywgbGVhdmluZ1ZpZXcpO1xuICAgICAgICBpZiAodGFiU3dpdGNoKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAnYmFjayc7XG4gICAgICAgICAgICBhbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgdmlld3NTbmFwc2hvdCA9IHRoaXMudmlld3Muc2xpY2UoKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgY3VycmVudE5hdmlnYXRpb247XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHJvdXRlciA9ICgoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5yb3V0ZXIpKSk7XG4gICAgICAgIC8vIEFuZ3VsYXIgPj0gNy4yLjBcbiAgICAgICAgaWYgKHJvdXRlci5nZXRDdXJyZW50TmF2aWdhdGlvbikge1xuICAgICAgICAgICAgY3VycmVudE5hdmlnYXRpb24gPSByb3V0ZXIuZ2V0Q3VycmVudE5hdmlnYXRpb24oKTtcbiAgICAgICAgICAgIC8vIEFuZ3VsYXIgPCA3LjIuMFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvdXRlci5uYXZpZ2F0aW9ucyAmJlxuICAgICAgICAgICAgcm91dGVyLm5hdmlnYXRpb25zLnZhbHVlKSB7XG4gICAgICAgICAgICBjdXJyZW50TmF2aWdhdGlvbiA9IHJvdXRlci5uYXZpZ2F0aW9ucy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIG5hdmlnYXRpb24gYWN0aW9uXG4gICAgICAgICAqIHNldHMgYHJlcGxhY2VVcmw6IHRydWVgXG4gICAgICAgICAqIHRoZW4gd2UgbmVlZCB0byBtYWtlIHN1cmVcbiAgICAgICAgICogd2UgcmVtb3ZlIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgICogZnJvbSBvdXIgdmlld3Mgc3RhY2tcbiAgICAgICAgICovXG4gICAgICAgIGlmIChjdXJyZW50TmF2aWdhdGlvbiAmJlxuICAgICAgICAgICAgY3VycmVudE5hdmlnYXRpb24uZXh0cmFzICYmXG4gICAgICAgICAgICBjdXJyZW50TmF2aWdhdGlvbi5leHRyYXMucmVwbGFjZVVybCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlld3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3Muc3BsaWNlKC0xLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciByZXVzZWQgPSB0aGlzLnZpZXdzLmluY2x1ZGVzKGVudGVyaW5nVmlldyk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHZpZXdzID0gdGhpcy5pbnNlcnRWaWV3KGVudGVyaW5nVmlldywgZGlyZWN0aW9uKTtcbiAgICAgICAgLy8gVHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIGJlZm9yZSB0cmFuc2l0aW9uIHN0YXJ0c1xuICAgICAgICAvLyBUaGlzIHdpbGwgY2FsbCBuZ09uSW5pdCgpIHRoZSBmaXJzdCB0aW1lIHRvbywganVzdCBhZnRlciB0aGUgdmlld1xuICAgICAgICAvLyB3YXMgYXR0YWNoZWQgdG8gdGhlIGRvbSwgYnV0IEJFRk9SRSB0aGUgdHJhbnNpdGlvbiBzdGFydHNcbiAgICAgICAgaWYgKCFyZXVzZWQpIHtcbiAgICAgICAgICAgIGVudGVyaW5nVmlldy5yZWYuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgdW50aWwgcHJldmlvdXMgdHJhbnNpdGlvbnMgZmluaXNoXG4gICAgICAgIHJldHVybiB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLndhaXQoKC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGRpc2Nvbm5lY3QgbGVhdmluZyBwYWdlIGZyb20gY2hhbmdlIGRldGVjdGlvbiB0b1xuICAgICAgICAgICAgICAgIC8vIHJlZHVjZSBqYW5rIGR1cmluZyB0aGUgcGFnZSB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGxlYXZpbmdWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdWaWV3LnJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgZW50ZXJpbmdWaWV3IGlzIHRoZSBzYW1lIGFzIHRoZSBsZWF2aW5nUGFnZSB3ZSBuZWVkIHRvIHJlYXR0YWNoKClcbiAgICAgICAgICAgICAgICBlbnRlcmluZ1ZpZXcucmVmLmNoYW5nZURldGVjdG9yUmVmLnJlYXR0YWNoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zaXRpb24oZW50ZXJpbmdWaWV3LCBsZWF2aW5nVmlldywgYW5pbWF0aW9uLCBfdGhpcy5jYW5Hb0JhY2soMSksIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoLyoqXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhbnVwQXN5bmMoZW50ZXJpbmdWaWV3LCB2aWV3cywgdmlld3NTbmFwc2hvdCwgX3RoaXMubG9jYXRpb24pOyB9KSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKC8qKlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgZW50ZXJpbmdWaWV3OiBlbnRlcmluZ1ZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGFiU3dpdGNoOiB0YWJTd2l0Y2hcbiAgICAgICAgICAgICAgICB9KTsgfSkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlZXBcbiAgICAgKiBAcGFyYW0gez89fSBzdGFja0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGFja0NvbnRyb2xsZXIucHJvdG90eXBlLmNhbkdvQmFjayA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVlcFxuICAgICAqIEBwYXJhbSB7Pz19IHN0YWNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChkZWVwLCBzdGFja0lkKSB7XG4gICAgICAgIGlmIChzdGFja0lkID09PSB2b2lkIDApIHsgc3RhY2tJZCA9IHRoaXMuZ2V0QWN0aXZlU3RhY2tJZCgpOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrKHN0YWNrSWQpLmxlbmd0aCA+IGRlZXA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlZXBcbiAgICAgKiBAcGFyYW0gez89fSBzdGFja0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGFja0NvbnRyb2xsZXIucHJvdG90eXBlLnBvcCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVlcFxuICAgICAqIEBwYXJhbSB7Pz19IHN0YWNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChkZWVwLCBzdGFja0lkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzdGFja0lkID09PSB2b2lkIDApIHsgc3RhY2tJZCA9IHRoaXMuZ2V0QWN0aXZlU3RhY2tJZCgpOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnpvbmUucnVuKCgvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciB2aWV3cyA9IF90aGlzLmdldFN0YWNrKHN0YWNrSWQpO1xuICAgICAgICAgICAgaWYgKHZpZXdzLmxlbmd0aCA8PSBkZWVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgdmlldyA9IHZpZXdzW3ZpZXdzLmxlbmd0aCAtIGRlZXAgLSAxXTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciB1cmwgPSB2aWV3LnVybDtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciB2aWV3U2F2ZWREYXRhID0gdmlldy5zYXZlZERhdGE7XG4gICAgICAgICAgICBpZiAodmlld1NhdmVkRGF0YSkge1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeU91dGxldCA9IHZpZXdTYXZlZERhdGEuZ2V0KCdwcmltYXJ5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHByaW1hcnlPdXRsZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeU91dGxldC5yb3V0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5T3V0bGV0LnJvdXRlLl9yb3V0ZXJTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5T3V0bGV0LnJvdXRlLl9yb3V0ZXJTdGF0ZS5zbmFwc2hvdCAmJlxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5T3V0bGV0LnJvdXRlLl9yb3V0ZXJTdGF0ZS5zbmFwc2hvdC51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gcHJpbWFyeU91dGxldC5yb3V0ZS5fcm91dGVyU3RhdGUuc25hcHNob3QudXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5uYXZDdHJsLm5hdmlnYXRlQmFjayh1cmwsIHZpZXcuc2F2ZWRFeHRyYXMpLnRoZW4oKC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSkpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YWNrQ29udHJvbGxlci5wcm90b3R5cGUuc3RhcnRCYWNrVHJhbnNpdGlvbiA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBsZWF2aW5nVmlldyA9IHRoaXMuYWN0aXZlVmlldztcbiAgICAgICAgaWYgKGxlYXZpbmdWaWV3KSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgdmlld3MgPSB0aGlzLmdldFN0YWNrKGxlYXZpbmdWaWV3LnN0YWNrSWQpO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIGVudGVyaW5nVmlld18xID0gdmlld3Nbdmlld3MubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWl0KCgvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNpdGlvbihlbnRlcmluZ1ZpZXdfMSwgLy8gZW50ZXJpbmcgdmlld1xuICAgICAgICAgICAgICAgIGxlYXZpbmdWaWV3LCAvLyBsZWF2aW5nIHZpZXdcbiAgICAgICAgICAgICAgICAnYmFjaycsIF90aGlzLmNhbkdvQmFjaygyKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzaG91bGRDb21wbGV0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhY2tDb250cm9sbGVyLnByb3RvdHlwZS5lbmRCYWNrVHJhbnNpdGlvbiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2hvdWxkQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChzaG91bGRDb21wbGV0ZSkge1xuICAgICAgICBpZiAoc2hvdWxkQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcFRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wb3AoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmVWaWV3KSB7XG4gICAgICAgICAgICBjbGVhbnVwKHRoaXMuYWN0aXZlVmlldywgdGhpcy52aWV3cywgdGhpcy52aWV3cywgdGhpcy5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHN0YWNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YWNrQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0TGFzdFVybCA9IC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHN0YWNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChzdGFja0lkKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHZpZXdzID0gdGhpcy5nZXRTdGFjayhzdGFja0lkKTtcbiAgICAgICAgcmV0dXJuIHZpZXdzLmxlbmd0aCA+IDAgPyB2aWV3c1t2aWV3cy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhY2tDb250cm9sbGVyLnByb3RvdHlwZS5nZXRBY3RpdmVTdGFja0lkID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZpZXcgPyB0aGlzLmFjdGl2ZVZpZXcuc3RhY2tJZCA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhY2tDb250cm9sbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwgPSAoLyoqIEB0eXBlIHs/fSAqLyAodW5kZWZpbmVkKSk7XG4gICAgICAgIHRoaXMudmlld3MuZm9yRWFjaChkZXN0cm95Vmlldyk7XG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHN0YWNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YWNrQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U3RhY2sgPSAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gc3RhY2tJZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHN0YWNrSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3MuZmlsdGVyKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAodikgeyByZXR1cm4gdi5zdGFja0lkID09PSBzdGFja0lkOyB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gZW50ZXJpbmdWaWV3XG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3Rpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YWNrQ29udHJvbGxlci5wcm90b3R5cGUuaW5zZXJ0VmlldyA9IC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBlbnRlcmluZ1ZpZXdcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVudGVyaW5nVmlldywgZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IGVudGVyaW5nVmlldztcbiAgICAgICAgdGhpcy52aWV3cyA9IGluc2VydFZpZXcodGhpcy52aWV3cywgZW50ZXJpbmdWaWV3LCBkaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cy5zbGljZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGVudGVyaW5nVmlld1xuICAgICAqIEBwYXJhbSB7P30gbGVhdmluZ1ZpZXdcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSB7P30gc2hvd0dvQmFja1xuICAgICAqIEBwYXJhbSB7P30gcHJvZ3Jlc3NBbmltYXRpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YWNrQ29udHJvbGxlci5wcm90b3R5cGUudHJhbnNpdGlvbiA9IC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBlbnRlcmluZ1ZpZXdcbiAgICAgKiBAcGFyYW0gez99IGxlYXZpbmdWaWV3XG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0gez99IHNob3dHb0JhY2tcbiAgICAgKiBAcGFyYW0gez99IHByb2dyZXNzQW5pbWF0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZW50ZXJpbmdWaWV3LCBsZWF2aW5nVmlldywgZGlyZWN0aW9uLCBzaG93R29CYWNrLCBwcm9ncmVzc0FuaW1hdGlvbikge1xuICAgICAgICBpZiAodGhpcy5za2lwVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5za2lwVHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYXZpbmdWaWV3ID09PSBlbnRlcmluZ1ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGVudGVyaW5nRWwgPSBlbnRlcmluZ1ZpZXcgPyBlbnRlcmluZ1ZpZXcuZWxlbWVudCA6IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgbGVhdmluZ0VsID0gbGVhdmluZ1ZpZXcgPyBsZWF2aW5nVmlldy5lbGVtZW50IDogdW5kZWZpbmVkO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBjb250YWluZXJFbCA9IHRoaXMuY29udGFpbmVyRWw7XG4gICAgICAgIGlmIChlbnRlcmluZ0VsICYmIGVudGVyaW5nRWwgIT09IGxlYXZpbmdFbCkge1xuICAgICAgICAgICAgZW50ZXJpbmdFbC5jbGFzc0xpc3QuYWRkKCdpb24tcGFnZScpO1xuICAgICAgICAgICAgZW50ZXJpbmdFbC5jbGFzc0xpc3QuYWRkKCdpb24tcGFnZS1pbnZpc2libGUnKTtcbiAgICAgICAgICAgIGlmIChlbnRlcmluZ0VsLnBhcmVudEVsZW1lbnQgIT09IGNvbnRhaW5lckVsKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWwuYXBwZW5kQ2hpbGQoZW50ZXJpbmdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKCgvKiogQHR5cGUgez99ICovIChjb250YWluZXJFbCkpKS5jb21taXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyRWwuY29tbWl0KGVudGVyaW5nRWwsIGxlYXZpbmdFbCwge1xuICAgICAgICAgICAgICAgICAgICBkZWVwV2FpdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHNob3dHb0JhY2s6IHNob3dHb0JhY2ssXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQW5pbWF0aW9uOiBwcm9ncmVzc0FuaW1hdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gdGFza1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhY2tDb250cm9sbGVyLnByb3RvdHlwZS53YWl0ID0gLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gdGFza1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLnJ1bm5pbmdUYXNrICE9PSB1bmRlZmluZWQpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucnVubmluZ1Rhc2tdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmdUYXNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gdGhpcy5ydW5uaW5nVGFzayA9IHRhc2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwcm9taXNlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhY2tDb250cm9sbGVyO1xufSgpKTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBjbGVhbnVwQXN5bmMgPSAoLyoqXG4gKiBAcGFyYW0gez99IGFjdGl2ZVJvdXRlXG4gKiBAcGFyYW0gez99IHZpZXdzXG4gKiBAcGFyYW0gez99IHZpZXdzU25hcHNob3RcbiAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIChhY3RpdmVSb3V0ZSwgdmlld3MsIHZpZXdzU25hcHNob3QsIGxvY2F0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiAoKC8qKiBAdHlwZSB7P30gKi8gKHJlcXVlc3RBbmltYXRpb25GcmFtZSkpKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHJlc29sdmVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoYWN0aXZlUm91dGUsIHZpZXdzLCB2aWV3c1NuYXBzaG90LCBsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn0pO1xuLyoqIEB0eXBlIHs/fSAqL1xudmFyIGNsZWFudXAgPSAoLyoqXG4gKiBAcGFyYW0gez99IGFjdGl2ZVJvdXRlXG4gKiBAcGFyYW0gez99IHZpZXdzXG4gKiBAcGFyYW0gez99IHZpZXdzU25hcHNob3RcbiAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIChhY3RpdmVSb3V0ZSwgdmlld3MsIHZpZXdzU25hcHNob3QsIGxvY2F0aW9uKSB7XG4gICAgdmlld3NTbmFwc2hvdFxuICAgICAgICAuZmlsdGVyKCgvKipcbiAgICAgKiBAcGFyYW0gez99IHZpZXdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2aWV3KSB7IHJldHVybiAhdmlld3MuaW5jbHVkZXModmlldyk7IH0pKVxuICAgICAgICAuZm9yRWFjaChkZXN0cm95Vmlldyk7XG4gICAgdmlld3MuZm9yRWFjaCgoLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aWV3XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodmlldykge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW4gdGhlIGV2ZW50IHRoYXQgYSB1c2VyIG5hdmlnYXRlZCBtdWx0aXBsZVxuICAgICAgICAgKiB0aW1lcyBpbiByYXBpZCBzdWNjZXNzaW9uLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZVxuICAgICAgICAgKiB3ZSBkb24ndCBwcmUtZW1wdGl2ZWx5IGRldGFjaCBhIHZpZXcgd2hpbGVcbiAgICAgICAgICogaXQgaXMgaW4gbWlkLXRyYW5zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIHRoaXMgaW5zdGFuY2Ugd2UgYWxzbyBkbyBub3QgY2FyZSBhYm91dCBxdWVyeVxuICAgICAgICAgKiBwYXJhbXMgb3IgZnJhZ21lbnRzIGFzIGl0IHdpbGwgYmUgdGhlIHNhbWUgdmlldyByZWdhcmRsZXNzXG4gICAgICAgICAqIEB0eXBlIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGxvY2F0aW9uV2l0aG91dFBhcmFtcyA9IGxvY2F0aW9uLnBhdGgoKS5zcGxpdCgnPycpWzBdO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBsb2NhdGlvbldpdGhvdXRGcmFnbWVudCA9IGxvY2F0aW9uV2l0aG91dFBhcmFtcy5zcGxpdCgnIycpWzBdO1xuICAgICAgICBpZiAodmlldyAhPT0gYWN0aXZlUm91dGUgJiYgdmlldy51cmwgIT09IGxvY2F0aW9uV2l0aG91dEZyYWdtZW50KSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHZpZXcuZWxlbWVudDtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2lvbi1wYWdlLWhpZGRlbicpO1xuICAgICAgICAgICAgdmlldy5yZWYuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICB9KSk7XG59KTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBJb25Sb3V0ZXJPdXRsZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uUm91dGVyT3V0bGV0KHBhcmVudENvbnRleHRzLCBsb2NhdGlvbiwgcmVzb2x2ZXIsIG5hbWUsIHRhYnMsIGNvbmZpZywgbmF2Q3RybCwgY29tbW9uTG9jYXRpb24sIGVsZW1lbnRSZWYsIHJvdXRlciwgem9uZSwgYWN0aXZhdGVkUm91dGUsIHBhcmVudE91dGxldCkge1xuICAgICAgICB0aGlzLnBhcmVudENvbnRleHRzID0gcGFyZW50Q29udGV4dHM7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy5yZXNvbHZlciA9IHJlc29sdmVyO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5uYXZDdHJsID0gbmF2Q3RybDtcbiAgICAgICAgdGhpcy5wYXJlbnRPdXRsZXQgPSBwYXJlbnRPdXRsZXQ7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZWRWaWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGVkUm91dGUgPSBudWxsO1xuICAgICAgICAvLyBNYWludGFpbiBtYXAgb2YgYWN0aXZhdGVkIHJvdXRlIHByb3hpZXMgZm9yIGVhY2ggY29tcG9uZW50IGluc3RhbmNlXG4gICAgICAgIHRoaXMucHJveHlNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAvLyBLZWVwIHRoZSBsYXRlc3QgYWN0aXZhdGVkIHJvdXRlIGluIGEgc3ViamVjdCBmb3IgdGhlIHByb3h5IHJvdXRlcyB0byBzd2l0Y2ggbWFwIHRvXG4gICAgICAgIHRoaXMuY3VycmVudEFjdGl2YXRlZFJvdXRlJCA9IG5ldyBCZWhhdmlvclN1YmplY3QobnVsbCk7XG4gICAgICAgIHRoaXMuc3RhY2tFdmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVFdmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5uYXRpdmVFbCA9IGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZSB8fCBQUklNQVJZX09VVExFVDtcbiAgICAgICAgdGhpcy50YWJzUHJlZml4ID0gdGFicyA9PT0gJ3RydWUnID8gZ2V0VXJsKHJvdXRlciwgYWN0aXZhdGVkUm91dGUpIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YWNrQ3RybCA9IG5ldyBTdGFja0NvbnRyb2xsZXIodGhpcy50YWJzUHJlZml4LCB0aGlzLm5hdGl2ZUVsLCByb3V0ZXIsIG5hdkN0cmwsIHpvbmUsIGNvbW1vbkxvY2F0aW9uKTtcbiAgICAgICAgcGFyZW50Q29udGV4dHMub25DaGlsZE91dGxldENyZWF0ZWQodGhpcy5uYW1lLCAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcykpKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElvblJvdXRlck91dGxldC5wcm90b3R5cGUsIFwiYW5pbWF0ZWRcIiwge1xuICAgICAgICBzZXQ6IC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFuaW1hdGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoYW5pbWF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlRWwuYW5pbWF0ZWQgPSBhbmltYXRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElvblJvdXRlck91dGxldC5wcm90b3R5cGUsIFwic3dpcGVHZXN0dXJlXCIsIHtcbiAgICAgICAgc2V0OiAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBzd2lwZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHN3aXBlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fc3dpcGVHZXN0dXJlID0gc3dpcGU7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZUVsLnN3aXBlSGFuZGxlciA9IHN3aXBlID8ge1xuICAgICAgICAgICAgICAgIGNhblN0YXJ0OiAoLyoqXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdGFja0N0cmwuY2FuR29CYWNrKDEpOyB9KSxcbiAgICAgICAgICAgICAgICBvblN0YXJ0OiAoLyoqXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdGFja0N0cmwuc3RhcnRCYWNrVHJhbnNpdGlvbigpOyB9KSxcbiAgICAgICAgICAgICAgICBvbkVuZDogKC8qKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gc2hvdWxkQ29udGludWVcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzaG91bGRDb250aW51ZSkgeyByZXR1cm4gX3RoaXMuc3RhY2tDdHJsLmVuZEJhY2tUcmFuc2l0aW9uKHNob3VsZENvbnRpbnVlKTsgfSlcbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uUm91dGVyT3V0bGV0LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YWNrQ3RybC5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIElvblJvdXRlck91dGxldC5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRDb250ZXh0cy5nZXRDb250ZXh0KHRoaXMubmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIElvblJvdXRlck91dGxldC5wcm90b3R5cGUubmdPbkluaXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2YXRlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG91dGxldCB3YXMgbm90IGluc3RhbnRpYXRlZCBhdCB0aGUgdGltZSB0aGUgcm91dGUgZ290IGFjdGl2YXRlZCB3ZSBuZWVkIHRvIHBvcHVsYXRlXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGV0IHdoZW4gaXQgaXMgaW5pdGlhbGl6ZWQgKGllIGluc2lkZSBhIE5nSWYpXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5yb3V0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVXaXRoKGNvbnRleHQucm91dGUsIGNvbnRleHQucmVzb2x2ZXIgfHwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5uYXRpdmVFbCkpKS5jb21wb25lbnRPblJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZUVsLmNvbXBvbmVudE9uUmVhZHkoKS50aGVuKCgvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3N3aXBlR2VzdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN3aXBlR2VzdHVyZSA9IF90aGlzLmNvbmZpZy5nZXRCb29sZWFuKCdzd2lwZUJhY2tFbmFibGVkJywgKCgvKiogQHR5cGUgez99ICovIChfdGhpcy5uYXRpdmVFbCkpKS5tb2RlID09PSAnaW9zJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW9uUm91dGVyT3V0bGV0LnByb3RvdHlwZSwgXCJpc0FjdGl2YXRlZFwiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmFjdGl2YXRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElvblJvdXRlck91dGxldC5wcm90b3R5cGUsIFwiY29tcG9uZW50XCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dGxldCBpcyBub3QgYWN0aXZhdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZWQuaW5zdGFuY2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJb25Sb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImFjdGl2YXRlZFJvdXRlXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dGxldCBpcyBub3QgYWN0aXZhdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuX2FjdGl2YXRlZFJvdXRlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJb25Sb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImFjdGl2YXRlZFJvdXRlRGF0YVwiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZhdGVkUm91dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZhdGVkUm91dGUuc25hcHNob3QuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGBSb3V0ZVJldXNlU3RyYXRlZ3lgIGluc3RydWN0cyB0byBkZXRhY2ggdGhlIHN1YnRyZWVcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgYFJvdXRlUmV1c2VTdHJhdGVneWAgaW5zdHJ1Y3RzIHRvIGRldGFjaCB0aGUgc3VidHJlZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uUm91dGVyT3V0bGV0LnByb3RvdHlwZS5kZXRhY2ggPSAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgYFJvdXRlUmV1c2VTdHJhdGVneWAgaW5zdHJ1Y3RzIHRvIGRldGFjaCB0aGUgc3VidHJlZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29tcGF0aWJsZSByZXVzZSBzdHJhdGVneScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGBSb3V0ZVJldXNlU3RyYXRlZ3lgIGluc3RydWN0cyB0byByZS1hdHRhY2ggYSBwcmV2aW91c2x5IGRldGFjaGVkIHN1YnRyZWVcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgYFJvdXRlUmV1c2VTdHJhdGVneWAgaW5zdHJ1Y3RzIHRvIHJlLWF0dGFjaCBhIHByZXZpb3VzbHkgZGV0YWNoZWQgc3VidHJlZVxuICAgICAqIEBwYXJhbSB7P30gX3JlZlxuICAgICAqIEBwYXJhbSB7P30gX2FjdGl2YXRlZFJvdXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJb25Sb3V0ZXJPdXRsZXQucHJvdG90eXBlLmF0dGFjaCA9IC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBgUm91dGVSZXVzZVN0cmF0ZWd5YCBpbnN0cnVjdHMgdG8gcmUtYXR0YWNoIGEgcHJldmlvdXNseSBkZXRhY2hlZCBzdWJ0cmVlXG4gICAgICogQHBhcmFtIHs/fSBfcmVmXG4gICAgICogQHBhcmFtIHs/fSBfYWN0aXZhdGVkUm91dGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChfcmVmLCBfYWN0aXZhdGVkUm91dGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvbXBhdGlibGUgcmV1c2Ugc3RyYXRlZ3knKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uUm91dGVyT3V0bGV0LnByb3RvdHlwZS5kZWFjdGl2YXRlID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZhdGVkVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkVmlldy5zYXZlZERhdGEgPSBuZXcgTWFwKCgvKiogQHR5cGUgez99ICovICh0aGlzLmdldENvbnRleHQoKSkpLmNoaWxkcmVuWydjb250ZXh0cyddKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbnN1cmUgd2UgYXJlIHNhdmluZyB0aGUgTmF2aWdhdGlvbkV4dHJhc1xuICAgICAgICAgICAgICAgICAqIGRhdGEgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgbG9zdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkVmlldy5zYXZlZEV4dHJhcyA9IHt9O1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9ICgvKiogQHR5cGUgez99ICovICh0aGlzLmdldENvbnRleHQoKSkpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHRTbmFwc2hvdCA9IGNvbnRleHQucm91dGUuc25hcHNob3Q7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkVmlldy5zYXZlZEV4dHJhcy5xdWVyeVBhcmFtcyA9IGNvbnRleHRTbmFwc2hvdC5xdWVyeVBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZWRWaWV3LnNhdmVkRXh0cmFzLmZyYWdtZW50ID0gY29udGV4dFNuYXBzaG90LmZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlZFZpZXcgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVkUm91dGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlRXZlbnRzLmVtaXQoYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYWN0aXZhdGVkUm91dGVcbiAgICAgKiBAcGFyYW0gez99IHJlc29sdmVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJb25Sb3V0ZXJPdXRsZXQucHJvdG90eXBlLmFjdGl2YXRlV2l0aCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gYWN0aXZhdGVkUm91dGVcbiAgICAgKiBAcGFyYW0gez99IHJlc29sdmVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYWN0aXZhdGVkUm91dGUsIHJlc29sdmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhY3RpdmF0ZSBhbiBhbHJlYWR5IGFjdGl2YXRlZCBvdXRsZXQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hY3RpdmF0ZWRSb3V0ZSA9IGFjdGl2YXRlZFJvdXRlO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBjbXBSZWY7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGVudGVyaW5nVmlldyA9IHRoaXMuc3RhY2tDdHJsLmdldEV4aXN0aW5nVmlldyhhY3RpdmF0ZWRSb3V0ZSk7XG4gICAgICAgIGlmIChlbnRlcmluZ1ZpZXcpIHtcbiAgICAgICAgICAgIGNtcFJlZiA9IHRoaXMuYWN0aXZhdGVkID0gZW50ZXJpbmdWaWV3LnJlZjtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBzYXZlZCA9IGVudGVyaW5nVmlldy5zYXZlZERhdGE7XG4gICAgICAgICAgICBpZiAoc2F2ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzZWxmLXJlc3RvcmVcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5nZXRDb250ZXh0KCkpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNoaWxkcmVuWydjb250ZXh0cyddID0gc2F2ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGVkIGFjdGl2YXRlZCByb3V0ZSBwcm94eSBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQWN0aXZhdGVkUm91dGVQcm94eShjbXBSZWYuaW5zdGFuY2UsIGFjdGl2YXRlZFJvdXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9ICgoLyoqIEB0eXBlIHs/fSAqLyAoYWN0aXZhdGVkUm91dGUpKSkuX2Z1dHVyZVNuYXBzaG90O1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9ICgvKiogQHR5cGUgez99ICovICgoLyoqIEB0eXBlIHs/fSAqLyAoc25hcHNob3Qucm91dGVDb25maWcpKS5jb21wb25lbnQpKTtcbiAgICAgICAgICAgIHJlc29sdmVyID0gcmVzb2x2ZXIgfHwgdGhpcy5yZXNvbHZlcjtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gcmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50KTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBjaGlsZENvbnRleHRzID0gdGhpcy5wYXJlbnRDb250ZXh0cy5nZXRPckNyZWF0ZUNvbnRleHQodGhpcy5uYW1lKS5jaGlsZHJlbjtcbiAgICAgICAgICAgIC8vIFdlIGNyZWF0ZSBhbiBhY3RpdmF0ZWQgcm91dGUgcHJveHkgb2JqZWN0IHRoYXQgd2lsbCBtYWludGFpbiBmdXR1cmUgdXBkYXRlcyBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIG92ZXIgaXRzIGxpZmVjeWNsZSBpbiB0aGUgc3RhY2suXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50JCA9IG5ldyBCZWhhdmlvclN1YmplY3QobnVsbCk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgYWN0aXZhdGVkUm91dGVQcm94eSA9IHRoaXMuY3JlYXRlQWN0aXZhdGVkUm91dGVQcm94eShjb21wb25lbnQkLCBhY3RpdmF0ZWRSb3V0ZSk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgaW5qZWN0b3IgPSBuZXcgT3V0bGV0SW5qZWN0b3IoYWN0aXZhdGVkUm91dGVQcm94eSwgY2hpbGRDb250ZXh0cywgdGhpcy5sb2NhdGlvbi5pbmplY3Rvcik7XG4gICAgICAgICAgICBjbXBSZWYgPSB0aGlzLmFjdGl2YXRlZCA9IHRoaXMubG9jYXRpb24uY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIHRoaXMubG9jYXRpb24ubGVuZ3RoLCBpbmplY3Rvcik7XG4gICAgICAgICAgICAvLyBPbmNlIHRoZSBjb21wb25lbnQgaXMgY3JlYXRlZCB3ZSBjYW4gcHVzaCBpdCB0byBvdXIgbG9jYWwgc3ViamVjdCBzdXBwbGllZCB0byB0aGUgcHJveHlcbiAgICAgICAgICAgIGNvbXBvbmVudCQubmV4dChjbXBSZWYuaW5zdGFuY2UpO1xuICAgICAgICAgICAgLy8gQ2FsbGluZyBgbWFya0ZvckNoZWNrYCB0byBtYWtlIHN1cmUgd2Ugd2lsbCBydW4gdGhlIGNoYW5nZSBkZXRlY3Rpb24gd2hlbiB0aGVcbiAgICAgICAgICAgIC8vIGBSb3V0ZXJPdXRsZXRgIGlzIGluc2lkZSBhIGBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hgIGNvbXBvbmVudC5cbiAgICAgICAgICAgIGVudGVyaW5nVmlldyA9IHRoaXMuc3RhY2tDdHJsLmNyZWF0ZVZpZXcodGhpcy5hY3RpdmF0ZWQsIGFjdGl2YXRlZFJvdXRlKTtcbiAgICAgICAgICAgIC8vIFN0b3JlIHJlZmVyZW5jZXMgdG8gdGhlIHByb3h5IGJ5IGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5wcm94eU1hcC5zZXQoY21wUmVmLmluc3RhbmNlLCBhY3RpdmF0ZWRSb3V0ZVByb3h5KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFjdGl2YXRlZFJvdXRlJC5uZXh0KHsgY29tcG9uZW50OiBjbXBSZWYuaW5zdGFuY2UsIGFjdGl2YXRlZFJvdXRlOiBhY3RpdmF0ZWRSb3V0ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2YXRlZFZpZXcgPSBlbnRlcmluZ1ZpZXc7XG4gICAgICAgIHRoaXMuc3RhY2tDdHJsLnNldEFjdGl2ZShlbnRlcmluZ1ZpZXcpLnRoZW4oKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRhdGFcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBfdGhpcy5uYXZDdHJsLnNldFRvcE91dGxldChfdGhpcyk7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmF0ZUV2ZW50cy5lbWl0KGNtcFJlZi5pbnN0YW5jZSk7XG4gICAgICAgICAgICBfdGhpcy5zdGFja0V2ZW50cy5lbWl0KGRhdGEpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBhcmUgcGFnZXMgaW4gdGhlIHN0YWNrIHRvIGdvIGJhY2suXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlcmUgYXJlIHBhZ2VzIGluIHRoZSBzdGFjayB0byBnbyBiYWNrLlxuICAgICAqIEBwYXJhbSB7Pz19IGRlZXBcbiAgICAgKiBAcGFyYW0gez89fSBzdGFja0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJb25Sb3V0ZXJPdXRsZXQucHJvdG90eXBlLmNhbkdvQmFjayA9IC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGFyZSBwYWdlcyBpbiB0aGUgc3RhY2sgdG8gZ28gYmFjay5cbiAgICAgKiBAcGFyYW0gez89fSBkZWVwXG4gICAgICogQHBhcmFtIHs/PX0gc3RhY2tJZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGRlZXAsIHN0YWNrSWQpIHtcbiAgICAgICAgaWYgKGRlZXAgPT09IHZvaWQgMCkgeyBkZWVwID0gMTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja0N0cmwuY2FuR29CYWNrKGRlZXAsIHN0YWNrSWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdG8gYHRydWVgIGlmIGl0IHRoZSBvdXRsZXQgd2FzIGFibGUgdG8gc3VjZXNzZnVsbHkgcG9wIHRoZSBsYXN0IE4gcGFnZXMuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdG8gYHRydWVgIGlmIGl0IHRoZSBvdXRsZXQgd2FzIGFibGUgdG8gc3VjZXNzZnVsbHkgcG9wIHRoZSBsYXN0IE4gcGFnZXMuXG4gICAgICogQHBhcmFtIHs/PX0gZGVlcFxuICAgICAqIEBwYXJhbSB7Pz19IHN0YWNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIElvblJvdXRlck91dGxldC5wcm90b3R5cGUucG9wID0gLyoqXG4gICAgICogUmVzb2x2ZXMgdG8gYHRydWVgIGlmIGl0IHRoZSBvdXRsZXQgd2FzIGFibGUgdG8gc3VjZXNzZnVsbHkgcG9wIHRoZSBsYXN0IE4gcGFnZXMuXG4gICAgICogQHBhcmFtIHs/PX0gZGVlcFxuICAgICAqIEBwYXJhbSB7Pz19IHN0YWNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChkZWVwLCBzdGFja0lkKSB7XG4gICAgICAgIGlmIChkZWVwID09PSB2b2lkIDApIHsgZGVlcCA9IDE7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tDdHJsLnBvcChkZWVwLCBzdGFja0lkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFVSTCBvZiB0aGUgYWN0aXZlIHBhZ2Ugb2YgZWFjaCBzdGFjay5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBVUkwgb2YgdGhlIGFjdGl2ZSBwYWdlIG9mIGVhY2ggc3RhY2suXG4gICAgICogQHBhcmFtIHs/PX0gc3RhY2tJZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uUm91dGVyT3V0bGV0LnByb3RvdHlwZS5nZXRMYXN0VXJsID0gLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVJMIG9mIHRoZSBhY3RpdmUgcGFnZSBvZiBlYWNoIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7Pz19IHN0YWNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChzdGFja0lkKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuc3RhY2tDdHJsLmdldExhc3RVcmwoc3RhY2tJZCk7XG4gICAgICAgIHJldHVybiBhY3RpdmUgPyBhY3RpdmUudXJsIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0aXZlIHN0YWNrIElELiBJbiB0aGUgY29udGV4dCBvZiBpb24tdGFicywgaXQgbWVhbnMgdGhlIGFjdGl2ZSB0YWIuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0aXZlIHN0YWNrIElELiBJbiB0aGUgY29udGV4dCBvZiBpb24tdGFicywgaXQgbWVhbnMgdGhlIGFjdGl2ZSB0YWIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJb25Sb3V0ZXJPdXRsZXQucHJvdG90eXBlLmdldEFjdGl2ZVN0YWNrSWQgPSAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3RpdmUgc3RhY2sgSUQuIEluIHRoZSBjb250ZXh0IG9mIGlvbi10YWJzLCBpdCBtZWFucyB0aGUgYWN0aXZlIHRhYi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tDdHJsLmdldEFjdGl2ZVN0YWNrSWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNpbmNlIHRoZSBhY3RpdmF0ZWQgcm91dGUgY2FuIGNoYW5nZSBvdmVyIHRoZSBsaWZlIHRpbWUgb2YgYSBjb21wb25lbnQgaW4gYW4gaW9uIHJvdXRlciBvdXRsZXQsIHdlIGNyZWF0ZVxuICAgICAqIGEgcHJveHkgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoZSB2YWx1ZXMgb3ZlciB0aW1lIGFzIGEgdXNlciBuYXZpZ2F0ZXMgYmFjayB0byBjb21wb25lbnRzIGFscmVhZHkgaW4gdGhlIHN0YWNrLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFNpbmNlIHRoZSBhY3RpdmF0ZWQgcm91dGUgY2FuIGNoYW5nZSBvdmVyIHRoZSBsaWZlIHRpbWUgb2YgYSBjb21wb25lbnQgaW4gYW4gaW9uIHJvdXRlciBvdXRsZXQsIHdlIGNyZWF0ZVxuICAgICAqIGEgcHJveHkgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoZSB2YWx1ZXMgb3ZlciB0aW1lIGFzIGEgdXNlciBuYXZpZ2F0ZXMgYmFjayB0byBjb21wb25lbnRzIGFscmVhZHkgaW4gdGhlIHN0YWNrLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnQkXG4gICAgICogQHBhcmFtIHs/fSBhY3RpdmF0ZWRSb3V0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uUm91dGVyT3V0bGV0LnByb3RvdHlwZS5jcmVhdGVBY3RpdmF0ZWRSb3V0ZVByb3h5ID0gLyoqXG4gICAgICogU2luY2UgdGhlIGFjdGl2YXRlZCByb3V0ZSBjYW4gY2hhbmdlIG92ZXIgdGhlIGxpZmUgdGltZSBvZiBhIGNvbXBvbmVudCBpbiBhbiBpb24gcm91dGVyIG91dGxldCwgd2UgY3JlYXRlXG4gICAgICogYSBwcm94eSBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIHZhbHVlcyBvdmVyIHRpbWUgYXMgYSB1c2VyIG5hdmlnYXRlcyBiYWNrIHRvIGNvbXBvbmVudHMgYWxyZWFkeSBpbiB0aGUgc3RhY2suXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudCRcbiAgICAgKiBAcGFyYW0gez99IGFjdGl2YXRlZFJvdXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY29tcG9uZW50JCwgYWN0aXZhdGVkUm91dGUpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgcHJveHkgPSBuZXcgQWN0aXZhdGVkUm91dGUoKTtcbiAgICAgICAgcHJveHkuX2Z1dHVyZVNuYXBzaG90ID0gKCgvKiogQHR5cGUgez99ICovIChhY3RpdmF0ZWRSb3V0ZSkpKS5fZnV0dXJlU25hcHNob3Q7XG4gICAgICAgIHByb3h5Ll9yb3V0ZXJTdGF0ZSA9ICgoLyoqIEB0eXBlIHs/fSAqLyAoYWN0aXZhdGVkUm91dGUpKSkuX3JvdXRlclN0YXRlO1xuICAgICAgICBwcm94eS5zbmFwc2hvdCA9IGFjdGl2YXRlZFJvdXRlLnNuYXBzaG90O1xuICAgICAgICBwcm94eS5vdXRsZXQgPSBhY3RpdmF0ZWRSb3V0ZS5vdXRsZXQ7XG4gICAgICAgIHByb3h5LmNvbXBvbmVudCA9IGFjdGl2YXRlZFJvdXRlLmNvbXBvbmVudDtcbiAgICAgICAgLy8gU2V0dXAgd3JhcHBlcnMgZm9yIHRoZSBvYnNlcnZhYmxlcyBzbyBjb25zdW1lcnMgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBzd2l0Y2hpbmcgdG8gbmV3IG9ic2VydmFibGVzIGFzIHRoZSBzdGF0ZSB1cGRhdGVzXG4gICAgICAgICgoLyoqIEB0eXBlIHs/fSAqLyAocHJveHkpKSkuX3BhcmFtTWFwID0gdGhpcy5wcm94eU9ic2VydmFibGUoY29tcG9uZW50JCwgJ3BhcmFtTWFwJyk7XG4gICAgICAgICgoLyoqIEB0eXBlIHs/fSAqLyAocHJveHkpKSkuX3F1ZXJ5UGFyYW1NYXAgPSB0aGlzLnByb3h5T2JzZXJ2YWJsZShjb21wb25lbnQkLCAncXVlcnlQYXJhbU1hcCcpO1xuICAgICAgICBwcm94eS51cmwgPSB0aGlzLnByb3h5T2JzZXJ2YWJsZShjb21wb25lbnQkLCAndXJsJyk7XG4gICAgICAgIHByb3h5LnBhcmFtcyA9IHRoaXMucHJveHlPYnNlcnZhYmxlKGNvbXBvbmVudCQsICdwYXJhbXMnKTtcbiAgICAgICAgcHJveHkucXVlcnlQYXJhbXMgPSB0aGlzLnByb3h5T2JzZXJ2YWJsZShjb21wb25lbnQkLCAncXVlcnlQYXJhbXMnKTtcbiAgICAgICAgcHJveHkuZnJhZ21lbnQgPSB0aGlzLnByb3h5T2JzZXJ2YWJsZShjb21wb25lbnQkLCAnZnJhZ21lbnQnKTtcbiAgICAgICAgcHJveHkuZGF0YSA9IHRoaXMucHJveHlPYnNlcnZhYmxlKGNvbXBvbmVudCQsICdkYXRhJyk7XG4gICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHs/fSAqLyAocHJveHkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdyYXBwZWQgb2JzZXJ2YWJsZSB0aGF0IHdpbGwgc3dpdGNoIHRvIHRoZSBsYXRlc3QgYWN0aXZhdGVkIHJvdXRlIG1hdGNoZWQgYnkgdGhlIGdpdmVuIGNvbXBvbmVudFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdyYXBwZWQgb2JzZXJ2YWJsZSB0aGF0IHdpbGwgc3dpdGNoIHRvIHRoZSBsYXRlc3QgYWN0aXZhdGVkIHJvdXRlIG1hdGNoZWQgYnkgdGhlIGdpdmVuIGNvbXBvbmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnQkXG4gICAgICogQHBhcmFtIHs/fSBwYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJb25Sb3V0ZXJPdXRsZXQucHJvdG90eXBlLnByb3h5T2JzZXJ2YWJsZSA9IC8qKlxuICAgICAqIENyZWF0ZSBhIHdyYXBwZWQgb2JzZXJ2YWJsZSB0aGF0IHdpbGwgc3dpdGNoIHRvIHRoZSBsYXRlc3QgYWN0aXZhdGVkIHJvdXRlIG1hdGNoZWQgYnkgdGhlIGdpdmVuIGNvbXBvbmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnQkXG4gICAgICogQHBhcmFtIHs/fSBwYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY29tcG9uZW50JCwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50JC5waXBlKFxuICAgICAgICAvLyBGaXJzdCB3YWl0IHVudGlsIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgaXMgcHVzaGVkXG4gICAgICAgIGZpbHRlcigoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoY29tcG9uZW50KSB7IHJldHVybiAhIWNvbXBvbmVudDsgfSkpLCBzd2l0Y2hNYXAoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmN1cnJlbnRBY3RpdmF0ZWRSb3V0ZSQucGlwZShmaWx0ZXIoKC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBjdXJyZW50XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoY3VycmVudCkgeyByZXR1cm4gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LmNvbXBvbmVudCA9PT0gY29tcG9uZW50OyB9KSksIHN3aXRjaE1hcCgoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChjdXJyZW50KSB7IHJldHVybiBjdXJyZW50ICYmICgoLyoqIEB0eXBlIHs/fSAqLyAoY3VycmVudC5hY3RpdmF0ZWRSb3V0ZSkpKVtwYXRoXTsgfSkpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICAgICAgfSkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGFjdGl2YXRlZCByb3V0ZSBwcm94eSBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudCB0byB0aGUgbmV3IGluY29taW5nIHJvdXRlciBzdGF0ZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGFjdGl2YXRlZCByb3V0ZSBwcm94eSBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudCB0byB0aGUgbmV3IGluY29taW5nIHJvdXRlciBzdGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IGFjdGl2YXRlZFJvdXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJb25Sb3V0ZXJPdXRsZXQucHJvdG90eXBlLnVwZGF0ZUFjdGl2YXRlZFJvdXRlUHJveHkgPSAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBhY3RpdmF0ZWQgcm91dGUgcHJveHkgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQgdG8gdGhlIG5ldyBpbmNvbWluZyByb3V0ZXIgc3RhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHs/fSBhY3RpdmF0ZWRSb3V0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvbXBvbmVudCwgYWN0aXZhdGVkUm91dGUpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5TWFwLmdldChjb21wb25lbnQpO1xuICAgICAgICBpZiAoIXByb3h5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhY3RpdmF0ZWQgcm91dGUgcHJveHkgZm9yIHZpZXdcIik7XG4gICAgICAgIH1cbiAgICAgICAgKCgvKiogQHR5cGUgez99ICovIChwcm94eSkpKS5fZnV0dXJlU25hcHNob3QgPSAoKC8qKiBAdHlwZSB7P30gKi8gKGFjdGl2YXRlZFJvdXRlKSkpLl9mdXR1cmVTbmFwc2hvdDtcbiAgICAgICAgKCgvKiogQHR5cGUgez99ICovIChwcm94eSkpKS5fcm91dGVyU3RhdGUgPSAoKC8qKiBAdHlwZSB7P30gKi8gKGFjdGl2YXRlZFJvdXRlKSkpLl9yb3V0ZXJTdGF0ZTtcbiAgICAgICAgcHJveHkuc25hcHNob3QgPSBhY3RpdmF0ZWRSb3V0ZS5zbmFwc2hvdDtcbiAgICAgICAgcHJveHkub3V0bGV0ID0gYWN0aXZhdGVkUm91dGUub3V0bGV0O1xuICAgICAgICBwcm94eS5jb21wb25lbnQgPSBhY3RpdmF0ZWRSb3V0ZS5jb21wb25lbnQ7XG4gICAgICAgIHRoaXMuY3VycmVudEFjdGl2YXRlZFJvdXRlJC5uZXh0KHsgY29tcG9uZW50OiBjb21wb25lbnQsIGFjdGl2YXRlZFJvdXRlOiBhY3RpdmF0ZWRSb3V0ZSB9KTtcbiAgICB9O1xuICAgIElvblJvdXRlck91dGxldC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpb24tcm91dGVyLW91dGxldCcsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnb3V0bGV0JyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2FuaW1hdGVkJywgJ3N3aXBlR2VzdHVyZSddXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25Sb3V0ZXJPdXRsZXQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2hpbGRyZW5PdXRsZXRDb250ZXh0cyB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgfSxcbiAgICAgICAgeyB0eXBlOiBTdHJpbmcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEF0dHJpYnV0ZSwgYXJnczogWyduYW1lJyxdIH1dIH0sXG4gICAgICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEF0dHJpYnV0ZSwgYXJnczogWyd0YWJzJyxdIH1dIH0sXG4gICAgICAgIHsgdHlwZTogQ29uZmlnIH0sXG4gICAgICAgIHsgdHlwZTogTmF2Q29udHJvbGxlciB9LFxuICAgICAgICB7IHR5cGU6IExvY2F0aW9uIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgICAgICB7IHR5cGU6IFJvdXRlciB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgICAgICB7IHR5cGU6IEFjdGl2YXRlZFJvdXRlIH0sXG4gICAgICAgIHsgdHlwZTogSW9uUm91dGVyT3V0bGV0LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBTa2lwU2VsZiB9LCB7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbiAgICBdOyB9O1xuICAgIElvblJvdXRlck91dGxldC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgc3RhY2tFdmVudHM6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICAgICAgYWN0aXZhdGVFdmVudHM6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydhY3RpdmF0ZScsXSB9XSxcbiAgICAgICAgZGVhY3RpdmF0ZUV2ZW50czogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2RlYWN0aXZhdGUnLF0gfV1cbiAgICB9O1xuICAgIHJldHVybiBJb25Sb3V0ZXJPdXRsZXQ7XG59KCkpO1xudmFyIE91dGxldEluamVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE91dGxldEluamVjdG9yKHJvdXRlLCBjaGlsZENvbnRleHRzLCBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICB0aGlzLmNoaWxkQ29udGV4dHMgPSBjaGlsZENvbnRleHRzO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEBwYXJhbSB7Pz19IG5vdEZvdW5kVmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE91dGxldEluamVjdG9yLnByb3RvdHlwZS5nZXQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHBhcmFtIHs/PX0gbm90Rm91bmRWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gQWN0aXZhdGVkUm91dGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiA9PT0gQ2hpbGRyZW5PdXRsZXRDb250ZXh0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDb250ZXh0cztcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3V0bGV0SW5qZWN0b3I7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIElvblRhYnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uVGFicyhuYXZDdHJsKSB7XG4gICAgICAgIHRoaXMubmF2Q3RybCA9IG5hdkN0cmw7XG4gICAgICAgIHRoaXMuaW9uVGFic1dpbGxDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaW9uVGFic0RpZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGRldGFpbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uVGFicy5wcm90b3R5cGUub25QYWdlU2VsZWN0ZWQgPSAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gZGV0YWlsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHN0YWNrSWQgPSBkZXRhaWwuZW50ZXJpbmdWaWV3LnN0YWNrSWQ7XG4gICAgICAgIGlmIChkZXRhaWwudGFiU3dpdGNoICYmIHN0YWNrSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGFiQmFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWJCYXIuc2VsZWN0ZWRUYWIgPSBzdGFja0lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pb25UYWJzV2lsbENoYW5nZS5lbWl0KHsgdGFiOiBzdGFja0lkIH0pO1xuICAgICAgICAgICAgdGhpcy5pb25UYWJzRGlkQ2hhbmdlLmVtaXQoeyB0YWI6IHN0YWNrSWQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFiXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJb25UYWJzLnByb3RvdHlwZS5zZWxlY3QgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHRhYlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBhbHJlYWR5U2VsZWN0ZWQgPSB0aGlzLm91dGxldC5nZXRBY3RpdmVTdGFja0lkKCkgPT09IHRhYjtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgaHJlZiA9IHRoaXMub3V0bGV0LnRhYnNQcmVmaXggKyBcIi9cIiArIHRhYjtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgdXJsID0gYWxyZWFkeVNlbGVjdGVkXG4gICAgICAgICAgICA/IGhyZWZcbiAgICAgICAgICAgIDogdGhpcy5vdXRsZXQuZ2V0TGFzdFVybCh0YWIpIHx8IGhyZWY7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdkN0cmwubmF2aWdhdGVSb290KHVybCwge1xuICAgICAgICAgICAgYW5pbWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBhbmltYXRpb25EaXJlY3Rpb246ICdiYWNrJ1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uVGFicy5wcm90b3R5cGUuZ2V0U2VsZWN0ZWQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0bGV0LmdldEFjdGl2ZVN0YWNrSWQoKTtcbiAgICB9O1xuICAgIElvblRhYnMuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW9uLXRhYnMnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbc2xvdD10b3BdXFxcIj48L25nLWNvbnRlbnQ+XFxuICAgIDxkaXYgY2xhc3M9XFxcInRhYnMtaW5uZXJcXFwiPlxcbiAgICAgIDxpb24tcm91dGVyLW91dGxldCAjb3V0bGV0IHRhYnM9XFxcInRydWVcXFwiIChzdGFja0V2ZW50cyk9XFxcIm9uUGFnZVNlbGVjdGVkKCRldmVudClcXFwiPjwvaW9uLXJvdXRlci1vdXRsZXQ+XFxuICAgIDwvZGl2PlxcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogW1wiXFxuICAgIDpob3N0IHtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICB0b3A6IDA7XFxuICAgICAgbGVmdDogMDtcXG4gICAgICByaWdodDogMDtcXG4gICAgICBib3R0b206IDA7XFxuXFxuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG5cXG4gICAgICB3aWR0aDogMTAwJTtcXG4gICAgICBoZWlnaHQ6IDEwMCU7XFxuXFxuICAgICAgY29udGFpbjogbGF5b3V0IHNpemUgc3R5bGU7XFxuICAgICAgei1pbmRleDogJHotaW5kZXgtcGFnZS1jb250YWluZXI7XFxuICAgIH1cXG4gICAgLnRhYnMtaW5uZXIge1xcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG5cXG4gICAgICBmbGV4OiAxO1xcblxcbiAgICAgIGNvbnRhaW46IGxheW91dCBzaXplIHN0eWxlO1xcbiAgICB9XCJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW9uVGFicy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBOYXZDb250cm9sbGVyIH1cbiAgICBdOyB9O1xuICAgIElvblRhYnMucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgIG91dGxldDogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ291dGxldCcsIHsgcmVhZDogSW9uUm91dGVyT3V0bGV0IH0sXSB9XSxcbiAgICAgICAgdGFiQmFyOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtJb25UYWJCYXIsXSB9XSxcbiAgICAgICAgaW9uVGFic1dpbGxDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICAgICAgaW9uVGFic0RpZENoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgICAgICBzZWxlY3Q6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydpb25UYWJCdXR0b25DbGljaycsIFsnJGV2ZW50LmRldGFpbC50YWInXSxdIH1dXG4gICAgfTtcbiAgICByZXR1cm4gSW9uVGFicztcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgSW9uQmFja0J1dHRvbkRlbGVnYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbkJhY2tCdXR0b25EZWxlZ2F0ZShyb3V0ZXJPdXRsZXQsIG5hdkN0cmwpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXJPdXRsZXQgPSByb3V0ZXJPdXRsZXQ7XG4gICAgICAgIHRoaXMubmF2Q3RybCA9IG5hdkN0cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBldlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uQmFja0J1dHRvbkRlbGVnYXRlLnByb3RvdHlwZS5vbkNsaWNrID0gLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGV2XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKHRoaXMucm91dGVyT3V0bGV0ICYmIHRoaXMucm91dGVyT3V0bGV0LmNhbkdvQmFjaygpKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlck91dGxldC5wb3AoKTtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWZhdWx0SHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5hdkN0cmwubmF2aWdhdGVCYWNrKHRoaXMuZGVmYXVsdEhyZWYpO1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW9uQmFja0J1dHRvbkRlbGVnYXRlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lvbi1iYWNrLWJ1dHRvbicsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydkZWZhdWx0SHJlZiddXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25CYWNrQnV0dG9uRGVsZWdhdGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogSW9uUm91dGVyT3V0bGV0LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9LFxuICAgICAgICB7IHR5cGU6IE5hdkNvbnRyb2xsZXIgfVxuICAgIF07IH07XG4gICAgSW9uQmFja0J1dHRvbkRlbGVnYXRlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICBvbkNsaWNrOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnY2xpY2snLCBbJyRldmVudCddLF0gfV1cbiAgICB9O1xuICAgIHJldHVybiBJb25CYWNrQnV0dG9uRGVsZWdhdGU7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIE5hdkRlbGVnYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5hdkRlbGVnYXRlKHJlZiwgcmVzb2x2ZXIsIGluamVjdG9yLCBhbmd1bGFyRGVsZWdhdGUsIGxvY2F0aW9uKSB7XG4gICAgICAgIHJlZi5uYXRpdmVFbGVtZW50LmRlbGVnYXRlID0gYW5ndWxhckRlbGVnYXRlLmNyZWF0ZShyZXNvbHZlciwgaW5qZWN0b3IsIGxvY2F0aW9uKTtcbiAgICB9XG4gICAgTmF2RGVsZWdhdGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW9uLW5hdicsXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBOYXZEZWxlZ2F0ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIH0sXG4gICAgICAgIHsgdHlwZTogSW5qZWN0b3IgfSxcbiAgICAgICAgeyB0eXBlOiBBbmd1bGFyRGVsZWdhdGUgfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBOYXZEZWxlZ2F0ZTtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgUm91dGVyTGlua0RlbGVnYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdXRlckxpbmtEZWxlZ2F0ZShsb2NhdGlvblN0cmF0ZWd5LCBuYXZDdHJsLCBlbGVtZW50UmVmLCByb3V0ZXIsIHJvdXRlckxpbmspIHtcbiAgICAgICAgdGhpcy5sb2NhdGlvblN0cmF0ZWd5ID0gbG9jYXRpb25TdHJhdGVneTtcbiAgICAgICAgdGhpcy5uYXZDdHJsID0gbmF2Q3RybDtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMucm91dGVyTGluayA9IHJvdXRlckxpbms7XG4gICAgICAgIHRoaXMucm91dGVyRGlyZWN0aW9uID0gJ2ZvcndhcmQnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJvdXRlckxpbmtEZWxlZ2F0ZS5wcm90b3R5cGUubmdPbkluaXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXRVcmxBbmRIcmVmKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJvdXRlckxpbmtEZWxlZ2F0ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXRVcmxBbmRIcmVmKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJvdXRlckxpbmtEZWxlZ2F0ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUm91dGVyTGlua0RlbGVnYXRlLnByb3RvdHlwZS51cGRhdGVUYXJnZXRVcmxBbmRIcmVmID0gLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucm91dGVyTGluaykge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIGhyZWYgPSB0aGlzLmxvY2F0aW9uU3RyYXRlZ3kucHJlcGFyZUV4dGVybmFsVXJsKHRoaXMucm91dGVyLnNlcmlhbGl6ZVVybCh0aGlzLnJvdXRlckxpbmsudXJsVHJlZSkpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuaHJlZiA9IGhyZWY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBldlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUm91dGVyTGlua0RlbGVnYXRlLnByb3RvdHlwZS5vbkNsaWNrID0gLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGV2XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdGhpcy5uYXZDdHJsLnNldERpcmVjdGlvbih0aGlzLnJvdXRlckRpcmVjdGlvbik7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBSb3V0ZXJMaW5rRGVsZWdhdGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW3JvdXRlckxpbmtdJyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbJ3JvdXRlckRpcmVjdGlvbiddXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBSb3V0ZXJMaW5rRGVsZWdhdGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogTG9jYXRpb25TdHJhdGVneSB9LFxuICAgICAgICB7IHR5cGU6IE5hdkNvbnRyb2xsZXIgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogUm91dGVyIH0sXG4gICAgICAgIHsgdHlwZTogUm91dGVyTGluaywgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuICAgIF07IH07XG4gICAgUm91dGVyTGlua0RlbGVnYXRlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICBvbkNsaWNrOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnY2xpY2snLCBbJyRldmVudCddLF0gfV1cbiAgICB9O1xuICAgIHJldHVybiBSb3V0ZXJMaW5rRGVsZWdhdGU7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBWaXJ0dWFsRm9vdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpcnR1YWxGb290ZXIodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbiAgICBWaXJ0dWFsRm9vdGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1t2aXJ0dWFsRm9vdGVyXScgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBWaXJ0dWFsRm9vdGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBWaXJ0dWFsRm9vdGVyO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgVmlydHVhbEhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaXJ0dWFsSGVhZGVyKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG4gICAgVmlydHVhbEhlYWRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbdmlydHVhbEhlYWRlcl0nIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgVmlydHVhbEhlYWRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9XG4gICAgXTsgfTtcbiAgICByZXR1cm4gVmlydHVhbEhlYWRlcjtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xudmFyIFZpcnR1YWxJdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpcnR1YWxJdGVtKHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcbiAgICB9XG4gICAgVmlydHVhbEl0ZW0uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW3ZpcnR1YWxJdGVtXScgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBWaXJ0dWFsSXRlbS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIFZpcnR1YWxJdGVtO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBJb25WaXJ0dWFsU2Nyb2xsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvblZpcnR1YWxTY3JvbGwoeiwgaXRlcmFibGVEaWZmZXJzLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIHRoaXMuaXRlcmFibGVEaWZmZXJzID0gaXRlcmFibGVEaWZmZXJzO1xuICAgICAgICB0aGlzLnJlZk1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuZWwgPSAoLyoqIEB0eXBlIHs/fSAqLyAoZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSk7XG4gICAgICAgIHRoaXMuZWwubm9kZVJlbmRlciA9IHRoaXMubm9kZVJlbmRlci5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIElvblZpcnR1YWxTY3JvbGwucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAodGhpcy50cmFja0J5ICYmICdpdGVtcycgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgLy8gUmVhY3Qgb24gdmlydHVhbFNjcm9sbCBjaGFuZ2VzIG9ubHkgb25jZSBhbGwgaW5wdXRzIGhhdmUgYmVlbiBpbml0aWFsaXplZFxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY2hhbmdlc1snaXRlbXMnXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5kaWZmZXIgPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaWZmZXIgPSB0aGlzLml0ZXJhYmxlRGlmZmVycy5maW5kKHZhbHVlKS5jcmVhdGUodGhpcy50cmFja0J5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgJ1wiICsgdmFsdWUgKyBcIicuIFZpcnR1YWxTY3JvbGwgb25seSBzdXBwb3J0cyBiaW5kaW5nIHRvIEl0ZXJhYmxlcyBzdWNoIGFzIEFycmF5cy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIElvblZpcnR1YWxTY3JvbGwucHJvdG90eXBlLm5nRG9DaGVjayA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhbmQgaWYgdGhlcmUgYWN0dWFsbHkgYXJlIGNoYW5nZXNcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuZGlmZmVyICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pdGVtcyA/IHRoaXMuZGlmZmVyLmRpZmYodGhpcy5pdGVtcykgOiBudWxsO1xuICAgICAgICBpZiAoY2hhbmdlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IG9wdGltaXplXG4gICAgICAgIHRoaXMuY2hlY2tSYW5nZSgwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gY2VsbFxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIElvblZpcnR1YWxTY3JvbGwucHJvdG90eXBlLm5vZGVSZW5kZXIgPSAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IGNlbGxcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIGNlbGwsIGluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnoucnVuKCgvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBub2RlO1xuICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBfdGhpcy5pdG1UbXAudmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcoX3RoaXMuZ2V0Q29tcG9uZW50KGNlbGwudHlwZSksIHsgJGltcGxpY2l0OiBjZWxsLnZhbHVlLCBpbmRleDogaW5kZXggfSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGVsID0gZ2V0RWxlbWVudChub2RlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWZNYXAuc2V0KGVsLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSAoLyoqIEB0eXBlIHs/fSAqLyAoX3RoaXMucmVmTWFwLmdldChlbCkpKTtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICAgICAgICBjdHguJGltcGxpY2l0ID0gY2VsbC52YWx1ZTtcbiAgICAgICAgICAgICAgICBjdHguaW5kZXggPSBjZWxsLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcnVuIHN5bmMgY2hhbmdlIGRldGVjdGlvbnNcbiAgICAgICAgICAgIG5vZGUuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uVmlydHVhbFNjcm9sbC5wcm90b3R5cGUuZ2V0Q29tcG9uZW50ID0gLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaXRlbSc6IHJldHVybiB0aGlzLml0bVRtcC50ZW1wbGF0ZVJlZjtcbiAgICAgICAgICAgIGNhc2UgJ2hlYWRlcic6IHJldHVybiB0aGlzLmhkclRtcC50ZW1wbGF0ZVJlZjtcbiAgICAgICAgICAgIGNhc2UgJ2Zvb3Rlcic6IHJldHVybiB0aGlzLmZ0clRtcC50ZW1wbGF0ZVJlZjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbXBsYXRlIGZvciB2aXJ0dWFsIGl0ZW0gd2FzIG5vdCBwcm92aWRlZCcpO1xuICAgIH07XG4gICAgSW9uVmlydHVhbFNjcm9sbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpb24tdmlydHVhbC1zY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXBwcm94SXRlbUhlaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXBwcm94SGVhZGVySGVpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcHByb3hGb290ZXJIZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hlYWRlckZuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb290ZXJGbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaXRlbXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2l0ZW1IZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hlYWRlckhlaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9vdGVySGVpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFja0J5J1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJb25WaXJ0dWFsU2Nyb2xsLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgICAgICB7IHR5cGU6IEl0ZXJhYmxlRGlmZmVycyB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuICAgIF07IH07XG4gICAgSW9uVmlydHVhbFNjcm9sbC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgaXRtVG1wOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtWaXJ0dWFsSXRlbSxdIH1dLFxuICAgICAgICBoZHJUbXA6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW1ZpcnR1YWxIZWFkZXIsXSB9XSxcbiAgICAgICAgZnRyVG1wOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtWaXJ0dWFsRm9vdGVyLF0gfV1cbiAgICB9O1xuICAgIHJldHVybiBJb25WaXJ0dWFsU2Nyb2xsO1xufSgpKTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBnZXRFbGVtZW50ID0gKC8qKlxuICogQHBhcmFtIHs/fSB2aWV3XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiAodmlldykge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICB2YXIgcm9vdE5vZGVzID0gdmlldy5yb290Tm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJvb3ROb2Rlc1tpXS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3ROb2Rlc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZpcnR1YWwgZWxlbWVudCB3YXMgbm90IGNyZWF0ZWQnKTtcbn0pO1xucHJveHlJbnB1dHMoSW9uVmlydHVhbFNjcm9sbCwgW1xuICAgICdhcHByb3hJdGVtSGVpZ2h0JyxcbiAgICAnYXBwcm94SGVhZGVySGVpZ2h0JyxcbiAgICAnYXBwcm94Rm9vdGVySGVpZ2h0JyxcbiAgICAnaGVhZGVyRm4nLFxuICAgICdmb290ZXJGbicsXG4gICAgJ2l0ZW1zJyxcbiAgICAnaXRlbUhlaWdodCcsXG4gICAgJ2hlYWRlckhlaWdodCcsXG4gICAgJ2Zvb3RlckhlaWdodCdcbl0pO1xucHJveHlNZXRob2RzKElvblZpcnR1YWxTY3JvbGwsIFtcbiAgICAnY2hlY2tFbmQnLFxuICAgICdjaGVja1JhbmdlJyxcbiAgICAncG9zaXRpb25Gb3JJdGVtJ1xuXSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQ3NzVXRpbHNEZXByZWNhdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ3NzVXRpbHNEZXByZWNhdGlvbnMocmVmKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGVsID0gKCgvKiogQHR5cGUgez99ICovIChyZWYubmF0aXZlRWxlbWVudCkpKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IEFycmF5LmZyb20oZWwuYXR0cmlidXRlcylcbiAgICAgICAgICAgIC5tYXAoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5hbWU7IH0pKVxuICAgICAgICAgICAgLmZpbHRlcigoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIERFUFJFQ0FURURfQVRUUklCVVRFUy5pbmNsdWRlcyhuKTsgfSkpO1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbREVQUkVDQVRFRF1bQ1NTXSBJb25pYyBDU1MgYXR0cmlidXRlcyBhcmUgZGVwcmVjYXRlZC5cXG5SZXBsYWNlOlxcbic8XCIgKyBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiArIGF0dHJpYnV0ZXMubWFwKCgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gblxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiXCIgKyBuOyB9KSkuam9pbignICcpICsgXCI+J1xcblxcbldpdGg6XFxuJzxcIiArIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArIFwiIGNsYXNzPVxcXCJcIiArIGF0dHJpYnV0ZXMubWFwKCgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gblxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiaW9uLVwiICsgbjsgfSkpLmpvaW4oJyAnKSArIFwiXFxcIj4nXFxuICAgICAgXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENzc1V0aWxzRGVwcmVjYXRpb25zLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1thbGlnbi1zZWxmLXN0YXJ0XSwgW2FsaWduLXNlbGYtZW5kXSwgW2FsaWduLXNlbGYtY2VudGVyXSwgW2FsaWduLXNlbGYtc3RyZXRjaF0sIFthbGlnbi1zZWxmLWJhc2VsaW5lXSwgW2FsaWduLXNlbGYtYXV0b10sIFt3cmFwLXJldmVyc2VdLCBbanVzdGlmeS1jb250ZW50LXN0YXJ0XSwgW2p1c3RpZnktY29udGVudC1jZW50ZXJdLCBbanVzdGlmeS1jb250ZW50LWVuZF0sIFtqdXN0aWZ5LWNvbnRlbnQtYXJvdW5kXSwgW2p1c3RpZnktY29udGVudC1iZXR3ZWVuXSwgW2p1c3RpZnktY29udGVudC1ldmVubHldLCBbYWxpZ24taXRlbXMtc3RhcnRdLCBbYWxpZ24taXRlbXMtY2VudGVyXSwgW2FsaWduLWl0ZW1zLWVuZF0sIFthbGlnbi1pdGVtcy1zdHJldGNoXSwgW2FsaWduLWl0ZW1zLWJhc2VsaW5lXSwgW2Zsb2F0LWxlZnRdLCBbZmxvYXQtcmlnaHRdLCBbZmxvYXQtc3RhcnRdLCBbZmxvYXQtZW5kXSwgW2Zsb2F0LXNtLWxlZnRdLCBbZmxvYXQtc20tcmlnaHRdLCBbZmxvYXQtc20tc3RhcnRdLCBbZmxvYXQtc20tZW5kXSwgW2Zsb2F0LW1kLWxlZnRdLCBbZmxvYXQtbWQtcmlnaHRdLCBbZmxvYXQtbWQtc3RhcnRdLCBbZmxvYXQtbWQtZW5kXSwgW2Zsb2F0LWxnLWxlZnRdLCBbZmxvYXQtbGctcmlnaHRdLCBbZmxvYXQtbGctc3RhcnRdLCBbZmxvYXQtbGctZW5kXSwgW2Zsb2F0LXhsLWxlZnRdLCBbZmxvYXQteGwtcmlnaHRdLCBbZmxvYXQteGwtc3RhcnRdLCBbZmxvYXQteGwtZW5kXSwgW3RleHQtY2VudGVyXSwgW3RleHQtanVzdGlmeV0sIFt0ZXh0LXN0YXJ0XSwgW3RleHQtZW5kXSwgW3RleHQtbGVmdF0sIFt0ZXh0LXJpZ2h0XSwgW3RleHQtbm93cmFwXSwgW3RleHQtd3JhcF0sIFt0ZXh0LXNtLWNlbnRlcl0sIFt0ZXh0LXNtLWp1c3RpZnldLCBbdGV4dC1zbS1zdGFydF0sIFt0ZXh0LXNtLWVuZF0sIFt0ZXh0LXNtLWxlZnRdLCBbdGV4dC1zbS1yaWdodF0sIFt0ZXh0LXNtLW5vd3JhcF0sIFt0ZXh0LXNtLXdyYXBdLCBbdGV4dC1tZC1jZW50ZXJdLCBbdGV4dC1tZC1qdXN0aWZ5XSwgW3RleHQtbWQtc3RhcnRdLCBbdGV4dC1tZC1lbmRdLCBbdGV4dC1tZC1sZWZ0XSwgW3RleHQtbWQtcmlnaHRdLCBbdGV4dC1tZC1ub3dyYXBdLCBbdGV4dC1tZC13cmFwXSwgW3RleHQtbGctY2VudGVyXSwgW3RleHQtbGctanVzdGlmeV0sIFt0ZXh0LWxnLXN0YXJ0XSwgW3RleHQtbGctZW5kXSwgW3RleHQtbGctbGVmdF0sIFt0ZXh0LWxnLXJpZ2h0XSwgW3RleHQtbGctbm93cmFwXSwgW3RleHQtbGctd3JhcF0sIFt0ZXh0LXhsLWNlbnRlcl0sIFt0ZXh0LXhsLWp1c3RpZnldLCBbdGV4dC14bC1zdGFydF0sIFt0ZXh0LXhsLWVuZF0sIFt0ZXh0LXhsLWxlZnRdLCBbdGV4dC14bC1yaWdodF0sIFt0ZXh0LXhsLW5vd3JhcF0sIFt0ZXh0LXhsLXdyYXBdLCBbdGV4dC11cHBlcmNhc2VdLCBbdGV4dC1sb3dlcmNhc2VdLCBbdGV4dC1jYXBpdGFsaXplXSwgW3RleHQtc20tdXBwZXJjYXNlXSwgW3RleHQtc20tbG93ZXJjYXNlXSwgW3RleHQtc20tY2FwaXRhbGl6ZV0sIFt0ZXh0LW1kLXVwcGVyY2FzZV0sIFt0ZXh0LW1kLWxvd2VyY2FzZV0sIFt0ZXh0LW1kLWNhcGl0YWxpemVdLCBbdGV4dC1sZy11cHBlcmNhc2VdLCBbdGV4dC1sZy1sb3dlcmNhc2VdLCBbdGV4dC1sZy1jYXBpdGFsaXplXSwgW3RleHQteGwtdXBwZXJjYXNlXSwgW3RleHQteGwtbG93ZXJjYXNlXSwgW3RleHQteGwtY2FwaXRhbGl6ZV0sIFtuby1wYWRkaW5nXSwgW3BhZGRpbmddLCBbcGFkZGluZy10b3BdLCBbcGFkZGluZy1ib3R0b21dLCBbcGFkZGluZy1zdGFydF0sIFtwYWRkaW5nLWVuZF0sIFtwYWRkaW5nLXZlcnRpY2FsXSwgW3BhZGRpbmctaG9yaXpvbnRhbF0sIFtuby1tYXJnaW5dLCBbbWFyZ2luXSwgW21hcmdpbi10b3BdLCBbbWFyZ2luLWJvdHRvbV0sIFttYXJnaW4tc3RhcnRdLCBbbWFyZ2luLWVuZF0sIFttYXJnaW4tdmVydGljYWxdLCBbbWFyZ2luLWhvcml6b250YWxdJyxcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIENzc1V0aWxzRGVwcmVjYXRpb25zLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfVxuICAgIF07IH07XG4gICAgcmV0dXJuIENzc1V0aWxzRGVwcmVjYXRpb25zO1xufSgpKTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBERVBSRUNBVEVEX0FUVFJJQlVURVMgPSBbXG4gICAgJ2FsaWduLXNlbGYtc3RhcnQnLFxuICAgICdhbGlnbi1zZWxmLWVuZCcsXG4gICAgJ2FsaWduLXNlbGYtY2VudGVyJyxcbiAgICAnYWxpZ24tc2VsZi1zdHJldGNoJyxcbiAgICAnYWxpZ24tc2VsZi1iYXNlbGluZScsXG4gICAgJ2FsaWduLXNlbGYtYXV0bycsXG4gICAgJ3dyYXAtcmV2ZXJzZScsXG4gICAgJ2p1c3RpZnktY29udGVudC1zdGFydCcsXG4gICAgJ2p1c3RpZnktY29udGVudC1jZW50ZXInLFxuICAgICdqdXN0aWZ5LWNvbnRlbnQtZW5kJyxcbiAgICAnanVzdGlmeS1jb250ZW50LWFyb3VuZCcsXG4gICAgJ2p1c3RpZnktY29udGVudC1iZXR3ZWVuJyxcbiAgICAnanVzdGlmeS1jb250ZW50LWV2ZW5seScsXG4gICAgJ2FsaWduLWl0ZW1zLXN0YXJ0JyxcbiAgICAnYWxpZ24taXRlbXMtY2VudGVyJyxcbiAgICAnYWxpZ24taXRlbXMtZW5kJyxcbiAgICAnYWxpZ24taXRlbXMtc3RyZXRjaCcsXG4gICAgJ2FsaWduLWl0ZW1zLWJhc2VsaW5lJyxcbiAgICAnZmxvYXQtbGVmdCcsXG4gICAgJ2Zsb2F0LXJpZ2h0JyxcbiAgICAnZmxvYXQtc3RhcnQnLFxuICAgICdmbG9hdC1lbmQnLFxuICAgICdmbG9hdC1zbS1sZWZ0JyxcbiAgICAnZmxvYXQtc20tcmlnaHQnLFxuICAgICdmbG9hdC1zbS1zdGFydCcsXG4gICAgJ2Zsb2F0LXNtLWVuZCcsXG4gICAgJ2Zsb2F0LW1kLWxlZnQnLFxuICAgICdmbG9hdC1tZC1yaWdodCcsXG4gICAgJ2Zsb2F0LW1kLXN0YXJ0JyxcbiAgICAnZmxvYXQtbWQtZW5kJyxcbiAgICAnZmxvYXQtbGctbGVmdCcsXG4gICAgJ2Zsb2F0LWxnLXJpZ2h0JyxcbiAgICAnZmxvYXQtbGctc3RhcnQnLFxuICAgICdmbG9hdC1sZy1lbmQnLFxuICAgICdmbG9hdC14bC1sZWZ0JyxcbiAgICAnZmxvYXQteGwtcmlnaHQnLFxuICAgICdmbG9hdC14bC1zdGFydCcsXG4gICAgJ2Zsb2F0LXhsLWVuZCcsXG4gICAgJ3RleHQtY2VudGVyJyxcbiAgICAndGV4dC1qdXN0aWZ5JyxcbiAgICAndGV4dC1zdGFydCcsXG4gICAgJ3RleHQtZW5kJyxcbiAgICAndGV4dC1sZWZ0JyxcbiAgICAndGV4dC1yaWdodCcsXG4gICAgJ3RleHQtbm93cmFwJyxcbiAgICAndGV4dC13cmFwJyxcbiAgICAndGV4dC1zbS1jZW50ZXInLFxuICAgICd0ZXh0LXNtLWp1c3RpZnknLFxuICAgICd0ZXh0LXNtLXN0YXJ0JyxcbiAgICAndGV4dC1zbS1lbmQnLFxuICAgICd0ZXh0LXNtLWxlZnQnLFxuICAgICd0ZXh0LXNtLXJpZ2h0JyxcbiAgICAndGV4dC1zbS1ub3dyYXAnLFxuICAgICd0ZXh0LXNtLXdyYXAnLFxuICAgICd0ZXh0LW1kLWNlbnRlcicsXG4gICAgJ3RleHQtbWQtanVzdGlmeScsXG4gICAgJ3RleHQtbWQtc3RhcnQnLFxuICAgICd0ZXh0LW1kLWVuZCcsXG4gICAgJ3RleHQtbWQtbGVmdCcsXG4gICAgJ3RleHQtbWQtcmlnaHQnLFxuICAgICd0ZXh0LW1kLW5vd3JhcCcsXG4gICAgJ3RleHQtbWQtd3JhcCcsXG4gICAgJ3RleHQtbGctY2VudGVyJyxcbiAgICAndGV4dC1sZy1qdXN0aWZ5JyxcbiAgICAndGV4dC1sZy1zdGFydCcsXG4gICAgJ3RleHQtbGctZW5kJyxcbiAgICAndGV4dC1sZy1sZWZ0JyxcbiAgICAndGV4dC1sZy1yaWdodCcsXG4gICAgJ3RleHQtbGctbm93cmFwJyxcbiAgICAndGV4dC1sZy13cmFwJyxcbiAgICAndGV4dC14bC1jZW50ZXInLFxuICAgICd0ZXh0LXhsLWp1c3RpZnknLFxuICAgICd0ZXh0LXhsLXN0YXJ0JyxcbiAgICAndGV4dC14bC1lbmQnLFxuICAgICd0ZXh0LXhsLWxlZnQnLFxuICAgICd0ZXh0LXhsLXJpZ2h0JyxcbiAgICAndGV4dC14bC1ub3dyYXAnLFxuICAgICd0ZXh0LXhsLXdyYXAnLFxuICAgICd0ZXh0LXVwcGVyY2FzZScsXG4gICAgJ3RleHQtbG93ZXJjYXNlJyxcbiAgICAndGV4dC1jYXBpdGFsaXplJyxcbiAgICAndGV4dC1zbS11cHBlcmNhc2UnLFxuICAgICd0ZXh0LXNtLWxvd2VyY2FzZScsXG4gICAgJ3RleHQtc20tY2FwaXRhbGl6ZScsXG4gICAgJ3RleHQtbWQtdXBwZXJjYXNlJyxcbiAgICAndGV4dC1tZC1sb3dlcmNhc2UnLFxuICAgICd0ZXh0LW1kLWNhcGl0YWxpemUnLFxuICAgICd0ZXh0LWxnLXVwcGVyY2FzZScsXG4gICAgJ3RleHQtbGctbG93ZXJjYXNlJyxcbiAgICAndGV4dC1sZy1jYXBpdGFsaXplJyxcbiAgICAndGV4dC14bC11cHBlcmNhc2UnLFxuICAgICd0ZXh0LXhsLWxvd2VyY2FzZScsXG4gICAgJ3RleHQteGwtY2FwaXRhbGl6ZScsXG4gICAgJ25vLXBhZGRpbmcnLFxuICAgICdwYWRkaW5nJyxcbiAgICAncGFkZGluZy10b3AnLFxuICAgICdwYWRkaW5nLWJvdHRvbScsXG4gICAgJ3BhZGRpbmctc3RhcnQnLFxuICAgICdwYWRkaW5nLWVuZCcsXG4gICAgJ3BhZGRpbmctdmVydGljYWwnLFxuICAgICdwYWRkaW5nLWhvcml6b250YWwnLFxuICAgICduby1tYXJnaW4nLFxuICAgICdtYXJnaW4nLFxuICAgICdtYXJnaW4tdG9wJyxcbiAgICAnbWFyZ2luLWJvdHRvbScsXG4gICAgJ21hcmdpbi1zdGFydCcsXG4gICAgJ21hcmdpbi1lbmQnLFxuICAgICdtYXJnaW4tdmVydGljYWwnLFxuICAgICdtYXJnaW4taG9yaXpvbnRhbCdcbl07XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEB0ZW1wbGF0ZSBPcHRzLCBPdmVybGF5XG4gKi9cbnZhciAgLyoqXG4gKiBAdGVtcGxhdGUgT3B0cywgT3ZlcmxheVxuICovXG5PdmVybGF5QmFzZUNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3ZlcmxheUJhc2VDb250cm9sbGVyKGN0cmwpIHtcbiAgICAgICAgdGhpcy5jdHJsID0gY3RybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvdmVybGF5XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvdmVybGF5XG4gICAgICogQHBhcmFtIHs/PX0gb3B0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3ZlcmxheUJhc2VDb250cm9sbGVyLnByb3RvdHlwZS5jcmVhdGUgPSAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG92ZXJsYXlcbiAgICAgKiBAcGFyYW0gez89fSBvcHRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAvLyBUT0RPOiBuZXh0IG1ham9yIHJlbGVhc2Ugb3B0cyBpcyBub3Qgb3B0aW9uYWxcbiAgICAgICAgcmV0dXJuIHRoaXMuY3RybC5jcmVhdGUoKC8qKiBAdHlwZSB7P30gKi8gKChvcHRzIHx8IHt9KSkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gYGlkYCBpcyBub3QgcHJvdmlkZWQsIGl0IGRpc21pc3NlcyB0aGUgdG9wIG92ZXJsYXkuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogV2hlbiBgaWRgIGlzIG5vdCBwcm92aWRlZCwgaXQgZGlzbWlzc2VzIHRoZSB0b3Agb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0gez89fSBkYXRhXG4gICAgICogQHBhcmFtIHs/PX0gcm9sZVxuICAgICAqIEBwYXJhbSB7Pz19IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5QmFzZUNvbnRyb2xsZXIucHJvdG90eXBlLmRpc21pc3MgPSAvKipcbiAgICAgKiBXaGVuIGBpZGAgaXMgbm90IHByb3ZpZGVkLCBpdCBkaXNtaXNzZXMgdGhlIHRvcCBvdmVybGF5LlxuICAgICAqIEBwYXJhbSB7Pz19IGRhdGFcbiAgICAgKiBAcGFyYW0gez89fSByb2xlXG4gICAgICogQHBhcmFtIHs/PX0gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChkYXRhLCByb2xlLCBpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdHJsLmRpc21pc3MoZGF0YSwgcm9sZSwgaWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG9wIG92ZXJsYXkuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG9wIG92ZXJsYXkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5QmFzZUNvbnRyb2xsZXIucHJvdG90eXBlLmdldFRvcCA9IC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvcCBvdmVybGF5LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdHJsLmdldFRvcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIE92ZXJsYXlCYXNlQ29udHJvbGxlcjtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQWN0aW9uU2hlZXRDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY3Rpb25TaGVldENvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWN0aW9uU2hlZXRDb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgYWN0aW9uU2hlZXRDb250cm9sbGVyKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBY3Rpb25TaGVldENvbnRyb2xsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBBY3Rpb25TaGVldENvbnRyb2xsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi8gQWN0aW9uU2hlZXRDb250cm9sbGVyLm5nSW5qZWN0YWJsZURlZiA9IGRlZmluZUluamVjdGFibGUoeyBmYWN0b3J5OiBmdW5jdGlvbiBBY3Rpb25TaGVldENvbnRyb2xsZXJfRmFjdG9yeSgpIHsgcmV0dXJuIG5ldyBBY3Rpb25TaGVldENvbnRyb2xsZXIoKTsgfSwgdG9rZW46IEFjdGlvblNoZWV0Q29udHJvbGxlciwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG4gICAgcmV0dXJuIEFjdGlvblNoZWV0Q29udHJvbGxlcjtcbn0oT3ZlcmxheUJhc2VDb250cm9sbGVyKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQWxlcnRDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbGVydENvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWxlcnRDb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgYWxlcnRDb250cm9sbGVyKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBbGVydENvbnRyb2xsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBBbGVydENvbnRyb2xsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi8gQWxlcnRDb250cm9sbGVyLm5nSW5qZWN0YWJsZURlZiA9IGRlZmluZUluamVjdGFibGUoeyBmYWN0b3J5OiBmdW5jdGlvbiBBbGVydENvbnRyb2xsZXJfRmFjdG9yeSgpIHsgcmV0dXJuIG5ldyBBbGVydENvbnRyb2xsZXIoKTsgfSwgdG9rZW46IEFsZXJ0Q29udHJvbGxlciwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG4gICAgcmV0dXJuIEFsZXJ0Q29udHJvbGxlcjtcbn0oT3ZlcmxheUJhc2VDb250cm9sbGVyKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgRXZlbnRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5jID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbREVQUkVDQVRJT05dW0V2ZW50c106IFRoZSBFdmVudHMgcHJvdmlkZXIgaXMgZGVwcmVjYXRlZCBhbmQgaXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXFxuICAtIFVzZSBcXFwiT2JzZXJ2YWJsZXNcXFwiIGZvciBhIHNpbWlsYXIgcHViL3N1YiBhcmNoaXRlY3R1cmU6IGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9vYnNlcnZhYmxlc1xcbiAgLSBVc2UgXFxcIlJlZHV4XFxcIiBmb3IgYWR2YW5jZWQgc3RhdGUgbWFuYWdlbWVudDogaHR0cHM6Ly9uZ3J4LmlvXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gYW4gZXZlbnQgdG9waWMuIEV2ZW50cyB0aGF0IGdldCBwb3N0ZWQgdG8gdGhhdCB0b3BpYyB3aWxsIHRyaWdnZXIgdGhlIHByb3ZpZGVkIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9waWMgdGhlIHRvcGljIHRvIHN1YnNjcmliZSB0b1xuICAgICAqIEBwYXJhbSBoYW5kbGVyIHRoZSBldmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIGFuIGV2ZW50IHRvcGljLiBFdmVudHMgdGhhdCBnZXQgcG9zdGVkIHRvIHRoYXQgdG9waWMgd2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSB0b3BpYyB0aGUgdG9waWMgdG8gc3Vic2NyaWJlIHRvXG4gICAgICogQHBhcmFtIHsuLi4/fSBoYW5kbGVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXZlbnRzLnByb3RvdHlwZS5zdWJzY3JpYmUgPSAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gYW4gZXZlbnQgdG9waWMuIEV2ZW50cyB0aGF0IGdldCBwb3N0ZWQgdG8gdGhhdCB0b3BpYyB3aWxsIHRyaWdnZXIgdGhlIHByb3ZpZGVkIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHRvcGljIHRoZSB0b3BpYyB0byBzdWJzY3JpYmUgdG9cbiAgICAgKiBAcGFyYW0gey4uLj99IGhhbmRsZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodG9waWMpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciB0b3BpY3MgPSB0aGlzLmMuZ2V0KHRvcGljKTtcbiAgICAgICAgaWYgKCF0b3BpY3MpIHtcbiAgICAgICAgICAgIHRoaXMuYy5zZXQodG9waWMsIHRvcGljcyA9IFtdKTtcbiAgICAgICAgfVxuICAgICAgICB0b3BpY3MucHVzaC5hcHBseSh0b3BpY3MsIGhhbmRsZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGdpdmVuIHRvcGljLiBZb3VyIGhhbmRsZXIgd2lsbCBubyBsb25nZXIgcmVjZWl2ZSBldmVudHMgcHVibGlzaGVkIHRvIHRoaXMgdG9waWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9waWMgdGhlIHRvcGljIHRvIHVuc3Vic2NyaWJlIGZyb21cbiAgICAgKiBAcGFyYW0gaGFuZGxlciB0aGUgZXZlbnQgaGFuZGxlclxuICAgICAqXG4gICAgICogQHJldHVybiB0cnVlIGlmIGEgaGFuZGxlciB3YXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGdpdmVuIHRvcGljLiBZb3VyIGhhbmRsZXIgd2lsbCBubyBsb25nZXIgcmVjZWl2ZSBldmVudHMgcHVibGlzaGVkIHRvIHRoaXMgdG9waWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHRvcGljIHRoZSB0b3BpYyB0byB1bnN1YnNjcmliZSBmcm9tXG4gICAgICogQHBhcmFtIHs/PX0gaGFuZGxlciB0aGUgZXZlbnQgaGFuZGxlclxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gdHJ1ZSBpZiBhIGhhbmRsZXIgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBFdmVudHMucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gLyoqXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgZ2l2ZW4gdG9waWMuIFlvdXIgaGFuZGxlciB3aWxsIG5vIGxvbmdlciByZWNlaXZlIGV2ZW50cyBwdWJsaXNoZWQgdG8gdGhpcyB0b3BpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gdG9waWMgdGhlIHRvcGljIHRvIHVuc3Vic2NyaWJlIGZyb21cbiAgICAgKiBAcGFyYW0gez89fSBoYW5kbGVyIHRoZSBldmVudCBoYW5kbGVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSB0cnVlIGlmIGEgaGFuZGxlciB3YXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0b3BpYywgaGFuZGxlcikge1xuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmMuZGVsZXRlKHRvcGljKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciB0b3BpY3MgPSB0aGlzLmMuZ2V0KHRvcGljKTtcbiAgICAgICAgaWYgKCF0b3BpY3MpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgYW5kIHJlbW92ZSBhIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgaW5kZXggPSB0b3BpY3MuaW5kZXhPZihoYW5kbGVyKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgLy8gV2Fzbid0IGZvdW5kLCB3YXNuJ3QgcmVtb3ZlZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRvcGljcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAodG9waWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jLmRlbGV0ZSh0b3BpYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGFuIGV2ZW50IHRvIHRoZSBnaXZlbiB0b3BpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b3BpYyB0aGUgdG9waWMgdG8gcHVibGlzaCB0b1xuICAgICAqIEBwYXJhbSBldmVudERhdGEgdGhlIGRhdGEgdG8gc2VuZCBhcyB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGFuIGV2ZW50IHRvIHRoZSBnaXZlbiB0b3BpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gdG9waWMgdGhlIHRvcGljIHRvIHB1Ymxpc2ggdG9cbiAgICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV2ZW50cy5wcm90b3R5cGUucHVibGlzaCA9IC8qKlxuICAgICAqIFB1Ymxpc2ggYW4gZXZlbnQgdG8gdGhlIGdpdmVuIHRvcGljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSB0b3BpYyB0aGUgdG9waWMgdG8gcHVibGlzaCB0b1xuICAgICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHRvcGljcyA9IHRoaXMuYy5nZXQodG9waWMpO1xuICAgICAgICBpZiAoIXRvcGljcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcy5tYXAoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGhhbmRsZXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIEV2ZW50cy5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IEluamVjdGFibGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkSW46ICdyb290JyxcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEV2ZW50cy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqLyBFdmVudHMubmdJbmplY3RhYmxlRGVmID0gZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIEV2ZW50c19GYWN0b3J5KCkgeyByZXR1cm4gbmV3IEV2ZW50cygpOyB9LCB0b2tlbjogRXZlbnRzLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbiAgICByZXR1cm4gRXZlbnRzO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBMb2FkaW5nQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9hZGluZ0NvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTG9hZGluZ0NvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBsb2FkaW5nQ29udHJvbGxlcikgfHwgdGhpcztcbiAgICB9XG4gICAgTG9hZGluZ0NvbnRyb2xsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBMb2FkaW5nQ29udHJvbGxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqLyBMb2FkaW5nQ29udHJvbGxlci5uZ0luamVjdGFibGVEZWYgPSBkZWZpbmVJbmplY3RhYmxlKHsgZmFjdG9yeTogZnVuY3Rpb24gTG9hZGluZ0NvbnRyb2xsZXJfRmFjdG9yeSgpIHsgcmV0dXJuIG5ldyBMb2FkaW5nQ29udHJvbGxlcigpOyB9LCB0b2tlbjogTG9hZGluZ0NvbnRyb2xsZXIsIHByb3ZpZGVkSW46IFwicm9vdFwiIH0pO1xuICAgIHJldHVybiBMb2FkaW5nQ29udHJvbGxlcjtcbn0oT3ZlcmxheUJhc2VDb250cm9sbGVyKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgTWVudUNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVudUNvbnRyb2xsZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2dyYW1tYXRpY2FsbHkgb3BlbiB0aGUgTWVudS5cbiAgICAgKiBAcGFyYW0gW21lbnVJZF0gIE9wdGlvbmFsbHkgZ2V0IHRoZSBtZW51IGJ5IGl0cyBpZCwgb3Igc2lkZS5cbiAgICAgKiBAcmV0dXJuIHJldHVybnMgYSBwcm9taXNlIHdoZW4gdGhlIG1lbnUgaXMgZnVsbHkgb3BlbmVkXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUHJvZ3JhbW1hdGljYWxseSBvcGVuIHRoZSBNZW51LlxuICAgICAqIEBwYXJhbSB7Pz19IG1lbnVJZFxuICAgICAqIEByZXR1cm4gez99IHJldHVybnMgYSBwcm9taXNlIHdoZW4gdGhlIG1lbnUgaXMgZnVsbHkgb3BlbmVkXG4gICAgICovXG4gICAgTWVudUNvbnRyb2xsZXIucHJvdG90eXBlLm9wZW4gPSAvKipcbiAgICAgKiBQcm9ncmFtbWF0aWNhbGx5IG9wZW4gdGhlIE1lbnUuXG4gICAgICogQHBhcmFtIHs/PX0gbWVudUlkXG4gICAgICogQHJldHVybiB7P30gcmV0dXJucyBhIHByb21pc2Ugd2hlbiB0aGUgbWVudSBpcyBmdWxseSBvcGVuZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWVudUlkKSB7XG4gICAgICAgIHJldHVybiBtZW51Q29udHJvbGxlci5vcGVuKG1lbnVJZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9ncmFtbWF0aWNhbGx5IGNsb3NlIHRoZSBNZW51LiBJZiBubyBgbWVudUlkYCBpcyBnaXZlbiBhcyB0aGUgZmlyc3RcbiAgICAgKiBhcmd1bWVudCB0aGVuIGl0J2xsIGNsb3NlIGFueSBtZW51IHdoaWNoIGlzIG9wZW4uIElmIGEgYG1lbnVJZGBcbiAgICAgKiBpcyBnaXZlbiB0aGVuIGl0J2xsIGNsb3NlIHRoYXQgZXhhY3QgbWVudS5cbiAgICAgKiBAcGFyYW0gW21lbnVJZF0gIE9wdGlvbmFsbHkgZ2V0IHRoZSBtZW51IGJ5IGl0cyBpZCwgb3Igc2lkZS5cbiAgICAgKiBAcmV0dXJuIHJldHVybnMgYSBwcm9taXNlIHdoZW4gdGhlIG1lbnUgaXMgZnVsbHkgY2xvc2VkXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUHJvZ3JhbW1hdGljYWxseSBjbG9zZSB0aGUgTWVudS4gSWYgbm8gYG1lbnVJZGAgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0XG4gICAgICogYXJndW1lbnQgdGhlbiBpdCdsbCBjbG9zZSBhbnkgbWVudSB3aGljaCBpcyBvcGVuLiBJZiBhIGBtZW51SWRgXG4gICAgICogaXMgZ2l2ZW4gdGhlbiBpdCdsbCBjbG9zZSB0aGF0IGV4YWN0IG1lbnUuXG4gICAgICogQHBhcmFtIHs/PX0gbWVudUlkXG4gICAgICogQHJldHVybiB7P30gcmV0dXJucyBhIHByb21pc2Ugd2hlbiB0aGUgbWVudSBpcyBmdWxseSBjbG9zZWRcbiAgICAgKi9cbiAgICBNZW51Q29udHJvbGxlci5wcm90b3R5cGUuY2xvc2UgPSAvKipcbiAgICAgKiBQcm9ncmFtbWF0aWNhbGx5IGNsb3NlIHRoZSBNZW51LiBJZiBubyBgbWVudUlkYCBpcyBnaXZlbiBhcyB0aGUgZmlyc3RcbiAgICAgKiBhcmd1bWVudCB0aGVuIGl0J2xsIGNsb3NlIGFueSBtZW51IHdoaWNoIGlzIG9wZW4uIElmIGEgYG1lbnVJZGBcbiAgICAgKiBpcyBnaXZlbiB0aGVuIGl0J2xsIGNsb3NlIHRoYXQgZXhhY3QgbWVudS5cbiAgICAgKiBAcGFyYW0gez89fSBtZW51SWRcbiAgICAgKiBAcmV0dXJuIHs/fSByZXR1cm5zIGEgcHJvbWlzZSB3aGVuIHRoZSBtZW51IGlzIGZ1bGx5IGNsb3NlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtZW51SWQpIHtcbiAgICAgICAgcmV0dXJuIG1lbnVDb250cm9sbGVyLmNsb3NlKG1lbnVJZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIG1lbnUuIElmIGl0J3MgY2xvc2VkLCBpdCB3aWxsIG9wZW4sIGFuZCBpZiBvcGVuZWQsIGl0XG4gICAgICogd2lsbCBjbG9zZS5cbiAgICAgKiBAcGFyYW0gW21lbnVJZF0gIE9wdGlvbmFsbHkgZ2V0IHRoZSBtZW51IGJ5IGl0cyBpZCwgb3Igc2lkZS5cbiAgICAgKiBAcmV0dXJuIHJldHVybnMgYSBwcm9taXNlIHdoZW4gdGhlIG1lbnUgaGFzIGJlZW4gdG9nZ2xlZFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgbWVudS4gSWYgaXQncyBjbG9zZWQsIGl0IHdpbGwgb3BlbiwgYW5kIGlmIG9wZW5lZCwgaXRcbiAgICAgKiB3aWxsIGNsb3NlLlxuICAgICAqIEBwYXJhbSB7Pz19IG1lbnVJZFxuICAgICAqIEByZXR1cm4gez99IHJldHVybnMgYSBwcm9taXNlIHdoZW4gdGhlIG1lbnUgaGFzIGJlZW4gdG9nZ2xlZFxuICAgICAqL1xuICAgIE1lbnVDb250cm9sbGVyLnByb3RvdHlwZS50b2dnbGUgPSAvKipcbiAgICAgKiBUb2dnbGUgdGhlIG1lbnUuIElmIGl0J3MgY2xvc2VkLCBpdCB3aWxsIG9wZW4sIGFuZCBpZiBvcGVuZWQsIGl0XG4gICAgICogd2lsbCBjbG9zZS5cbiAgICAgKiBAcGFyYW0gez89fSBtZW51SWRcbiAgICAgKiBAcmV0dXJuIHs/fSByZXR1cm5zIGEgcHJvbWlzZSB3aGVuIHRoZSBtZW51IGhhcyBiZWVuIHRvZ2dsZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWVudUlkKSB7XG4gICAgICAgIHJldHVybiBtZW51Q29udHJvbGxlci50b2dnbGUobWVudUlkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZW5hYmxlIG9yIGRpc2FibGUgYSBtZW51LiBGb3IgZXhhbXBsZSwgdGhlcmUgY291bGQgYmUgbXVsdGlwbGVcbiAgICAgKiBsZWZ0IG1lbnVzLCBidXQgb25seSBvbmUgb2YgdGhlbSBzaG91bGQgYmUgYWJsZSB0byBiZSBvcGVuZWQgYXQgdGhlIHNhbWVcbiAgICAgKiB0aW1lLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgbWVudXMgb24gdGhlIHNhbWUgc2lkZSwgdGhlbiBlbmFibGluZyBvbmUgbWVudVxuICAgICAqIHdpbGwgYWxzbyBhdXRvbWF0aWNhbGx5IGRpc2FibGUgYWxsIHRoZSBvdGhlcnMgdGhhdCBhcmUgb24gdGhlIHNhbWUgc2lkZS5cbiAgICAgKiBAcGFyYW0gW21lbnVJZF0gIE9wdGlvbmFsbHkgZ2V0IHRoZSBtZW51IGJ5IGl0cyBpZCwgb3Igc2lkZS5cbiAgICAgKiBAcmV0dXJuIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBtZW51LCB3aGljaCBpcyB1c2VmdWwgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZW5hYmxlIG9yIGRpc2FibGUgYSBtZW51LiBGb3IgZXhhbXBsZSwgdGhlcmUgY291bGQgYmUgbXVsdGlwbGVcbiAgICAgKiBsZWZ0IG1lbnVzLCBidXQgb25seSBvbmUgb2YgdGhlbSBzaG91bGQgYmUgYWJsZSB0byBiZSBvcGVuZWQgYXQgdGhlIHNhbWVcbiAgICAgKiB0aW1lLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgbWVudXMgb24gdGhlIHNhbWUgc2lkZSwgdGhlbiBlbmFibGluZyBvbmUgbWVudVxuICAgICAqIHdpbGwgYWxzbyBhdXRvbWF0aWNhbGx5IGRpc2FibGUgYWxsIHRoZSBvdGhlcnMgdGhhdCBhcmUgb24gdGhlIHNhbWUgc2lkZS5cbiAgICAgKiBAcGFyYW0gez99IHNob3VsZEVuYWJsZVxuICAgICAqIEBwYXJhbSB7Pz19IG1lbnVJZFxuICAgICAqIEByZXR1cm4gez99IFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBtZW51LCB3aGljaCBpcyB1c2VmdWwgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIE1lbnVDb250cm9sbGVyLnByb3RvdHlwZS5lbmFibGUgPSAvKipcbiAgICAgKiBVc2VkIHRvIGVuYWJsZSBvciBkaXNhYmxlIGEgbWVudS4gRm9yIGV4YW1wbGUsIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlXG4gICAgICogbGVmdCBtZW51cywgYnV0IG9ubHkgb25lIG9mIHRoZW0gc2hvdWxkIGJlIGFibGUgdG8gYmUgb3BlbmVkIGF0IHRoZSBzYW1lXG4gICAgICogdGltZS4gSWYgdGhlcmUgYXJlIG11bHRpcGxlIG1lbnVzIG9uIHRoZSBzYW1lIHNpZGUsIHRoZW4gZW5hYmxpbmcgb25lIG1lbnVcbiAgICAgKiB3aWxsIGFsc28gYXV0b21hdGljYWxseSBkaXNhYmxlIGFsbCB0aGUgb3RoZXJzIHRoYXQgYXJlIG9uIHRoZSBzYW1lIHNpZGUuXG4gICAgICogQHBhcmFtIHs/fSBzaG91bGRFbmFibGVcbiAgICAgKiBAcGFyYW0gez89fSBtZW51SWRcbiAgICAgKiBAcmV0dXJuIHs/fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgbWVudSwgd2hpY2ggaXMgdXNlZnVsIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc2hvdWxkRW5hYmxlLCBtZW51SWQpIHtcbiAgICAgICAgcmV0dXJuIG1lbnVDb250cm9sbGVyLmVuYWJsZShzaG91bGRFbmFibGUsIG1lbnVJZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBhYmlsaXR5IHRvIHN3aXBlIG9wZW4gdGhlIG1lbnUuXG4gICAgICogQHBhcmFtIHNob3VsZEVuYWJsZSAgVHJ1ZSBpZiBpdCBzaG91bGQgYmUgc3dpcGUtYWJsZSwgZmFsc2UgaWYgbm90LlxuICAgICAqIEBwYXJhbSBbbWVudUlkXSAgT3B0aW9uYWxseSBnZXQgdGhlIG1lbnUgYnkgaXRzIGlkLCBvciBzaWRlLlxuICAgICAqIEByZXR1cm4gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIG1lbnUsIHdoaWNoIGlzIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHN3aXBlR2VzdHVyZSgpIGluc3RlYWQuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYWJpbGl0eSB0byBzd2lwZSBvcGVuIHRoZSBtZW51LlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBzd2lwZUdlc3R1cmUoKSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSB7P30gc2hvdWxkRW5hYmxlICBUcnVlIGlmIGl0IHNob3VsZCBiZSBzd2lwZS1hYmxlLCBmYWxzZSBpZiBub3QuXG4gICAgICogQHBhcmFtIHs/PX0gbWVudUlkXG4gICAgICogQHJldHVybiB7P30gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIG1lbnUsIHdoaWNoIGlzIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgTWVudUNvbnRyb2xsZXIucHJvdG90eXBlLnN3aXBlRW5hYmxlID0gLyoqXG4gICAgICogVXNlZCB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYWJpbGl0eSB0byBzd2lwZSBvcGVuIHRoZSBtZW51LlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBzd2lwZUdlc3R1cmUoKSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSB7P30gc2hvdWxkRW5hYmxlICBUcnVlIGlmIGl0IHNob3VsZCBiZSBzd2lwZS1hYmxlLCBmYWxzZSBpZiBub3QuXG4gICAgICogQHBhcmFtIHs/PX0gbWVudUlkXG4gICAgICogQHJldHVybiB7P30gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIG1lbnUsIHdoaWNoIGlzIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHNob3VsZEVuYWJsZSwgbWVudUlkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW0RFUFJFQ0FURURdW2lvbi1tZW51LWNvbnRyb2xsZXJdIHN3aXBlRW5hYmxlKCkgaXMgZGVwcmVjYXRlZC4gVXNlIE1lbnVDb250cm9sbGVyLnN3aXBlR2VzdHVyZSgpIGluc3RlYWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3dpcGVHZXN0dXJlKHNob3VsZEVuYWJsZSwgbWVudUlkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGFiaWxpdHkgdG8gc3dpcGUgb3BlbiB0aGUgbWVudS5cbiAgICAgKiBAcGFyYW0gc2hvdWxkRW5hYmxlICBUcnVlIGlmIGl0IHNob3VsZCBiZSBzd2lwZS1hYmxlLCBmYWxzZSBpZiBub3QuXG4gICAgICogQHBhcmFtIFttZW51SWRdICBPcHRpb25hbGx5IGdldCB0aGUgbWVudSBieSBpdHMgaWQsIG9yIHNpZGUuXG4gICAgICogQHJldHVybiBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgbWVudSwgd2hpY2ggaXMgdXNlZnVsIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBhYmlsaXR5IHRvIHN3aXBlIG9wZW4gdGhlIG1lbnUuXG4gICAgICogQHBhcmFtIHs/fSBzaG91bGRFbmFibGUgIFRydWUgaWYgaXQgc2hvdWxkIGJlIHN3aXBlLWFibGUsIGZhbHNlIGlmIG5vdC5cbiAgICAgKiBAcGFyYW0gez89fSBtZW51SWRcbiAgICAgKiBAcmV0dXJuIHs/fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgbWVudSwgd2hpY2ggaXMgdXNlZnVsIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBNZW51Q29udHJvbGxlci5wcm90b3R5cGUuc3dpcGVHZXN0dXJlID0gLyoqXG4gICAgICogVXNlZCB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYWJpbGl0eSB0byBzd2lwZSBvcGVuIHRoZSBtZW51LlxuICAgICAqIEBwYXJhbSB7P30gc2hvdWxkRW5hYmxlICBUcnVlIGlmIGl0IHNob3VsZCBiZSBzd2lwZS1hYmxlLCBmYWxzZSBpZiBub3QuXG4gICAgICogQHBhcmFtIHs/PX0gbWVudUlkXG4gICAgICogQHJldHVybiB7P30gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIG1lbnUsIHdoaWNoIGlzIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHNob3VsZEVuYWJsZSwgbWVudUlkKSB7XG4gICAgICAgIHJldHVybiBtZW51Q29udHJvbGxlci5zd2lwZUdlc3R1cmUoc2hvdWxkRW5hYmxlLCBtZW51SWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIFttZW51SWRdIE9wdGlvbmFsbHkgZ2V0IHRoZSBtZW51IGJ5IGl0cyBpZCwgb3Igc2lkZS5cbiAgICAgKiBAcmV0dXJuIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIG1lbnUgaXMgY3VycmVudGx5IG9wZW4sIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKiBJZiB0aGUgbWVudUlkIGlzIG5vdCBzcGVjaWZpZWQsIGl0IHJldHVybnMgdHJ1ZSBpZiBBTlkgbWVudSBpcyBjdXJyZW5seSBvcGVuLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG1lbnVJZFxuICAgICAqIEByZXR1cm4gez99IFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIG1lbnUgaXMgY3VycmVudGx5IG9wZW4sIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKiBJZiB0aGUgbWVudUlkIGlzIG5vdCBzcGVjaWZpZWQsIGl0IHJldHVybnMgdHJ1ZSBpZiBBTlkgbWVudSBpcyBjdXJyZW5seSBvcGVuLlxuICAgICAqL1xuICAgIE1lbnVDb250cm9sbGVyLnByb3RvdHlwZS5pc09wZW4gPSAvKipcbiAgICAgKiBAcGFyYW0gez89fSBtZW51SWRcbiAgICAgKiBAcmV0dXJuIHs/fSBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBtZW51IGlzIGN1cnJlbnRseSBvcGVuLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICogSWYgdGhlIG1lbnVJZCBpcyBub3Qgc3BlY2lmaWVkLCBpdCByZXR1cm5zIHRydWUgaWYgQU5ZIG1lbnUgaXMgY3VycmVubHkgb3Blbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWVudUlkKSB7XG4gICAgICAgIHJldHVybiBtZW51Q29udHJvbGxlci5pc09wZW4obWVudUlkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBbbWVudUlkXSAgT3B0aW9uYWxseSBnZXQgdGhlIG1lbnUgYnkgaXRzIGlkLCBvciBzaWRlLlxuICAgICAqIEByZXR1cm4gUmV0dXJucyB0cnVlIGlmIHRoZSBtZW51IGlzIGN1cnJlbnRseSBlbmFibGVkLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gbWVudUlkXG4gICAgICogQHJldHVybiB7P30gUmV0dXJucyB0cnVlIGlmIHRoZSBtZW51IGlzIGN1cnJlbnRseSBlbmFibGVkLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgTWVudUNvbnRyb2xsZXIucHJvdG90eXBlLmlzRW5hYmxlZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG1lbnVJZFxuICAgICAqIEByZXR1cm4gez99IFJldHVybnMgdHJ1ZSBpZiB0aGUgbWVudSBpcyBjdXJyZW50bHkgZW5hYmxlZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtZW51SWQpIHtcbiAgICAgICAgcmV0dXJuIG1lbnVDb250cm9sbGVyLmlzRW5hYmxlZChtZW51SWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBnZXQgYSBtZW51IGluc3RhbmNlLiBJZiBhIGBtZW51SWRgIGlzIG5vdCBwcm92aWRlZCB0aGVuIGl0J2xsXG4gICAgICogcmV0dXJuIHRoZSBmaXJzdCBtZW51IGZvdW5kLiBJZiBhIGBtZW51SWRgIGlzIGBsZWZ0YCBvciBgcmlnaHRgLCB0aGVuXG4gICAgICogaXQnbGwgcmV0dXJuIHRoZSBlbmFibGVkIG1lbnUgb24gdGhhdCBzaWRlLiBPdGhlcndpc2UsIGlmIGEgYG1lbnVJZGAgaXNcbiAgICAgKiBwcm92aWRlZCwgdGhlbiBpdCdsbCB0cnkgdG8gZmluZCB0aGUgbWVudSB1c2luZyB0aGUgbWVudSdzIGBpZGBcbiAgICAgKiBwcm9wZXJ0eS4gSWYgYSBtZW51IGlzIG5vdCBmb3VuZCB0aGVuIGl0J2xsIHJldHVybiBgbnVsbGAuXG4gICAgICogQHBhcmFtIFttZW51SWRdICBPcHRpb25hbGx5IGdldCB0aGUgbWVudSBieSBpdHMgaWQsIG9yIHNpZGUuXG4gICAgICogQHJldHVybiBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgbWVudSBpZiBmb3VuZCwgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGdldCBhIG1lbnUgaW5zdGFuY2UuIElmIGEgYG1lbnVJZGAgaXMgbm90IHByb3ZpZGVkIHRoZW4gaXQnbGxcbiAgICAgKiByZXR1cm4gdGhlIGZpcnN0IG1lbnUgZm91bmQuIElmIGEgYG1lbnVJZGAgaXMgYGxlZnRgIG9yIGByaWdodGAsIHRoZW5cbiAgICAgKiBpdCdsbCByZXR1cm4gdGhlIGVuYWJsZWQgbWVudSBvbiB0aGF0IHNpZGUuIE90aGVyd2lzZSwgaWYgYSBgbWVudUlkYCBpc1xuICAgICAqIHByb3ZpZGVkLCB0aGVuIGl0J2xsIHRyeSB0byBmaW5kIHRoZSBtZW51IHVzaW5nIHRoZSBtZW51J3MgYGlkYFxuICAgICAqIHByb3BlcnR5LiBJZiBhIG1lbnUgaXMgbm90IGZvdW5kIHRoZW4gaXQnbGwgcmV0dXJuIGBudWxsYC5cbiAgICAgKiBAcGFyYW0gez89fSBtZW51SWRcbiAgICAgKiBAcmV0dXJuIHs/fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgbWVudSBpZiBmb3VuZCwgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKi9cbiAgICBNZW51Q29udHJvbGxlci5wcm90b3R5cGUuZ2V0ID0gLyoqXG4gICAgICogVXNlZCB0byBnZXQgYSBtZW51IGluc3RhbmNlLiBJZiBhIGBtZW51SWRgIGlzIG5vdCBwcm92aWRlZCB0aGVuIGl0J2xsXG4gICAgICogcmV0dXJuIHRoZSBmaXJzdCBtZW51IGZvdW5kLiBJZiBhIGBtZW51SWRgIGlzIGBsZWZ0YCBvciBgcmlnaHRgLCB0aGVuXG4gICAgICogaXQnbGwgcmV0dXJuIHRoZSBlbmFibGVkIG1lbnUgb24gdGhhdCBzaWRlLiBPdGhlcndpc2UsIGlmIGEgYG1lbnVJZGAgaXNcbiAgICAgKiBwcm92aWRlZCwgdGhlbiBpdCdsbCB0cnkgdG8gZmluZCB0aGUgbWVudSB1c2luZyB0aGUgbWVudSdzIGBpZGBcbiAgICAgKiBwcm9wZXJ0eS4gSWYgYSBtZW51IGlzIG5vdCBmb3VuZCB0aGVuIGl0J2xsIHJldHVybiBgbnVsbGAuXG4gICAgICogQHBhcmFtIHs/PX0gbWVudUlkXG4gICAgICogQHJldHVybiB7P30gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIG1lbnUgaWYgZm91bmQsIG90aGVyd2lzZSBgbnVsbGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1lbnVJZCkge1xuICAgICAgICByZXR1cm4gbWVudUNvbnRyb2xsZXIuZ2V0KG1lbnVJZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBtZW51IGFscmVhZHkgb3BlbmVkLCBvdGhlcndpc2UgYG51bGxgLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99IFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBtZW51IGFscmVhZHkgb3BlbmVkLCBvdGhlcndpc2UgYG51bGxgLlxuICAgICAqL1xuICAgIE1lbnVDb250cm9sbGVyLnByb3RvdHlwZS5nZXRPcGVuID0gLyoqXG4gICAgICogQHJldHVybiB7P30gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIG1lbnUgYWxyZWFkeSBvcGVuZWQsIG90aGVyd2lzZSBgbnVsbGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWVudUNvbnRyb2xsZXIuZ2V0T3BlbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBtZW51IGluc3RhbmNlcy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fSBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBtZW51IGluc3RhbmNlcy5cbiAgICAgKi9cbiAgICBNZW51Q29udHJvbGxlci5wcm90b3R5cGUuZ2V0TWVudXMgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fSBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBtZW51IGluc3RhbmNlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZW51Q29udHJvbGxlci5nZXRNZW51cygpO1xuICAgIH07XG4gICAgTWVudUNvbnRyb2xsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi8gTWVudUNvbnRyb2xsZXIubmdJbmplY3RhYmxlRGVmID0gZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIE1lbnVDb250cm9sbGVyX0ZhY3RvcnkoKSB7IHJldHVybiBuZXcgTWVudUNvbnRyb2xsZXIoKTsgfSwgdG9rZW46IE1lbnVDb250cm9sbGVyLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbiAgICByZXR1cm4gTWVudUNvbnRyb2xsZXI7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFBpY2tlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBpY2tlckNvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGlja2VyQ29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBpY2tlckNvbnRyb2xsZXIpIHx8IHRoaXM7XG4gICAgfVxuICAgIFBpY2tlckNvbnRyb2xsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBQaWNrZXJDb250cm9sbGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgLyoqIEBub2NvbGxhcHNlICovIFBpY2tlckNvbnRyb2xsZXIubmdJbmplY3RhYmxlRGVmID0gZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIFBpY2tlckNvbnRyb2xsZXJfRmFjdG9yeSgpIHsgcmV0dXJuIG5ldyBQaWNrZXJDb250cm9sbGVyKCk7IH0sIHRva2VuOiBQaWNrZXJDb250cm9sbGVyLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbiAgICByZXR1cm4gUGlja2VyQ29udHJvbGxlcjtcbn0oT3ZlcmxheUJhc2VDb250cm9sbGVyKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgTW9kYWxDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb2RhbENvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9kYWxDb250cm9sbGVyKGFuZ3VsYXJEZWxlZ2F0ZSwgcmVzb2x2ZXIsIGluamVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vZGFsQ29udHJvbGxlcikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYW5ndWxhckRlbGVnYXRlID0gYW5ndWxhckRlbGVnYXRlO1xuICAgICAgICBfdGhpcy5yZXNvbHZlciA9IHJlc29sdmVyO1xuICAgICAgICBfdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3B0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTW9kYWxDb250cm9sbGVyLnByb3RvdHlwZS5jcmVhdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG9wdHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNyZWF0ZS5jYWxsKHRoaXMsIF9fYXNzaWduKHt9LCBvcHRzLCB7IGRlbGVnYXRlOiB0aGlzLmFuZ3VsYXJEZWxlZ2F0ZS5jcmVhdGUodGhpcy5yZXNvbHZlciwgdGhpcy5pbmplY3RvcikgfSkpO1xuICAgIH07XG4gICAgTW9kYWxDb250cm9sbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgTW9kYWxDb250cm9sbGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEFuZ3VsYXJEZWxlZ2F0ZSB9LFxuICAgICAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB9LFxuICAgICAgICB7IHR5cGU6IEluamVjdG9yIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBNb2RhbENvbnRyb2xsZXI7XG59KE92ZXJsYXlCYXNlQ29udHJvbGxlcikpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFBvcG92ZXJDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQb3BvdmVyQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb3BvdmVyQ29udHJvbGxlcihhbmd1bGFyRGVsZWdhdGUsIHJlc29sdmVyLCBpbmplY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwb3BvdmVyQ29udHJvbGxlcikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYW5ndWxhckRlbGVnYXRlID0gYW5ndWxhckRlbGVnYXRlO1xuICAgICAgICBfdGhpcy5yZXNvbHZlciA9IHJlc29sdmVyO1xuICAgICAgICBfdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3B0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUG9wb3ZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNyZWF0ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3B0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY3JlYXRlLmNhbGwodGhpcywgX19hc3NpZ24oe30sIG9wdHMsIHsgZGVsZWdhdGU6IHRoaXMuYW5ndWxhckRlbGVnYXRlLmNyZWF0ZSh0aGlzLnJlc29sdmVyLCB0aGlzLmluamVjdG9yKSB9KSk7XG4gICAgfTtcbiAgICBQb3BvdmVyQ29udHJvbGxlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFBvcG92ZXJDb250cm9sbGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEFuZ3VsYXJEZWxlZ2F0ZSB9LFxuICAgICAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB9LFxuICAgICAgICB7IHR5cGU6IEluamVjdG9yIH1cbiAgICBdOyB9O1xuICAgIHJldHVybiBQb3BvdmVyQ29udHJvbGxlcjtcbn0oT3ZlcmxheUJhc2VDb250cm9sbGVyKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgVG9hc3RDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUb2FzdENvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9hc3RDb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdG9hc3RDb250cm9sbGVyKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUb2FzdENvbnRyb2xsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBUb2FzdENvbnRyb2xsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi8gVG9hc3RDb250cm9sbGVyLm5nSW5qZWN0YWJsZURlZiA9IGRlZmluZUluamVjdGFibGUoeyBmYWN0b3J5OiBmdW5jdGlvbiBUb2FzdENvbnRyb2xsZXJfRmFjdG9yeSgpIHsgcmV0dXJuIG5ldyBUb2FzdENvbnRyb2xsZXIoKTsgfSwgdG9rZW46IFRvYXN0Q29udHJvbGxlciwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG4gICAgcmV0dXJuIFRvYXN0Q29udHJvbGxlcjtcbn0oT3ZlcmxheUJhc2VDb250cm9sbGVyKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgRG9tQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb21Db250cm9sbGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYSB0YXNrIHRvIHJ1biBkdXJpbmcgdGhlIFJFQUQgcGhhc2Ugb2YgdGhlIG5leHQgZnJhbWUuXG4gICAgICogVGhpcyB0YXNrIHNob3VsZCBvbmx5IHJlYWQgdGhlIERPTSwgYnV0IG5ldmVyIG1vZGlmeSBpdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYSB0YXNrIHRvIHJ1biBkdXJpbmcgdGhlIFJFQUQgcGhhc2Ugb2YgdGhlIG5leHQgZnJhbWUuXG4gICAgICogVGhpcyB0YXNrIHNob3VsZCBvbmx5IHJlYWQgdGhlIERPTSwgYnV0IG5ldmVyIG1vZGlmeSBpdC5cbiAgICAgKiBAcGFyYW0gez99IGNiXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21Db250cm9sbGVyLnByb3RvdHlwZS5yZWFkID0gLyoqXG4gICAgICogU2NoZWR1bGVzIGEgdGFzayB0byBydW4gZHVyaW5nIHRoZSBSRUFEIHBoYXNlIG9mIHRoZSBuZXh0IGZyYW1lLlxuICAgICAqIFRoaXMgdGFzayBzaG91bGQgb25seSByZWFkIHRoZSBET00sIGJ1dCBuZXZlciBtb2RpZnkgaXQuXG4gICAgICogQHBhcmFtIHs/fSBjYlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIGdldFF1ZXVlKCkucmVhZChjYik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYSB0YXNrIHRvIHJ1biBkdXJpbmcgdGhlIFdSSVRFIHBoYXNlIG9mIHRoZSBuZXh0IGZyYW1lLlxuICAgICAqIFRoaXMgdGFzayBzaG91bGQgd3JpdGUgdGhlIERPTSwgYnV0IG5ldmVyIFJFQUQgaXQuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgdGFzayB0byBydW4gZHVyaW5nIHRoZSBXUklURSBwaGFzZSBvZiB0aGUgbmV4dCBmcmFtZS5cbiAgICAgKiBUaGlzIHRhc2sgc2hvdWxkIHdyaXRlIHRoZSBET00sIGJ1dCBuZXZlciBSRUFEIGl0LlxuICAgICAqIEBwYXJhbSB7P30gY2JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUNvbnRyb2xsZXIucHJvdG90eXBlLndyaXRlID0gLyoqXG4gICAgICogU2NoZWR1bGVzIGEgdGFzayB0byBydW4gZHVyaW5nIHRoZSBXUklURSBwaGFzZSBvZiB0aGUgbmV4dCBmcmFtZS5cbiAgICAgKiBUaGlzIHRhc2sgc2hvdWxkIHdyaXRlIHRoZSBET00sIGJ1dCBuZXZlciBSRUFEIGl0LlxuICAgICAqIEBwYXJhbSB7P30gY2JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjYikge1xuICAgICAgICBnZXRRdWV1ZSgpLndyaXRlKGNiKTtcbiAgICB9O1xuICAgIERvbUNvbnRyb2xsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi8gRG9tQ29udHJvbGxlci5uZ0luamVjdGFibGVEZWYgPSBkZWZpbmVJbmplY3RhYmxlKHsgZmFjdG9yeTogZnVuY3Rpb24gRG9tQ29udHJvbGxlcl9GYWN0b3J5KCkgeyByZXR1cm4gbmV3IERvbUNvbnRyb2xsZXIoKTsgfSwgdG9rZW46IERvbUNvbnRyb2xsZXIsIHByb3ZpZGVkSW46IFwicm9vdFwiIH0pO1xuICAgIHJldHVybiBEb21Db250cm9sbGVyO1xufSgpKTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBnZXRRdWV1ZSA9ICgvKipcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgdmFyIHdpbiA9IHR5cGVvZiAoKC8qKiBAdHlwZSB7P30gKi8gKHdpbmRvdykpKSAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiAoLyoqIEB0eXBlIHs/fSAqLyAobnVsbCkpO1xuICAgIGlmICh3aW4gIT0gbnVsbCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBJb25pYyA9IHdpbi5Jb25pYztcbiAgICAgICAgaWYgKElvbmljICYmIElvbmljLnF1ZXVlKSB7XG4gICAgICAgICAgICByZXR1cm4gSW9uaWMucXVldWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWQ6ICgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gY2JcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChjYikgeyByZXR1cm4gd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7IH0pLFxuICAgICAgICAgICAgd3JpdGU6ICgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gY2JcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChjYikgeyByZXR1cm4gd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7IH0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlYWQ6ICgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KSxcbiAgICAgICAgd3JpdGU6ICgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KVxuICAgIH07XG59KTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBJb25pY1JvdXRlU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW9uaWNSb3V0ZVN0cmF0ZWd5KCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yb3V0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uaWNSb3V0ZVN0cmF0ZWd5LnByb3RvdHlwZS5zaG91bGREZXRhY2ggPSAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yb3V0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKF9yb3V0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yb3V0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uaWNSb3V0ZVN0cmF0ZWd5LnByb3RvdHlwZS5zaG91bGRBdHRhY2ggPSAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yb3V0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKF9yb3V0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yb3V0ZVxuICAgICAqIEBwYXJhbSB7P30gX2RldGFjaGVkVHJlZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uaWNSb3V0ZVN0cmF0ZWd5LnByb3RvdHlwZS5zdG9yZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3JvdXRlXG4gICAgICogQHBhcmFtIHs/fSBfZGV0YWNoZWRUcmVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoX3JvdXRlLCBfZGV0YWNoZWRUcmVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3JvdXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJb25pY1JvdXRlU3RyYXRlZ3kucHJvdG90eXBlLnJldHJpZXZlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcm91dGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChfcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZ1dHVyZVxuICAgICAqIEBwYXJhbSB7P30gY3VyclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW9uaWNSb3V0ZVN0cmF0ZWd5LnByb3RvdHlwZS5zaG91bGRSZXVzZVJvdXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBmdXR1cmVcbiAgICAgKiBAcGFyYW0gez99IGN1cnJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmdXR1cmUsIGN1cnIpIHtcbiAgICAgICAgaWYgKGZ1dHVyZS5yb3V0ZUNvbmZpZyAhPT0gY3Vyci5yb3V0ZUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNraW5nIHJvdXRlciBwYXJhbXNcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgZnV0dXJlUGFyYW1zID0gZnV0dXJlLnBhcmFtcztcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgY3VycmVudFBhcmFtcyA9IGN1cnIucGFyYW1zO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGZ1dHVyZVBhcmFtcyk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoY3VycmVudFBhcmFtcyk7XG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwga2V5c0FfMSA9IGtleXNBOyBfaSA8IGtleXNBXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c0FfMVtfaV07XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcmFtc1trZXldICE9PSBmdXR1cmVQYXJhbXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBJb25pY1JvdXRlU3RyYXRlZ3k7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqIEB0eXBlIHs/fSAqL1xudmFyIGRpZEluaXRpYWxpemUgPSBmYWxzZTtcbi8qKiBAdHlwZSB7P30gKi9cbnZhciBhcHBJbml0aWFsaXplID0gKC8qKlxuICogQHBhcmFtIHs/fSBjb25maWdcbiAqIEBwYXJhbSB7P30gZG9jXG4gKiBAcGFyYW0gez99IHpvbmVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIChjb25maWcsIGRvYywgem9uZSkge1xuICAgIHJldHVybiAoLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHdpbiA9ICgvKiogQHR5cGUgez99ICovIChkb2MuZGVmYXVsdFZpZXcpKTtcbiAgICAgICAgaWYgKHdpbikge1xuICAgICAgICAgICAgaWYgKGRpZEluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0lvbmljIEFuZ3VsYXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuIE1ha2Ugc3VyZSBJb25pY01vZHVsZS5mb3JSb290KCkgaXMganVzdCBjYWxsZWQgb25jZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpZEluaXRpYWxpemUgPSB0cnVlO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIElvbmljID0gd2luLklvbmljID0gd2luLklvbmljIHx8IHt9O1xuICAgICAgICAgICAgSW9uaWMuY29uZmlnID0gX19hc3NpZ24oe30sIGNvbmZpZywgeyBfem9uZUdhdGU6ICgvKipcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gez99IGhcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChoKSB7IHJldHVybiB6b25lLnJ1bihoKTsgfSkgfSk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgYWVsRm5fMSA9ICdfX3pvbmVfc3ltYm9sX19hZGRFdmVudExpc3RlbmVyJyBpbiAoKC8qKiBAdHlwZSB7P30gKi8gKGRvYy5ib2R5KSkpXG4gICAgICAgICAgICAgICAgPyAnX196b25lX3N5bWJvbF9fYWRkRXZlbnRMaXN0ZW5lcidcbiAgICAgICAgICAgICAgICA6ICdhZGRFdmVudExpc3RlbmVyJztcbiAgICAgICAgICAgIHJldHVybiBhcHBseVBvbHlmaWxscygpLnRoZW4oKC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FbGVtZW50cyh3aW4sIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZTogWydpb24tdGFicycsICdpb24tdGFiJ10sXG4gICAgICAgICAgICAgICAgICAgIHN5bmNRdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmFmOiByYWYsXG4gICAgICAgICAgICAgICAgICAgIGptcDogKC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gez99IGhcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChoKSB7IHJldHVybiB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKGgpOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgYWVsOiAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHs/fSBlbG1cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHs/fSBjYlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gez99IG9wdHNcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbG0sIGV2ZW50TmFtZSwgY2IsIG9wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgoLyoqIEB0eXBlIHs/fSAqLyAoZWxtKSkpW2FlbEZuXzFdKGV2ZW50TmFtZSwgY2IsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWw6IC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gez99IGVsbVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gez99IGNiXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gb3B0c1xuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsbSwgZXZlbnROYW1lLCBjYiwgb3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYiwgb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKiogQHR5cGUgez99ICovXG52YXIgREVDTEFSQVRJT05TID0gW1xuICAgIC8vIHByb3hpZXNcbiAgICBJb25BcHAsXG4gICAgSW9uQXZhdGFyLFxuICAgIElvbkJhY2tCdXR0b24sXG4gICAgSW9uQmFja2Ryb3AsXG4gICAgSW9uQmFkZ2UsXG4gICAgSW9uQnV0dG9uLFxuICAgIElvbkJ1dHRvbnMsXG4gICAgSW9uQ2FyZCxcbiAgICBJb25DYXJkQ29udGVudCxcbiAgICBJb25DYXJkSGVhZGVyLFxuICAgIElvbkNhcmRTdWJ0aXRsZSxcbiAgICBJb25DYXJkVGl0bGUsXG4gICAgSW9uQ2hlY2tib3gsXG4gICAgSW9uQ2hpcCxcbiAgICBJb25Db2wsXG4gICAgSW9uQ29udGVudCxcbiAgICBJb25EYXRldGltZSxcbiAgICBJb25GYWIsXG4gICAgSW9uRmFiQnV0dG9uLFxuICAgIElvbkZhYkxpc3QsXG4gICAgSW9uRm9vdGVyLFxuICAgIElvbkdyaWQsXG4gICAgSW9uSGVhZGVyLFxuICAgIElvbkljb24sXG4gICAgSW9uSW1nLFxuICAgIElvbkluZmluaXRlU2Nyb2xsLFxuICAgIElvbkluZmluaXRlU2Nyb2xsQ29udGVudCxcbiAgICBJb25JbnB1dCxcbiAgICBJb25JdGVtLFxuICAgIElvbkl0ZW1EaXZpZGVyLFxuICAgIElvbkl0ZW1Hcm91cCxcbiAgICBJb25JdGVtT3B0aW9uLFxuICAgIElvbkl0ZW1PcHRpb25zLFxuICAgIElvbkl0ZW1TbGlkaW5nLFxuICAgIElvbkxhYmVsLFxuICAgIElvbkxpc3QsXG4gICAgSW9uTGlzdEhlYWRlcixcbiAgICBJb25NZW51LFxuICAgIElvbk1lbnVCdXR0b24sXG4gICAgSW9uTWVudVRvZ2dsZSxcbiAgICBJb25OYXYsXG4gICAgSW9uTmF2TGluayxcbiAgICBJb25OYXZQb3AsXG4gICAgSW9uTmF2UHVzaCxcbiAgICBJb25OYXZTZXRSb290LFxuICAgIElvbk5vdGUsXG4gICAgSW9uUHJvZ3Jlc3NCYXIsXG4gICAgSW9uUmFkaW8sXG4gICAgSW9uUmFkaW9Hcm91cCxcbiAgICBJb25SYW5nZSxcbiAgICBJb25SZWZyZXNoZXIsXG4gICAgSW9uUmVmcmVzaGVyQ29udGVudCxcbiAgICBJb25SZW9yZGVyLFxuICAgIElvblJlb3JkZXJHcm91cCxcbiAgICBJb25SaXBwbGVFZmZlY3QsXG4gICAgSW9uUm93LFxuICAgIElvblNlYXJjaGJhcixcbiAgICBJb25TZWdtZW50LFxuICAgIElvblNlZ21lbnRCdXR0b24sXG4gICAgSW9uU2VsZWN0LFxuICAgIElvblNlbGVjdE9wdGlvbixcbiAgICBJb25Ta2VsZXRvblRleHQsXG4gICAgSW9uU2xpZGUsXG4gICAgSW9uU2xpZGVzLFxuICAgIElvblNwaW5uZXIsXG4gICAgSW9uU3BsaXRQYW5lLFxuICAgIElvblRhYkJhcixcbiAgICBJb25UYWJCdXR0b24sXG4gICAgSW9uVGV4dCxcbiAgICBJb25UZXh0YXJlYSxcbiAgICBJb25UaHVtYm5haWwsXG4gICAgSW9uVG9nZ2xlLFxuICAgIElvblRvb2xiYXIsXG4gICAgSW9uVGl0bGUsXG4gICAgSW9uVGFicyxcbiAgICAvLyBuZ01vZGVsIGFjY2Vzc29yc1xuICAgIEJvb2xlYW5WYWx1ZUFjY2Vzc29yLFxuICAgIE51bWVyaWNWYWx1ZUFjY2Vzc29yLFxuICAgIFJhZGlvVmFsdWVBY2Nlc3NvcixcbiAgICBTZWxlY3RWYWx1ZUFjY2Vzc29yLFxuICAgIFRleHRWYWx1ZUFjY2Vzc29yLFxuICAgIC8vIG5hdmlnYXRpb25cbiAgICBJb25Sb3V0ZXJPdXRsZXQsXG4gICAgSW9uQmFja0J1dHRvbkRlbGVnYXRlLFxuICAgIE5hdkRlbGVnYXRlLFxuICAgIFJvdXRlckxpbmtEZWxlZ2F0ZSxcbiAgICAvLyB2aXJ0dWFsIHNjcm9sbFxuICAgIFZpcnR1YWxGb290ZXIsXG4gICAgVmlydHVhbEhlYWRlcixcbiAgICBWaXJ0dWFsSXRlbSxcbiAgICBJb25WaXJ0dWFsU2Nyb2xsLFxuICAgIC8vIERlcHJlY2F0aW9uc1xuICAgIENzc1V0aWxzRGVwcmVjYXRpb25zXG5dO1xudmFyIElvbmljTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElvbmljTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIElvbmljTW9kdWxlLmZvclJvb3QgPSAvKipcbiAgICAgKiBAcGFyYW0gez89fSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBJb25pY01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQ29uZmlnVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiBjb25maWdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQVBQX0lOSVRJQUxJWkVSLFxuICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBhcHBJbml0aWFsaXplLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGVwczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgQ29uZmlnVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBET0NVTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIE5nWm9uZVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgSW9uaWNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlMsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IERFQ0xBUkFUSU9OUyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbQW5ndWxhckRlbGVnYXRlLCBNb2RhbENvbnRyb2xsZXIsIFBvcG92ZXJDb250cm9sbGVyXSxcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIHJldHVybiBJb25pY01vZHVsZTtcbn0oKSk7XG5cbmV4cG9ydCB7IEFjdGlvblNoZWV0Q29udHJvbGxlciwgQWxlcnRDb250cm9sbGVyLCBBbmd1bGFyRGVsZWdhdGUsIEJvb2xlYW5WYWx1ZUFjY2Vzc29yLCBDb25maWcsIENzc1V0aWxzRGVwcmVjYXRpb25zLCBEb21Db250cm9sbGVyLCBFdmVudHMsIElvbkFwcCwgSW9uQXZhdGFyLCBJb25CYWNrQnV0dG9uLCBJb25CYWNrQnV0dG9uRGVsZWdhdGUsIElvbkJhY2tkcm9wLCBJb25CYWRnZSwgSW9uQnV0dG9uLCBJb25CdXR0b25zLCBJb25DYXJkLCBJb25DYXJkQ29udGVudCwgSW9uQ2FyZEhlYWRlciwgSW9uQ2FyZFN1YnRpdGxlLCBJb25DYXJkVGl0bGUsIElvbkNoZWNrYm94LCBJb25DaGlwLCBJb25Db2wsIElvbkNvbnRlbnQsIElvbkRhdGV0aW1lLCBJb25GYWIsIElvbkZhYkJ1dHRvbiwgSW9uRmFiTGlzdCwgSW9uRm9vdGVyLCBJb25HcmlkLCBJb25IZWFkZXIsIElvbkljb24sIElvbkltZywgSW9uSW5maW5pdGVTY3JvbGwsIElvbkluZmluaXRlU2Nyb2xsQ29udGVudCwgSW9uSW5wdXQsIElvbkl0ZW0sIElvbkl0ZW1EaXZpZGVyLCBJb25JdGVtR3JvdXAsIElvbkl0ZW1PcHRpb24sIElvbkl0ZW1PcHRpb25zLCBJb25JdGVtU2xpZGluZywgSW9uTGFiZWwsIElvbkxpc3QsIElvbkxpc3RIZWFkZXIsIElvbk1lbnUsIElvbk1lbnVCdXR0b24sIElvbk1lbnVUb2dnbGUsIElvbk5hdiwgSW9uTmF2TGluaywgSW9uTmF2UG9wLCBJb25OYXZQdXNoLCBJb25OYXZTZXRSb290LCBJb25Ob3RlLCBJb25Qcm9ncmVzc0JhciwgSW9uUmFkaW8sIElvblJhZGlvR3JvdXAsIElvblJhbmdlLCBJb25SZWZyZXNoZXIsIElvblJlZnJlc2hlckNvbnRlbnQsIElvblJlb3JkZXIsIElvblJlb3JkZXJHcm91cCwgSW9uUmlwcGxlRWZmZWN0LCBJb25Sb3V0ZXJPdXRsZXQsIElvblJvdywgSW9uU2VhcmNoYmFyLCBJb25TZWdtZW50LCBJb25TZWdtZW50QnV0dG9uLCBJb25TZWxlY3QsIElvblNlbGVjdE9wdGlvbiwgSW9uU2tlbGV0b25UZXh0LCBJb25TbGlkZSwgSW9uU2xpZGVzLCBJb25TcGlubmVyLCBJb25TcGxpdFBhbmUsIElvblRhYkJhciwgSW9uVGFiQnV0dG9uLCBJb25UYWJzLCBJb25UZXh0LCBJb25UZXh0YXJlYSwgSW9uVGh1bWJuYWlsLCBJb25UaXRsZSwgSW9uVG9nZ2xlLCBJb25Ub29sYmFyLCBJb25WaXJ0dWFsU2Nyb2xsLCBJb25pY01vZHVsZSwgSW9uaWNSb3V0ZVN0cmF0ZWd5LCBMb2FkaW5nQ29udHJvbGxlciwgTWVudUNvbnRyb2xsZXIsIE1vZGFsQ29udHJvbGxlciwgTmF2Q29udHJvbGxlciwgTmF2RGVsZWdhdGUsIE5hdlBhcmFtcywgTnVtZXJpY1ZhbHVlQWNjZXNzb3IsIFBpY2tlckNvbnRyb2xsZXIsIFBsYXRmb3JtLCBQb3BvdmVyQ29udHJvbGxlciwgUmFkaW9WYWx1ZUFjY2Vzc29yLCBSb3V0ZXJMaW5rRGVsZWdhdGUsIFNlbGVjdFZhbHVlQWNjZXNzb3IsIFRleHRWYWx1ZUFjY2Vzc29yLCBUb2FzdENvbnRyb2xsZXIsIFZpcnR1YWxGb290ZXIsIFZpcnR1YWxIZWFkZXIsIFZpcnR1YWxJdGVtLCBDb25maWdUb2tlbiBhcyDJtWEsIFZhbHVlQWNjZXNzb3IgYXMgybViLCBPdmVybGF5QmFzZUNvbnRyb2xsZXIgYXMgybVkLCBhcHBJbml0aWFsaXplIGFzIMm1ZSB9O1xuIl19